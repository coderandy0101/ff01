#RequireAdmin
#Region
	#AutoIt3Wrapper_Icon=icon.ico
	#AutoIt3Wrapper_Run_AU3Check=n
#EndRegion
#Region
#EndRegion
OnAutoItExitRegister("OnAutoItExit")
Global Const $bs_groupbox = 7
Global Const $bs_bottom = 2048
Global Const $bs_center = 768
Global Const $bs_defpushbutton = 1
Global Const $bs_left = 256
Global Const $bs_multiline = 8192
Global Const $bs_pushbox = 10
Global Const $bs_pushlike = 4096
Global Const $bs_right = 512
Global Const $bs_rightbutton = 32
Global Const $bs_top = 1024
Global Const $bs_vcenter = 3072
Global Const $bs_flat = 32768
Global Const $bs_icon = 64
Global Const $bs_bitmap = 128
Global Const $bs_notify = 16384
Global Const $bs_splitbutton = 12
Global Const $bs_defsplitbutton = 13
Global Const $bs_commandlink = 14
Global Const $bs_defcommandlink = 15
Global Const $bcsif_glyph = 1
Global Const $bcsif_image = 2
Global Const $bcsif_style = 4
Global Const $bcsif_size = 8
Global Const $bcss_nosplit = 1
Global Const $bcss_stretch = 2
Global Const $bcss_alignleft = 4
Global Const $bcss_image = 8
Global Const $button_imagelist_align_left = 0
Global Const $button_imagelist_align_right = 1
Global Const $button_imagelist_align_top = 2
Global Const $button_imagelist_align_bottom = 3
Global Const $button_imagelist_align_center = 4
Global Const $bs_3state = 5
Global Const $bs_auto3state = 6
Global Const $bs_autocheckbox = 3
Global Const $bs_checkbox = 2
Global Const $bs_radiobutton = 4
Global Const $bs_autoradiobutton = 9
Global Const $bs_ownerdraw = 11
Global Const $gui_ss_default_button = 0
Global Const $gui_ss_default_checkbox = 0
Global Const $gui_ss_default_group = 0
Global Const $gui_ss_default_radio = 0
Global Const $bcm_first = 5632
Global Const $bcm_getidealsize = ($bcm_first + 1)
Global Const $bcm_getimagelist = ($bcm_first + 3)
Global Const $bcm_getnote = ($bcm_first + 10)
Global Const $bcm_getnotelength = ($bcm_first + 11)
Global Const $bcm_getsplitinfo = ($bcm_first + 8)
Global Const $bcm_gettextmargin = ($bcm_first + 5)
Global Const $bcm_setdropdownstate = ($bcm_first + 6)
Global Const $bcm_setimagelist = ($bcm_first + 2)
Global Const $bcm_setnote = ($bcm_first + 9)
Global Const $bcm_setshield = ($bcm_first + 12)
Global Const $bcm_setsplitinfo = ($bcm_first + 7)
Global Const $bcm_settextmargin = ($bcm_first + 4)
Global Const $bm_click = 245
Global Const $bm_getcheck = 240
Global Const $bm_getimage = 246
Global Const $bm_getstate = 242
Global Const $bm_setcheck = 241
Global Const $bm_setdontclick = 248
Global Const $bm_setimage = 247
Global Const $bm_setstate = 243
Global Const $bm_setstyle = 244
Global Const $bcn_first = -1250
Global Const $bcn_dropdown = ($bcn_first + 2)
Global Const $bcn_hotitemchange = ($bcn_first + 1)
Global Const $bn_clicked = 0
Global Const $bn_paint = 1
Global Const $bn_hilite = 2
Global Const $bn_unhilite = 3
Global Const $bn_disable = 4
Global Const $bn_doubleclicked = 5
Global Const $bn_setfocus = 6
Global Const $bn_killfocus = 7
Global Const $bn_pushed = $bn_hilite
Global Const $bn_unpushed = $bn_unhilite
Global Const $bn_dblclk = $bn_doubleclicked
Global Const $bst_checked = 1
Global Const $bst_indeterminate = 2
Global Const $bst_unchecked = 0
Global Const $bst_focus = 8
Global Const $bst_pushed = 4
Global Const $bst_dontclick = 128
Global Const $cb_err = -1
Global Const $cb_errattribute = -3
Global Const $cb_errrequired = -4
Global Const $cb_errspace = -2
Global Const $cb_okay = 0
Global Const $state_system_invisible = 32768
Global Const $state_system_pressed = 8
Global Const $cbs_autohscroll = 64
Global Const $cbs_disablenoscroll = 2048
Global Const $cbs_dropdown = 2
Global Const $cbs_dropdownlist = 3
Global Const $cbs_hasstrings = 512
Global Const $cbs_lowercase = 16384
Global Const $cbs_nointegralheight = 1024
Global Const $cbs_oemconvert = 128
Global Const $cbs_ownerdrawfixed = 16
Global Const $cbs_ownerdrawvariable = 32
Global Const $cbs_simple = 1
Global Const $cbs_sort = 256
Global Const $cbs_uppercase = 8192
Global Const $cbm_first = 5888
Global Const $cb_addstring = 323
Global Const $cb_deletestring = 324
Global Const $cb_dir = 325
Global Const $cb_findstring = 332
Global Const $cb_findstringexact = 344
Global Const $cb_getcomboboxinfo = 356
Global Const $cb_getcount = 326
Global Const $cb_getcuebanner = ($cbm_first + 4)
Global Const $cb_getcursel = 327
Global Const $cb_getdroppedcontrolrect = 338
Global Const $cb_getdroppedstate = 343
Global Const $cb_getdroppedwidth = 351
Global Const $cb_geteditsel = 320
Global Const $cb_getextendedui = 342
Global Const $cb_gethorizontalextent = 349
Global Const $cb_getitemdata = 336
Global Const $cb_getitemheight = 340
Global Const $cb_getlbtext = 328
Global Const $cb_getlbtextlen = 329
Global Const $cb_getlocale = 346
Global Const $cb_getminvisible = 5890
Global Const $cb_gettopindex = 347
Global Const $cb_initstorage = 353
Global Const $cb_limittext = 321
Global Const $cb_resetcontent = 331
Global Const $cb_insertstring = 330
Global Const $cb_selectstring = 333
Global Const $cb_setcuebanner = ($cbm_first + 3)
Global Const $cb_setcursel = 334
Global Const $cb_setdroppedwidth = 352
Global Const $cb_seteditsel = 322
Global Const $cb_setextendedui = 341
Global Const $cb_sethorizontalextent = 350
Global Const $cb_setitemdata = 337
Global Const $cb_setitemheight = 339
Global Const $cb_setlocale = 345
Global Const $cb_setminvisible = 5889
Global Const $cb_settopindex = 348
Global Const $cb_showdropdown = 335
Global Const $cbn_closeup = 8
Global Const $cbn_dblclk = 2
Global Const $cbn_dropdown = 7
Global Const $cbn_editchange = 5
Global Const $cbn_editupdate = 6
Global Const $cbn_errspace = (-1)
Global Const $cbn_killfocus = 4
Global Const $cbn_selchange = 1
Global Const $cbn_selendcancel = 10
Global Const $cbn_selendok = 9
Global Const $cbn_setfocus = 3
Global Const $cbes_ex_casesensitive = 16
Global Const $cbes_ex_noeditimage = 1
Global Const $cbes_ex_noeditimageindent = 2
Global Const $cbes_ex_nosizelimit = 8
Global Const $__comboboxconstant_wm_user = 1024
Global Const $cbem_deleteitem = $cb_deletestring
Global Const $cbem_getcombocontrol = ($__comboboxconstant_wm_user + 6)
Global Const $cbem_geteditcontrol = ($__comboboxconstant_wm_user + 7)
Global Const $cbem_getexstyle = ($__comboboxconstant_wm_user + 9)
Global Const $cbem_getextendedstyle = ($__comboboxconstant_wm_user + 9)
Global Const $cbem_getimagelist = ($__comboboxconstant_wm_user + 3)
Global Const $cbem_getitema = ($__comboboxconstant_wm_user + 4)
Global Const $cbem_getitemw = ($__comboboxconstant_wm_user + 13)
Global Const $cbem_getunicodeformat = 8192 + 6
Global Const $cbem_haseditchanged = ($__comboboxconstant_wm_user + 10)
Global Const $cbem_insertitema = ($__comboboxconstant_wm_user + 1)
Global Const $cbem_insertitemw = ($__comboboxconstant_wm_user + 11)
Global Const $cbem_setexstyle = ($__comboboxconstant_wm_user + 8)
Global Const $cbem_setextendedstyle = ($__comboboxconstant_wm_user + 14)
Global Const $cbem_setimagelist = ($__comboboxconstant_wm_user + 2)
Global Const $cbem_setitema = ($__comboboxconstant_wm_user + 5)
Global Const $cbem_setitemw = ($__comboboxconstant_wm_user + 12)
Global Const $cbem_setunicodeformat = 8192 + 5
Global Const $cbem_setwindowtheme = 8192 + 11
Global Const $cben_first = (-800)
Global Const $cben_last = (-830)
Global Const $cben_beginedit = ($cben_first - 4)
Global Const $cben_deleteitem = ($cben_first - 2)
Global Const $cben_dragbegina = ($cben_first - 8)
Global Const $cben_dragbeginw = ($cben_first - 9)
Global Const $cben_endedita = ($cben_first - 5)
Global Const $cben_endeditw = ($cben_first - 6)
Global Const $cben_getdispinfo = ($cben_first + 0)
Global Const $cben_getdispinfoa = ($cben_first + 0)
Global Const $cben_getdispinfow = ($cben_first - 7)
Global Const $cben_insertitem = ($cben_first - 1)
Global Const $cbeif_di_setitem = 268435456
Global Const $cbeif_image = 2
Global Const $cbeif_indent = 16
Global Const $cbeif_lparam = 32
Global Const $cbeif_overlay = 8
Global Const $cbeif_selectedimage = 4
Global Const $cbeif_text = 1
Global Const $gui_ss_default_combo = 2097218
Global Const $es_left = 0
Global Const $es_center = 1
Global Const $es_right = 2
Global Const $es_multiline = 4
Global Const $es_uppercase = 8
Global Const $es_lowercase = 16
Global Const $es_password = 32
Global Const $es_autovscroll = 64
Global Const $es_autohscroll = 128
Global Const $es_nohidesel = 256
Global Const $es_oemconvert = 1024
Global Const $es_readonly = 2048
Global Const $es_wantreturn = 4096
Global Const $es_number = 8192
Global Const $ec_err = -1
Global Const $ecm_first = 5376
Global Const $em_canundo = 198
Global Const $em_charfrompos = 215
Global Const $em_emptyundobuffer = 205
Global Const $em_fmtlines = 200
Global Const $em_getcuebanner = ($ecm_first + 2)
Global Const $em_getfirstvisibleline = 206
Global Const $em_gethandle = 189
Global Const $em_getimestatus = 217
Global Const $em_getlimittext = 213
Global Const $em_getline = 196
Global Const $em_getlinecount = 186
Global Const $em_getmargins = 212
Global Const $em_getmodify = 184
Global Const $em_getpasswordchar = 210
Global Const $em_getrect = 178
Global Const $em_getsel = 176
Global Const $em_getthumb = 190
Global Const $em_getwordbreakproc = 209
Global Const $em_hideballoontip = ($ecm_first + 4)
Global Const $em_limittext = 197
Global Const $em_linefromchar = 201
Global Const $em_lineindex = 187
Global Const $em_linelength = 193
Global Const $em_linescroll = 182
Global Const $em_posfromchar = 214
Global Const $em_replacesel = 194
Global Const $em_scroll = 181
Global Const $em_scrollcaret = 183
Global Const $em_setcuebanner = ($ecm_first + 1)
Global Const $em_sethandle = 188
Global Const $em_setimestatus = 216
Global Const $em_setlimittext = $em_limittext
Global Const $em_setmargins = 211
Global Const $em_setmodify = 185
Global Const $em_setpasswordchar = 204
Global Const $em_setreadonly = 207
Global Const $em_setrect = 179
Global Const $em_setrectnp = 180
Global Const $em_setsel = 177
Global Const $em_settabstops = 203
Global Const $em_setwordbreakproc = 208
Global Const $em_showballoontip = ($ecm_first + 3)
Global Const $em_undo = 199
Global Const $ec_leftmargin = 1
Global Const $ec_rightmargin = 2
Global Const $ec_usefontinfo = 65535
Global Const $emsis_compositionstring = 1
Global Const $eimes_getcompstratonce = 1
Global Const $eimes_cancelcompstrinfocus = 2
Global Const $eimes_completecompstrkillfocus = 4
Global Const $en_align_ltr_ec = 1792
Global Const $en_align_rtl_ec = 1793
Global Const $en_change = 768
Global Const $en_errspace = 1280
Global Const $en_hscroll = 1537
Global Const $en_killfocus = 512
Global Const $en_maxtext = 1281
Global Const $en_setfocus = 256
Global Const $en_update = 1024
Global Const $en_vscroll = 1538
Global Const $gui_ss_default_edit = 3150016
Global Const $gui_ss_default_input = 128
Global Const $gui_event_single = 0
Global Const $gui_event_array = 1
Global Const $gui_event_none = 0
Global Const $gui_event_close = -3
Global Const $gui_event_minimize = -4
Global Const $gui_event_restore = -5
Global Const $gui_event_maximize = -6
Global Const $gui_event_primarydown = -7
Global Const $gui_event_primaryup = -8
Global Const $gui_event_secondarydown = -9
Global Const $gui_event_secondaryup = -10
Global Const $gui_event_mousemove = -11
Global Const $gui_event_resized = -12
Global Const $gui_event_dropped = -13
Global Const $gui_rundefmsg = "GUI_RUNDEFMSG"
Global Const $gui_avistop = 0
Global Const $gui_avistart = 1
Global Const $gui_aviclose = 2
Global Const $gui_checked = 1
Global Const $gui_indeterminate = 2
Global Const $gui_unchecked = 4
Global Const $gui_dropaccepted = 8
Global Const $gui_nodropaccepted = 4096
Global Const $gui_acceptfiles = $gui_dropaccepted
Global Const $gui_show = 16
Global Const $gui_hide = 32
Global Const $gui_enable = 64
Global Const $gui_disable = 128
Global Const $gui_focus = 256
Global Const $gui_nofocus = 8192
Global Const $gui_defbutton = 512
Global Const $gui_expand = 1024
Global Const $gui_ontop = 2048
Global Const $gui_fontnormal = 0
Global Const $gui_fontitalic = 2
Global Const $gui_fontunder = 4
Global Const $gui_fontstrike = 8
Global Const $gui_dockauto = 1
Global Const $gui_dockleft = 2
Global Const $gui_dockright = 4
Global Const $gui_dockhcenter = 8
Global Const $gui_docktop = 32
Global Const $gui_dockbottom = 64
Global Const $gui_dockvcenter = 128
Global Const $gui_dockwidth = 256
Global Const $gui_dockheight = 512
Global Const $gui_docksize = 768
Global Const $gui_dockmenubar = 544
Global Const $gui_dockstatebar = 576
Global Const $gui_dockall = 802
Global Const $gui_dockborders = 102
Global Const $gui_gr_close = 1
Global Const $gui_gr_line = 2
Global Const $gui_gr_bezier = 4
Global Const $gui_gr_move = 6
Global Const $gui_gr_color = 8
Global Const $gui_gr_rect = 10
Global Const $gui_gr_ellipse = 12
Global Const $gui_gr_pie = 14
Global Const $gui_gr_dot = 16
Global Const $gui_gr_pixel = 18
Global Const $gui_gr_hint = 20
Global Const $gui_gr_refresh = 22
Global Const $gui_gr_pensize = 24
Global Const $gui_gr_nobkcolor = -2
Global Const $gui_bkcolor_default = -1
Global Const $gui_bkcolor_transparent = -2
Global Const $gui_bkcolor_lv_alternate = -33554432
Global Const $gui_read_default = 0
Global Const $gui_read_extended = 1
Global Const $gui_cursor_nooverride = 0
Global Const $gui_cursor_override = 1
Global Const $gui_ws_ex_parentdrag = 1048576
Global Const $ss_left = 0
Global Const $ss_center = 1
Global Const $ss_right = 2
Global Const $ss_icon = 3
Global Const $ss_blackrect = 4
Global Const $ss_grayrect = 5
Global Const $ss_whiterect = 6
Global Const $ss_blackframe = 7
Global Const $ss_grayframe = 8
Global Const $ss_whiteframe = 9
Global Const $ss_simple = 11
Global Const $ss_leftnowordwrap = 12
Global Const $ss_bitmap = 14
Global Const $ss_enhmetafile = 15
Global Const $ss_etchedhorz = 16
Global Const $ss_etchedvert = 17
Global Const $ss_etchedframe = 18
Global Const $ss_realsizecontrol = 64
Global Const $ss_noprefix = 128
Global Const $ss_notify = 256
Global Const $ss_centerimage = 512
Global Const $ss_rightjust = 1024
Global Const $ss_sunken = 4096
Global Const $gui_ss_default_label = 0
Global Const $gui_ss_default_graphic = 0
Global Const $gui_ss_default_icon = $ss_notify
Global Const $gui_ss_default_pic = $ss_notify
Global Const $stm_seticon = 368
Global Const $stm_geticon = 369
Global Const $stm_setimage = 370
Global Const $stm_getimage = 371
Global Const $gdip_dashcapflat = 0
Global Const $gdip_dashcapround = 2
Global Const $gdip_dashcaptriangle = 3
Global Const $gdip_dashstylesolid = 0
Global Const $gdip_dashstyledash = 1
Global Const $gdip_dashstyledot = 2
Global Const $gdip_dashstyledashdot = 3
Global Const $gdip_dashstyledashdotdot = 4
Global Const $gdip_dashstylecustom = 5
Global Const $gdip_epgchrominancetable = "{F2E455DC-09B3-4316-8260-676ADA32481C}"
Global Const $gdip_epgcolordepth = "{66087055-AD66-4C7C-9A18-38A2310B8337}"
Global Const $gdip_epgcompression = "{E09D739D-CCD4-44EE-8EBA-3FBF8BE4FC58}"
Global Const $gdip_epgluminancetable = "{EDB33BCE-0266-4A77-B904-27216099E717}"
Global Const $gdip_epgquality = "{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}"
Global Const $gdip_epgrendermethod = "{6D42C53A-229A-4825-8BB7-5C99E2B9A8B8}"
Global Const $gdip_epgsaveflag = "{292266FC-AC40-47BF-8CFC-A85B89A655DE}"
Global Const $gdip_epgscanmethod = "{3A4E2661-3109-4E56-8536-42C156E7DCFA}"
Global Const $gdip_epgtransformation = "{8D0EB2D1-A58E-4EA8-AA14-108074B7B6F9}"
Global Const $gdip_epgversion = "{24D18C76-814A-41A4-BF53-1C219CCCF797}"
Global Const $gdip_eptbyte = 1
Global Const $gdip_eptascii = 2
Global Const $gdip_eptshort = 3
Global Const $gdip_eptlong = 4
Global Const $gdip_eptrational = 5
Global Const $gdip_eptlongrange = 6
Global Const $gdip_eptundefined = 7
Global Const $gdip_eptrationalrange = 8
Global Const $gdip_errok = 0
Global Const $gdip_errgenericerror = 1
Global Const $gdip_errinvalidparameter = 2
Global Const $gdip_erroutofmemory = 3
Global Const $gdip_errobjectbusy = 4
Global Const $gdip_errinsufficientbuffer = 5
Global Const $gdip_errnotimplemented = 6
Global Const $gdip_errwin32error = 7
Global Const $gdip_errwrongstate = 8
Global Const $gdip_erraborted = 9
Global Const $gdip_errfilenotfound = 10
Global Const $gdip_errvalueoverflow = 11
Global Const $gdip_erraccessdenied = 12
Global Const $gdip_errunknownimageformat = 13
Global Const $gdip_errfontfamilynotfound = 14
Global Const $gdip_errfontstylenotfound = 15
Global Const $gdip_errnottruetypefont = 16
Global Const $gdip_errunsupportedgdiversion = 17
Global Const $gdip_errgdiplusnotinitialized = 18
Global Const $gdip_errpropertynotfound = 19
Global Const $gdip_errpropertynotsupported = 20
Global Const $gdip_evtcompressionlzw = 2
Global Const $gdip_evtcompressionccitt3 = 3
Global Const $gdip_evtcompressionccitt4 = 4
Global Const $gdip_evtcompressionrle = 5
Global Const $gdip_evtcompressionnone = 6
Global Const $gdip_evttransformrotate90 = 13
Global Const $gdip_evttransformrotate180 = 14
Global Const $gdip_evttransformrotate270 = 15
Global Const $gdip_evttransformfliphorizontal = 16
Global Const $gdip_evttransformflipvertical = 17
Global Const $gdip_evtmultiframe = 18
Global Const $gdip_evtlastframe = 19
Global Const $gdip_evtflush = 20
Global Const $gdip_evtframedimensionpage = 23
Global Const $gdip_icfencoder = 1
Global Const $gdip_icfdecoder = 2
Global Const $gdip_icfsupportbitmap = 4
Global Const $gdip_icfsupportvector = 8
Global Const $gdip_icfseekableencode = 16
Global Const $gdip_icfblockingdecode = 32
Global Const $gdip_icfbuiltin = 65536
Global Const $gdip_icfsystem = 131072
Global Const $gdip_icfuser = 262144
Global Const $gdip_ilmread = 1
Global Const $gdip_ilmwrite = 2
Global Const $gdip_ilmuserinputbuf = 4
Global Const $gdip_linecapflat = 0
Global Const $gdip_linecapsquare = 1
Global Const $gdip_linecapround = 2
Global Const $gdip_linecaptriangle = 3
Global Const $gdip_linecapnoanchor = 16
Global Const $gdip_linecapsquareanchor = 17
Global Const $gdip_linecaproundanchor = 18
Global Const $gdip_linecapdiamondanchor = 19
Global Const $gdip_linecaparrowanchor = 20
Global Const $gdip_linecapcustom = 255
Global Const $gdip_pxf01indexed = 196865
Global Const $gdip_pxf04indexed = 197634
Global Const $gdip_pxf08indexed = 198659
Global Const $gdip_pxf16grayscale = 1052676
Global Const $gdip_pxf16rgb555 = 135173
Global Const $gdip_pxf16rgb565 = 135174
Global Const $gdip_pxf16argb1555 = 397319
Global Const $gdip_pxf24rgb = 137224
Global Const $gdip_pxf32rgb = 139273
Global Const $gdip_pxf32argb = 2498570
Global Const $gdip_pxf32pargb = 925707
Global Const $gdip_pxf48rgb = 1060876
Global Const $gdip_pxf64argb = 3424269
Global Const $gdip_pxf64pargb = 1720334
Global Const $gdip_imageformat_undefined = "{B96B3CA9-0728-11D3-9D7B-0000F81EF32E}"
Global Const $gdip_imageformat_memorybmp = "{B96B3CAA-0728-11D3-9D7B-0000F81EF32E}"
Global Const $gdip_imageformat_bmp = "{B96B3CAB-0728-11D3-9D7B-0000F81EF32E}"
Global Const $gdip_imageformat_emf = "{B96B3CAC-0728-11D3-9D7B-0000F81EF32E}"
Global Const $gdip_imageformat_wmf = "{B96B3CAD-0728-11D3-9D7B-0000F81EF32E}"
Global Const $gdip_imageformat_jpeg = "{B96B3CAE-0728-11D3-9D7B-0000F81EF32E}"
Global Const $gdip_imageformat_png = "{B96B3CAF-0728-11D3-9D7B-0000F81EF32E}"
Global Const $gdip_imageformat_gif = "{B96B3CB0-0728-11D3-9D7B-0000F81EF32E}"
Global Const $gdip_imageformat_tiff = "{B96B3CB1-0728-11D3-9D7B-0000F81EF32E}"
Global Const $gdip_imageformat_exif = "{B96B3CB2-0728-11D3-9D7B-0000F81EF32E}"
Global Const $gdip_imageformat_icon = "{B96B3CB5-0728-11D3-9D7B-0000F81EF32E}"
Global Const $gdip_imagetype_unknown = 0
Global Const $gdip_imagetype_bitmap = 1
Global Const $gdip_imagetype_metafile = 2
Global Const $gdip_imageflags_none = 0
Global Const $gdip_imageflags_scalable = 1
Global Const $gdip_imageflags_hasalpha = 2
Global Const $gdip_imageflags_hastranslucent = 4
Global Const $gdip_imageflags_partiallyscalable = 8
Global Const $gdip_imageflags_colorspace_rgb = 16
Global Const $gdip_imageflags_colorspace_cmyk = 32
Global Const $gdip_imageflags_colorspace_gray = 64
Global Const $gdip_imageflags_colorspace_ycbcr = 128
Global Const $gdip_imageflags_colorspace_ycck = 256
Global Const $gdip_imageflags_hasrealdpi = 4096
Global Const $gdip_imageflags_hasrealpixelsize = 8192
Global Const $gdip_imageflags_readonly = 65536
Global Const $gdip_imageflags_caching = 131072
Global Const $gdip_smoothingmode_invalid = -1
Global Const $gdip_smoothingmode_default = 0
Global Const $gdip_smoothingmode_highspeed = 1
Global Const $gdip_smoothingmode_highquality = 2
Global Const $gdip_smoothingmode_none = 3
Global Const $gdip_smoothingmode_antialias8x4 = 4
Global Const $gdip_smoothingmode_antialias = $gdip_smoothingmode_antialias8x4
Global Const $gdip_smoothingmode_antialias8x8 = 5
Global Const $gdip_rlum = 0.3086
Global Const $gdip_glum = 0.6094
Global Const $gdip_blum = 0.082
Global Const $gdip_interpolationmode_invalid = -1
Global Const $gdip_interpolationmode_default = 0
Global Const $gdip_interpolationmode_lowquality = 1
Global Const $gdip_interpolationmode_highquality = 2
Global Const $gdip_interpolationmode_bilinear = 3
Global Const $gdip_interpolationmode_bicubic = 4
Global Const $gdip_interpolationmode_nearestneighbor = 5
Global Const $gdip_interpolationmode_highqualitybilinear = 6
Global Const $gdip_interpolationmode_highqualitybicubic = 7
Global Const $gdip_textrenderinghint_systemdefault = 0
Global Const $gdip_textrenderinghint_singlebitperpixelgridfit = 1
Global Const $gdip_textrenderinghint_singlebitperpixel = 2
Global Const $gdip_textrenderinghint_antialiasgridfit = 3
Global Const $gdip_textrenderinghint_antialias = 4
Global Const $gdip_textrenderinghint_cleartypegridfit = 5
Global Const $gdip_pixeloffsetmode_invalid = -1
Global Const $gdip_pixeloffsetmode_default = 0
Global Const $gdip_pixeloffsetmode_highspeed = 1
Global Const $gdip_pixeloffsetmode_highquality = 2
Global Const $gdip_pixeloffsetmode_none = 3
Global Const $gdip_pixeloffsetmode_half = 4
Global Const $gdip_pensetlinejoin_miter = 0
Global Const $gdip_pensetlinejoin_bevel = 1
Global Const $gdip_pensetlinejoin_round = 2
Global Const $gdip_pensetlinejoin_miterclipped = 3
Global Const $gdip_fillmodealternate = 0
Global Const $gdip_fillmodewinding = 1
Global Const $gdip_qualitymodeinvalid = -1
Global Const $gdip_qualitymodedefault = 0
Global Const $gdip_qualitymodelow = 1
Global Const $gdip_qualitymodehigh = 2
Global Const $gdip_compositingmodesourceover = 0
Global Const $gdip_compositingmodesourcecopy = 1
Global Const $gdip_compositingqualityinvalid = $gdip_qualitymodeinvalid
Global Const $gdip_compositingqualitydefault = $gdip_qualitymodedefault
Global Const $gdip_compositingqualityhighspeed = $gdip_qualitymodelow
Global Const $gdip_compositingqualityhighquality = $gdip_qualitymodehigh
Global Const $gdip_compositingqualitygammacorrected = 3
Global Const $gdip_compositingqualityassumelinear = 4
Global Const $gdip_hatchstyle_horizontal = 0
Global Const $gdip_hatchstyle_vertical = 1
Global Const $gdip_hatchstyle_forwarddiagonal = 2
Global Const $gdip_hatchstyle_backwarddiagonal = 3
Global Const $gdip_hatchstyle_cross = 4
Global Const $gdip_hatchstyle_diagonalcross = 5
Global Const $gdip_hatchstyle_05percent = 6
Global Const $gdip_hatchstyle_10percent = 7
Global Const $gdip_hatchstyle_20percent = 8
Global Const $gdip_hatchstyle_25percent = 9
Global Const $gdip_hatchstyle_30percent = 10
Global Const $gdip_hatchstyle_40percent = 11
Global Const $gdip_hatchstyle_50percent = 12
Global Const $gdip_hatchstyle_60percent = 13
Global Const $gdip_hatchstyle_70percent = 14
Global Const $gdip_hatchstyle_75percent = 15
Global Const $gdip_hatchstyle_80percent = 16
Global Const $gdip_hatchstyle_90percent = 17
Global Const $gdip_hatchstyle_lightdownwarddiagonal = 18
Global Const $gdip_hatchstyle_lightupwarddiagonal = 19
Global Const $gdip_hatchstyle_darkdownwarddiagonal = 20
Global Const $gdip_hatchstyle_darkupwarddiagonal = 21
Global Const $gdip_hatchstyle_widedownwarddiagonal = 22
Global Const $gdip_hatchstyle_wideupwarddiagonal = 23
Global Const $gdip_hatchstyle_lightvertical = 24
Global Const $gdip_hatchstyle_lighthorizontal = 25
Global Const $gdip_hatchstyle_narrowvertical = 26
Global Const $gdip_hatchstyle_narrowhorizontal = 27
Global Const $gdip_hatchstyle_darkvertical = 28
Global Const $gdip_hatchstyle_darkhorizontal = 29
Global Const $gdip_hatchstyle_dasheddownwarddiagonal = 30
Global Const $gdip_hatchstyle_dashedupwarddiagonal = 31
Global Const $gdip_hatchstyle_dashedhorizontal = 32
Global Const $gdip_hatchstyle_dashedvertical = 33
Global Const $gdip_hatchstyle_smallconfetti = 34
Global Const $gdip_hatchstyle_largeconfetti = 35
Global Const $gdip_hatchstyle_zigzag = 36
Global Const $gdip_hatchstyle_wave = 37
Global Const $gdip_hatchstyle_diagonalbrick = 38
Global Const $gdip_hatchstyle_horizontalbrick = 39
Global Const $gdip_hatchstyle_weave = 40
Global Const $gdip_hatchstyle_plaid = 41
Global Const $gdip_hatchstyle_divot = 42
Global Const $gdip_hatchstyle_dottedgrid = 43
Global Const $gdip_hatchstyle_dotteddiamond = 44
Global Const $gdip_hatchstyle_shingle = 45
Global Const $gdip_hatchstyle_trellis = 46
Global Const $gdip_hatchstyle_sphere = 47
Global Const $gdip_hatchstyle_smallgrid = 48
Global Const $gdip_hatchstyle_smallcheckerboard = 49
Global Const $gdip_hatchstyle_largecheckerboard = 50
Global Const $gdip_hatchstyle_outlineddiamond = 51
Global Const $gdip_hatchstyle_soliddiamond = 52
Global Const $gdip_hatchstyle_total = 53
Global Const $gdip_hatchstyle_largegrid = $gdip_hatchstyle_cross
Global Const $gdip_hatchstyle_min = $gdip_hatchstyle_horizontal
Global Const $gdip_hatchstyle_max = $gdip_hatchstyle_total - 1
Global Const $gdip_blureffectguid = "{633C80A4-1843-482b-9EF2-BE2834C5FDD4}"
Global Const $gdip_sharpeneffectguid = "{63CBF3EE-C526-402c-8F71-62C540BF5142}"
Global Const $gdip_colormatrixeffectguid = "{718F2615-7933-40e3-A511-5F68FE14DD74}"
Global Const $gdip_colorluteffectguid = "{A7CE72A9-0F7F-40d7-B3CC-D0C02D5C3212}"
Global Const $gdip_brightnesscontrasteffectguid = "{D3A1DBE1-8EC4-4c17-9F4C-EA97AD1C343D}"
Global Const $gdip_huesaturationlightnesseffectguid = "{8B2DD6C3-EB07-4d87-A5F0-7108E26A9C5F}"
Global Const $gdip_levelseffectguid = "{99C354EC-2A31-4f3a-8C34-17A803B33A25}"
Global Const $gdip_tinteffectguid = "{1077AF00-2848-4441-9489-44AD4C2D7A2C}"
Global Const $gdip_colorbalanceeffectguid = "{537E597D-251E-48da-9664-29CA496B70F8}"
Global Const $gdip_redeyecorrectioneffectguid = "{74D29D05-69A4-4266-9549-3CC52836B632}"
Global Const $gdip_colorcurveeffectguid = "{DD6A0022-58E4-4a67-9D9B-D48EB881A53D}"
Global Const $gdip_adjustexposure = 0
Global Const $gdip_adjustdensity = 1
Global Const $gdip_adjustcontrast = 2
Global Const $gdip_adjusthighlight = 3
Global Const $gdip_adjustshadow = 4
Global Const $gdip_adjustmidtone = 5
Global Const $gdip_adjustwhitesaturation = 6
Global Const $gdip_adjustblacksaturation = 7
Global Const $gdip_curvechannelall = 0
Global Const $gdip_curvechannelred = 1
Global Const $gdip_curvechannelgreen = 2
Global Const $gdip_curvechannelblue = 3
Global Const $gdip_palettetypecustom = 0
Global Const $gdip_palettetypeoptimal = 1
Global Const $gdip_palettetypefixedbw = 2
Global Const $gdip_palettetypefixedhalftone8 = 3
Global Const $gdip_palettetypefixedhalftone27 = 4
Global Const $gdip_palettetypefixedhalftone64 = 5
Global Const $gdip_palettetypefixedhalftone125 = 6
Global Const $gdip_palettetypefixedhalftone216 = 7
Global Const $gdip_palettetypefixedhalftone252 = 8
Global Const $gdip_palettetypefixedhalftone256 = 9
Global Const $gdip_paletteflagshasalpha = 1
Global Const $gdip_paletteflagsgrayscale = 2
Global Const $gdip_paletteflagshalftone = 4
Global Const $gdip_dithertypenone = 0
Global Const $gdip_dithertypesolid = 1
Global Const $gdip_dithertypeordered4x4 = 2
Global Const $gdip_dithertypeordered8x8 = 3
Global Const $gdip_dithertypeordered16x16 = 4
Global Const $gdip_dithertypeordered91x91 = 5
Global Const $gdip_dithertypespiral4x4 = 6
Global Const $gdip_dithertypespiral8x8 = 7
Global Const $gdip_dithertypedualspiral4x4 = 8
Global Const $gdip_dithertypedualspiral8x8 = 9
Global Const $gdip_dithertypeerrordiffusion = 10
Global Const $gdip_dithertypemax = 10
Global Const $gdip_histogramformatargb = 0
Global Const $gdip_histogramformatpargb = 1
Global Const $gdip_histogramformatrgb = 2
Global Const $gdip_histogramformatgray = 3
Global Const $gdip_histogramformatb = 4
Global Const $gdip_histogramformatg = 5
Global Const $gdip_histogramformatr = 6
Global Const $gdip_histogramformata = 7
Global Const $gdip_textrenderinghintsystemdefault = 0
Global Const $gdip_textrenderinghintsinglebitperpixelgridfit = 1
Global Const $gdip_textrenderinghintsinglebitperpixel = 2
Global Const $gdip_textrenderinghintantialiasgridfit = 3
Global Const $gdip_textrenderinghintantialias = 4
Global Const $gdip_textrenderinghintcleartypegridfit = 5
Global Const $gdip_rotatenoneflipnone = 0
Global Const $gdip_rotate90flipnone = 1
Global Const $gdip_rotate180flipnone = 2
Global Const $gdip_rotate270flipnone = 3
Global Const $gdip_rotatenoneflipx = 4
Global Const $gdip_rotate90flipx = 5
Global Const $gdip_rotate180flipx = 6
Global Const $gdip_rotate270flipx = 7
Global Const $gdip_rotatenoneflipy = $gdip_rotate180flipx
Global Const $gdip_rotate90flipy = $gdip_rotate270flipx
Global Const $gdip_rotate180flipy = $gdip_rotatenoneflipx
Global Const $gdip_rotate270flipy = $gdip_rotate90flipx
Global Const $gdip_rotatenoneflipxy = $gdip_rotate180flipnone
Global Const $gdip_rotate90flipxy = $gdip_rotate270flipnone
Global Const $gdip_rotate270flipxy = $gdip_rotate90flipnone
Global Const $tagpoint = "struct;long X;long Y;endstruct"
Global Const $tagrect = "struct;long Left;long Top;long Right;long Bottom;endstruct"
Global Const $tagsize = "struct;long X;long Y;endstruct"
Global Const $tagmargins = "int cxLeftWidth;int cxRightWidth;int cyTopHeight;int cyBottomHeight"
Global Const $tagfiletime = "struct;dword Lo;dword Hi;endstruct"
Global Const $tagsystemtime = "struct;word Year;word Month;word Dow;word Day;word Hour;word Minute;word Second;word MSeconds;endstruct"
Global Const $tagtime_zone_information = "struct;long Bias;wchar StdName[32];word StdDate[8];long StdBias;wchar DayName[32];word DayDate[8];long DayBias;endstruct"
Global Const $tagnmhdr = "struct;hwnd hWndFrom;uint_ptr IDFrom;INT Code;endstruct"
Global Const $tagcomboboxexitem = "uint Mask;int_ptr Item;ptr Text;int TextMax;int Image;int SelectedImage;int OverlayImage;" & "int Indent;lparam Param"
Global Const $tagnmcbedragbegin = $tagnmhdr & ";int ItemID;wchar szText[260]"
Global Const $tagnmcbeendedit = $tagnmhdr & ";bool fChanged;int NewSelection;wchar szText[260];int Why"
Global Const $tagnmcomboboxex = $tagnmhdr & ";uint Mask;int_ptr Item;ptr Text;int TextMax;int Image;" & "int SelectedImage;int OverlayImage;int Indent;lparam Param"
Global Const $tagdtprange = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;" & "word MinSecond;word MinMSecond;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;" & "word MaxMinute;word MaxSecond;word MaxMSecond;bool MinValid;bool MaxValid"
Global Const $tagnmdatetimechange = $tagnmhdr & ";dword Flag;" & $tagsystemtime
Global Const $tagnmdatetimeformat = $tagnmhdr & ";ptr Format;" & $tagsystemtime & ";ptr pDisplay;wchar Display[64]"
Global Const $tagnmdatetimeformatquery = $tagnmhdr & ";ptr Format;struct;long SizeX;long SizeY;endstruct"
Global Const $tagnmdatetimekeydown = $tagnmhdr & ";int VirtKey;ptr Format;" & $tagsystemtime
Global Const $tagnmdatetimestring = $tagnmhdr & ";ptr UserString;" & $tagsystemtime & ";dword Flags"
Global Const $tageventlogrecord = "dword Length;dword Reserved;dword RecordNumber;dword TimeGenerated;dword TimeWritten;dword EventID;" & "word EventType;word NumStrings;word EventCategory;word ReservedFlags;dword ClosingRecordNumber;dword StringOffset;" & "dword UserSidLength;dword UserSidOffset;dword DataLength;dword DataOffset"
Global Const $taggdip_effectparams_blur = "float Radius; bool ExpandEdge"
Global Const $taggdip_effectparams_brightnesscontrast = "int BrightnessLevel; int ContrastLevel"
Global Const $taggdip_effectparams_colorbalance = "int CyanRed; int MagentaGreen; int YellowBlue"
Global Const $taggdip_effectparams_colorcurve = "int Adjustment; int Channel; int AdjustValue"
Global Const $taggdip_effectparams_colorlut = "byte LutB[256]; byte LutG[256]; byte LutR[256]; byte LutA[256]"
Global Const $taggdip_effectparams_huesaturationlightness = "int HueLevel; int SaturationLevel; int LightnessLevel"
Global Const $taggdip_effectparams_levels = "int Highlight; int Midtone; int Shadow"
Global Const $taggdip_effectparams_redeyecorrection = "uint NumberOfAreas; ptr Areas"
Global Const $taggdip_effectparams_sharpen = "float Radius; float Amount"
Global Const $taggdip_effectparams_tint = "int Hue; int Amount"
Global Const $taggdipbitmapdata = "uint Width;uint Height;int Stride;int Format;ptr Scan0;uint_ptr Reserved"
Global Const $taggdipcolormatrix = "float m[25]"
Global Const $taggdipencoderparam = "struct;byte GUID[16];ulong NumberOfValues;ulong Type;ptr Values;endstruct"
Global Const $taggdipencoderparams = "uint Count;" & $taggdipencoderparam
Global Const $taggdiprectf = "struct;float X;float Y;float Width;float Height;endstruct"
Global Const $taggdipstartupinput = "uint Version;ptr Callback;bool NoThread;bool NoCodecs"
Global Const $taggdipstartupoutput = "ptr HookProc;ptr UnhookProc"
Global Const $taggdipimagecodecinfo = "byte CLSID[16];byte FormatID[16];ptr CodecName;ptr DllName;ptr FormatDesc;ptr FileExt;" & "ptr MimeType;dword Flags;dword Version;dword SigCount;dword SigSize;ptr SigPattern;ptr SigMask"
Global Const $taggdippencoderparams = "uint Count;byte Params[1]"
Global Const $taghditem = "uint Mask;int XY;ptr Text;handle hBMP;int TextMax;int Fmt;lparam Param;int Image;int Order;uint Type;ptr pFilter;uint State"
Global Const $tagnmhddispinfo = $tagnmhdr & ";int Item;uint Mask;ptr Text;int TextMax;int Image;lparam lParam"
Global Const $tagnmhdfilterbtnclick = $tagnmhdr & ";int Item;" & $tagrect
Global Const $tagnmheader = $tagnmhdr & ";int Item;int Button;ptr pItem"
Global Const $taggetipaddress = "byte Field4;byte Field3;byte Field2;byte Field1"
Global Const $tagnmipaddress = $tagnmhdr & ";int Field;int Value"
Global Const $taglvfindinfo = "struct;uint Flags;ptr Text;lparam Param;" & $tagpoint & ";uint Direction;endstruct"
Global Const $taglvhittestinfo = $tagpoint & ";uint Flags;int Item;int SubItem;int iGroup"
Global Const $taglvitem = "struct;uint Mask;int Item;int SubItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;lparam Param;" & "int Indent;int GroupID;uint Columns;ptr pColumns;ptr piColFmt;int iGroup;endstruct"
Global Const $tagnmlistview = $tagnmhdr & ";int Item;int SubItem;uint NewState;uint OldState;uint Changed;" & "struct;long ActionX;long ActionY;endstruct;lparam Param"
Global Const $tagnmlvcustomdraw = "struct;" & $tagnmhdr & ";dword dwDrawStage;handle hdc;" & $tagrect & ";dword_ptr dwItemSpec;uint uItemState;lparam lItemlParam;endstruct" & ";dword clrText;dword clrTextBk;int iSubItem;dword dwItemType;dword clrFace;int iIconEffect;" & "int iIconPhase;int iPartID;int iStateID;struct;long TextLeft;long TextTop;long TextRight;long TextBottom;endstruct;uint uAlign"
Global Const $tagnmlvdispinfo = $tagnmhdr & ";" & $taglvitem
Global Const $tagnmlvfinditem = $tagnmhdr & ";int Start;" & $taglvfindinfo
Global Const $tagnmlvgetinfotip = $tagnmhdr & ";dword Flags;ptr Text;int TextMax;int Item;int SubItem;lparam lParam"
Global Const $tagnmitemactivate = $tagnmhdr & ";int Index;int SubItem;uint NewState;uint OldState;uint Changed;" & $tagpoint & ";lparam lParam;uint KeyFlags"
Global Const $tagnmlvkeydown = "align 1;" & $tagnmhdr & ";word VKey;uint Flags"
Global Const $tagnmlvscroll = $tagnmhdr & ";int DX;int DY"
Global Const $tagmchittestinfo = "uint Size;" & $tagpoint & ";uint Hit;" & $tagsystemtime & ";" & $tagrect & ";int iOffset;int iRow;int iCol"
Global Const $tagmcmonthrange = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" & "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" & "word MaxMSeconds;short Span"
Global Const $tagmcrange = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" & "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" & "word MaxMSeconds;short MinSet;short MaxSet"
Global Const $tagmcselrange = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" & "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" & "word MaxMSeconds"
Global Const $tagnmdaystate = $tagnmhdr & ";" & $tagsystemtime & ";int DayState;ptr pDayState"
Global Const $tagnmselchange = $tagnmhdr & ";struct;word BegYear;word BegMonth;word BegDOW;word BegDay;word BegHour;word BegMinute;word BegSecond;word BegMSeconds;endstruct;" & "struct;word EndYear;word EndMonth;word EndDOW;word EndDay;word EndHour;word EndMinute;word EndSecond;word EndMSeconds;endstruct"
Global Const $tagnmobjectnotify = $tagnmhdr & ";int Item;ptr piid;ptr pObject;long Result;dword dwFlags"
Global Const $tagnmtckeydown = "align 1;" & $tagnmhdr & ";word VKey;uint Flags"
Global Const $tagtvitem = "struct;uint Mask;handle hItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;int SelectedImage;" & "int Children;lparam Param;endstruct"
Global Const $tagtvitemex = "struct;" & $tagtvitem & ";int Integral;uint uStateEx;hwnd hwnd;int iExpandedImage;int iReserved;endstruct"
Global Const $tagnmtreeview = $tagnmhdr & ";uint Action;" & "struct;uint OldMask;handle OldhItem;uint OldState;uint OldStateMask;" & "ptr OldText;int OldTextMax;int OldImage;int OldSelectedImage;int OldChildren;lparam OldParam;endstruct;" & "struct;uint NewMask;handle NewhItem;uint NewState;uint NewStateMask;" & "ptr NewText;int NewTextMax;int NewImage;int NewSelectedImage;int NewChildren;lparam NewParam;endstruct;" & "struct;long PointX;long PointY;endstruct"
Global Const $tagnmtvcustomdraw = "struct;" & $tagnmhdr & ";dword DrawStage;handle HDC;" & $tagrect & ";dword_ptr ItemSpec;uint ItemState;lparam ItemParam;endstruct" & ";dword ClrText;dword ClrTextBk;int Level"
Global Const $tagnmtvdispinfo = $tagnmhdr & ";" & $tagtvitem
Global Const $tagnmtvgetinfotip = $tagnmhdr & ";ptr Text;int TextMax;handle hItem;lparam lParam"
Global Const $tagnmtvitemchange = $tagnmhdr & ";uint Changed;handle hItem;uint StateNew;uint StateOld;lparam lParam;"
Global Const $tagtvhittestinfo = $tagpoint & ";uint Flags;handle Item"
Global Const $tagnmtvkeydown = "align 1;" & $tagnmhdr & ";word VKey;uint Flags"
Global Const $tagnmmouse = $tagnmhdr & ";dword_ptr ItemSpec;dword_ptr ItemData;" & $tagpoint & ";lparam HitInfo"
Global Const $tagtoken_privileges = "dword Count;align 4;int64 LUID;dword Attributes"
Global Const $tagimageinfo = "handle hBitmap;handle hMask;int Unused1;int Unused2;" & $tagrect
Global Const $tagmenuinfo = "dword Size;INT Mask;dword Style;uint YMax;handle hBack;dword ContextHelpID;ulong_ptr MenuData"
Global Const $tagmenuiteminfo = "uint Size;uint Mask;uint Type;uint State;uint ID;handle SubMenu;handle BmpChecked;handle BmpUnchecked;" & "ulong_ptr ItemData;ptr TypeData;uint CCH;handle BmpItem"
Global Const $tagrebarbandinfo = "uint cbSize;uint fMask;uint fStyle;dword clrFore;dword clrBack;ptr lpText;uint cch;" & "int iImage;hwnd hwndChild;uint cxMinChild;uint cyMinChild;uint cx;handle hbmBack;uint wID;uint cyChild;uint cyMaxChild;" & "uint cyIntegral;uint cxIdeal;lparam lParam;uint cxHeader" & ((@OSVersion = "WIN_XP") ? "" : ";" & $tagrect & ";uint uChevronState")
Global Const $tagnmrebarautobreak = $tagnmhdr & ";uint uBand;uint wID;lparam lParam;uint uMsg;uint fStyleCurrent;bool fAutoBreak"
Global Const $tagnmrbautosize = $tagnmhdr & ";bool fChanged;" & "struct;long TargetLeft;long TargetTop;long TargetRight;long TargetBottom;endstruct;" & "struct;long ActualLeft;long ActualTop;long ActualRight;long ActualBottom;endstruct"
Global Const $tagnmrebar = $tagnmhdr & ";dword dwMask;uint uBand;uint fStyle;uint wID;lparam lParam"
Global Const $tagnmrebarchevron = $tagnmhdr & ";uint uBand;uint wID;lparam lParam;" & $tagrect & ";lparam lParamNM"
Global Const $tagnmrebarchildsize = $tagnmhdr & ";uint uBand;uint wID;" & "struct;long CLeft;long CTop;long CRight;long CBottom;endstruct;" & "struct;long BLeft;long BTop;long BRight;long BBottom;endstruct"
Global Const $tagcolorscheme = "dword Size;dword BtnHighlight;dword BtnShadow"
Global Const $tagnmtoolbar = $tagnmhdr & ";int iItem;" & "struct;int iBitmap;int idCommand;byte fsState;byte fsStyle;dword_ptr dwData;int_ptr iString;endstruct" & ";int cchText;ptr pszText;" & $tagrect
Global Const $tagnmtbhotitem = $tagnmhdr & ";int idOld;int idNew;dword dwFlags"
Global Const $tagtbbutton = "int Bitmap;int Command;byte State;byte Style;dword_ptr Param;int_ptr String"
Global Const $tagtbbuttoninfo = "uint Size;dword Mask;int Command;int Image;byte State;byte Style;word CX;dword_ptr Param;ptr Text;int TextMax"
Global Const $tagnetresource = "dword Scope;dword Type;dword DisplayType;dword Usage;ptr LocalName;ptr RemoteName;ptr Comment;ptr Provider"
Global Const $tagoverlapped = "ulong_ptr Internal;ulong_ptr InternalHigh;struct;dword Offset;dword OffsetHigh;endstruct;handle hEvent"
Global Const $tagopenfilename = "dword StructSize;hwnd hwndOwner;handle hInstance;ptr lpstrFilter;ptr lpstrCustomFilter;" & "dword nMaxCustFilter;dword nFilterIndex;ptr lpstrFile;dword nMaxFile;ptr lpstrFileTitle;dword nMaxFileTitle;" & "ptr lpstrInitialDir;ptr lpstrTitle;dword Flags;word nFileOffset;word nFileExtension;ptr lpstrDefExt;lparam lCustData;" & "ptr lpfnHook;ptr lpTemplateName;ptr pvReserved;dword dwReserved;dword FlagsEx"
Global Const $tagbitmapinfoheader = "struct;dword biSize;long biWidth;long biHeight;word biPlanes;word biBitCount;" & "dword biCompression;dword biSizeImage;long biXPelsPerMeter;long biYPelsPerMeter;dword biClrUsed;dword biClrImportant;endstruct"
Global Const $tagbitmapinfo = $tagbitmapinfoheader & ";dword biRGBQuad[1]"
Global Const $tagblendfunction = "byte Op;byte Flags;byte Alpha;byte Format"
Global Const $tagguid = "struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];endstruct"
Global Const $tagwindowplacement = "uint length;uint flags;uint showCmd;long ptMinPosition[2];long ptMaxPosition[2];long rcNormalPosition[4]"
Global Const $tagwindowpos = "hwnd hWnd;hwnd InsertAfter;int X;int Y;int CX;int CY;uint Flags"
Global Const $tagscrollinfo = "uint cbSize;uint fMask;int nMin;int nMax;uint nPage;int nPos;int nTrackPos"
Global Const $tagscrollbarinfo = "dword cbSize;" & $tagrect & ";int dxyLineButton;int xyThumbTop;" & "int xyThumbBottom;int reserved;dword rgstate[6]"
Global Const $taglogfont = "struct;long Height;long Width;long Escapement;long Orientation;long Weight;byte Italic;byte Underline;" & "byte Strikeout;byte CharSet;byte OutPrecision;byte ClipPrecision;byte Quality;byte PitchAndFamily;wchar FaceName[32];endstruct"
Global Const $tagkbdllhookstruct = "dword vkCode;dword scanCode;dword flags;dword time;ulong_ptr dwExtraInfo"
Global Const $tagprocess_information = "handle hProcess;handle hThread;dword ProcessID;dword ThreadID"
Global Const $tagstartupinfo = "dword Size;ptr Reserved1;ptr Desktop;ptr Title;dword X;dword Y;dword XSize;dword YSize;dword XCountChars;" & "dword YCountChars;dword FillAttribute;dword Flags;word ShowWindow;word Reserved2;ptr Reserved3;handle StdInput;" & "handle StdOutput;handle StdError"
Global Const $tagsecurity_attributes = "dword Length;ptr Descriptor;bool InheritHandle"
Global Const $tagwin32_find_data = "dword dwFileAttributes;dword ftCreationTime[2];dword ftLastAccessTime[2];dword ftLastWriteTime[2];dword nFileSizeHigh;dword nFileSizeLow;dword dwReserved0;dword dwReserved1;wchar cFileName[260];wchar cAlternateFileName[14]"
Global Const $tagtextmetric = "long tmHeight;long tmAscent;long tmDescent;long tmInternalLeading;long tmExternalLeading;" & "long tmAveCharWidth;long tmMaxCharWidth;long tmWeight;long tmOverhang;long tmDigitizedAspectX;long tmDigitizedAspectY;" & "wchar tmFirstChar;wchar tmLastChar;wchar tmDefaultChar;wchar tmBreakChar;byte tmItalic;byte tmUnderlined;byte tmStruckOut;" & "byte tmPitchAndFamily;byte tmCharSet"
Global Const $opt_coordsrelative = 0
Global Const $opt_coordsabsolute = 1
Global Const $opt_coordsclient = 2
Global Const $opt_errorsilent = 0
Global Const $opt_errorfatal = 1
Global Const $opt_capsnostore = 0
Global Const $opt_capsstore = 1
Global Const $opt_matchstart = 1
Global Const $opt_matchany = 2
Global Const $opt_matchexact = 3
Global Const $opt_matchadvanced = 4
Global Const $ccs_top = 1
Global Const $ccs_nomovey = 2
Global Const $ccs_bottom = 3
Global Const $ccs_noresize = 4
Global Const $ccs_noparentalign = 8
Global Const $ccs_nohilite = 16
Global Const $ccs_adjustable = 32
Global Const $ccs_nodivider = 64
Global Const $ccs_vert = 128
Global Const $ccs_left = 129
Global Const $ccs_nomovex = 130
Global Const $ccs_right = 131
Global Const $dt_drivetype = 1
Global Const $dt_ssdstatus = 2
Global Const $dt_bustype = 3
Global Const $proxy_ie = 0
Global Const $proxy_none = 1
Global Const $proxy_specified = 2
Global Const $objid_window = 0
Global Const $objid_titlebar = -2
Global Const $objid_sizegrip = -7
Global Const $objid_caret = -8
Global Const $objid_cursor = -9
Global Const $objid_alert = -10
Global Const $objid_sound = -11
Global Const $dlg_centerontop = 0
Global Const $dlg_notitle = 1
Global Const $dlg_notontop = 2
Global Const $dlg_textleft = 4
Global Const $dlg_textright = 8
Global Const $dlg_moveable = 16
Global Const $dlg_textvcenter = 32
Global Const $idc_unknown = 0
Global Const $idc_appstarting = 1
Global Const $idc_arrow = 2
Global Const $idc_cross = 3
Global Const $idc_hand = 32649
Global Const $idc_help = 4
Global Const $idc_ibeam = 5
Global Const $idc_icon = 6
Global Const $idc_no = 7
Global Const $idc_size = 8
Global Const $idc_sizeall = 9
Global Const $idc_sizenesw = 10
Global Const $idc_sizens = 11
Global Const $idc_sizenwse = 12
Global Const $idc_sizewe = 13
Global Const $idc_uparrow = 14
Global Const $idc_wait = 15
Global Const $idi_application = 32512
Global Const $idi_asterisk = 32516
Global Const $idi_exclamation = 32515
Global Const $idi_hand = 32513
Global Const $idi_question = 32514
Global Const $idi_winlogo = 32517
Global Const $idi_shield = 32518
Global Const $idi_error = $idi_hand
Global Const $idi_information = $idi_asterisk
Global Const $idi_warning = $idi_exclamation
Global Const $sd_logoff = 0
Global Const $sd_shutdown = 1
Global Const $sd_reboot = 2
Global Const $sd_force = 4
Global Const $sd_powerdown = 8
Global Const $sd_forcehung = 16
Global Const $sd_standby = 32
Global Const $sd_hibernate = 64
Global Const $stdin_child = 1
Global Const $stdout_child = 2
Global Const $stderr_child = 4
Global Const $stderr_merged = 8
Global Const $stdio_inherit_parent = 16
Global Const $run_create_new_console = 65536
Global Const $ubound_dimensions = 0
Global Const $ubound_rows = 1
Global Const $ubound_columns = 2
Global Const $mouseeventf_absolute = 32768
Global Const $mouseeventf_move = 1
Global Const $mouseeventf_leftdown = 2
Global Const $mouseeventf_leftup = 4
Global Const $mouseeventf_rightdown = 8
Global Const $mouseeventf_rightup = 16
Global Const $mouseeventf_middledown = 32
Global Const $mouseeventf_middleup = 64
Global Const $mouseeventf_wheel = 2048
Global Const $mouseeventf_xdown = 128
Global Const $mouseeventf_xup = 256
Global Const $reg_none = 0
Global Const $reg_sz = 1
Global Const $reg_expand_sz = 2
Global Const $reg_binary = 3
Global Const $reg_dword = 4
Global Const $reg_dword_little_endian = 4
Global Const $reg_dword_big_endian = 5
Global Const $reg_link = 6
Global Const $reg_multi_sz = 7
Global Const $reg_resource_list = 8
Global Const $reg_full_resource_descriptor = 9
Global Const $reg_resource_requirements_list = 10
Global Const $reg_qword = 11
Global Const $reg_qword_little_endian = 11
Global Const $hwnd_bottom = 1
Global Const $hwnd_notopmost = -2
Global Const $hwnd_top = 0
Global Const $hwnd_topmost = -1
Global Const $swp_nosize = 1
Global Const $swp_nomove = 2
Global Const $swp_nozorder = 4
Global Const $swp_noredraw = 8
Global Const $swp_noactivate = 16
Global Const $swp_framechanged = 32
Global Const $swp_drawframe = 32
Global Const $swp_showwindow = 64
Global Const $swp_hidewindow = 128
Global Const $swp_nocopybits = 256
Global Const $swp_noownerzorder = 512
Global Const $swp_noreposition = 512
Global Const $swp_nosendchanging = 1024
Global Const $swp_defererase = 8192
Global Const $swp_asyncwindowpos = 16384
Global Const $keyword_default = 1
Global Const $keyword_null = 2
Global Const $declared_local = -1
Global Const $declared_unknown = 0
Global Const $declared_global = 1
Global Const $assign_create = 0
Global Const $assign_forcelocal = 1
Global Const $assign_forceglobal = 2
Global Const $assign_existfail = 4
Global Const $bi_enable = 0
Global Const $bi_disable = 1
Global Const $break_enable = 1
Global Const $break_disable = 0
Global Const $cdtray_open = "open"
Global Const $cdtray_closed = "closed"
Global Const $send_default = 0
Global Const $send_raw = 1
Global Const $dir_default = 0
Global Const $dir_extended = 1
Global Const $dir_norecurse = 2
Global Const $dir_remove = 1
Global Const $dt_all = "ALL"
Global Const $dt_cdrom = "CDROM"
Global Const $dt_removable = "REMOVABLE"
Global Const $dt_fixed = "FIXED"
Global Const $dt_network = "NETWORK"
Global Const $dt_ramdisk = "RAMDISK"
Global Const $dt_unknown = "UNKNOWN"
Global Const $dt_undefined = 1
Global Const $dt_fat = "FAT"
Global Const $dt_fat32 = "FAT32"
Global Const $dt_exfat = "exFAT"
Global Const $dt_ntfs = "NTFS"
Global Const $dt_nwfs = "NWFS"
Global Const $dt_cdfs = "CDFS"
Global Const $dt_udf = "UDF"
Global Const $dma_default = 0
Global Const $dma_persistent = 1
Global Const $dma_authentication = 8
Global Const $ds_unknown = "UNKNOWN"
Global Const $ds_ready = "READY"
Global Const $ds_notready = "NOTREADY"
Global Const $ds_invalid = "INVALID"
Global Const $mouse_click_left = "left"
Global Const $mouse_click_right = "right"
Global Const $mouse_click_middle = "middle"
Global Const $mouse_click_main = "main"
Global Const $mouse_click_menu = "menu"
Global Const $mouse_click_primary = "primary"
Global Const $mouse_click_secondary = "secondary"
Global Const $mouse_wheel_up = "up"
Global Const $mouse_wheel_down = "down"
Global Const $number_auto = 0
Global Const $number_32bit = 1
Global Const $number_64bit = 2
Global Const $number_double = 3
Global Const $obj_name = 1
Global Const $obj_string = 2
Global Const $obj_progid = 3
Global Const $obj_file = 4
Global Const $obj_module = 5
Global Const $obj_clsid = 6
Global Const $obj_iid = 7
Global Const $exitclose_normal = 0
Global Const $exitclose_byexit = 1
Global Const $exitclose_byclick = 2
Global Const $exitclose_bylogoff = 3
Global Const $exitclose_bysutdown = 4
Global Const $process_stats_memory = 0
Global Const $process_stats_io = 1
Global Const $process_low = 0
Global Const $process_belownormal = 1
Global Const $process_normal = 2
Global Const $process_abovenormal = 3
Global Const $process_high = 4
Global Const $process_realtime = 5
Global Const $run_logon_noprofile = 0
Global Const $run_logon_profile = 1
Global Const $run_logon_network = 2
Global Const $run_logon_inherit = 4
Global Const $sound_nowait = 0
Global Const $sound_wait = 1
Global Const $shex_open = "open"
Global Const $shex_edit = "edit"
Global Const $shex_print = "print"
Global Const $shex_properties = "properties"
Global Const $tcp_data_default = 0
Global Const $tcp_data_binary = 1
Global Const $udp_open_default = 0
Global Const $udp_open_broadcast = 1
Global Const $udp_data_default = 0
Global Const $udp_data_binary = 1
Global Const $udp_data_array = 2
Global Const $tip_noicon = 0
Global Const $tip_infoicon = 1
Global Const $tip_warningicon = 2
Global Const $tip_erroricon = 3
Global Const $tip_balloon = 1
Global Const $tip_center = 2
Global Const $tip_forcevisible = 4
Global Const $windows_noontop = 0
Global Const $windows_ontop = 1
Global Const $fc_nooverwrite = 0
Global Const $fc_overwrite = 1
Global Const $fc_createpath = 8
Global Const $ft_modified = 0
Global Const $ft_created = 1
Global Const $ft_accessed = 2
Global Const $ft_array = 0
Global Const $ft_string = 1
Global Const $fsf_createbutton = 1
Global Const $fsf_newdialog = 2
Global Const $fsf_editcontrol = 4
Global Const $ft_nonrecursive = 0
Global Const $ft_recursive = 1
Global Const $fo_read = 0
Global Const $fo_append = 1
Global Const $fo_overwrite = 2
Global Const $fo_createpath = 8
Global Const $fo_binary = 16
Global Const $fo_unicode = 32
Global Const $fo_utf16_le = 32
Global Const $fo_utf16_be = 64
Global Const $fo_utf8 = 128
Global Const $fo_utf8_nobom = 256
Global Const $fo_ansi = 512
Global Const $fo_utf16_le_nobom = 1024
Global Const $fo_utf16_be_nobom = 2048
Global Const $fo_utf8_full = 16384
Global Const $fo_fullfile_detect = 16384
Global Const $eof = -1
Global Const $fd_filemustexist = 1
Global Const $fd_pathmustexist = 2
Global Const $fd_multiselect = 4
Global Const $fd_promptcreatenew = 8
Global Const $fd_promptoverwrite = 16
Global Const $create_new = 1
Global Const $create_always = 2
Global Const $open_existing = 3
Global Const $open_always = 4
Global Const $truncate_existing = 5
Global Const $invalid_set_file_pointer = -1
Global Const $file_begin = 0
Global Const $file_current = 1
Global Const $file_end = 2
Global Const $file_attribute_readonly = 1
Global Const $file_attribute_hidden = 2
Global Const $file_attribute_system = 4
Global Const $file_attribute_directory = 16
Global Const $file_attribute_archive = 32
Global Const $file_attribute_device = 64
Global Const $file_attribute_normal = 128
Global Const $file_attribute_temporary = 256
Global Const $file_attribute_sparse_file = 512
Global Const $file_attribute_reparse_point = 1024
Global Const $file_attribute_compressed = 2048
Global Const $file_attribute_offline = 4096
Global Const $file_attribute_not_content_indexed = 8192
Global Const $file_attribute_encrypted = 16384
Global Const $file_share_read = 1
Global Const $file_share_write = 2
Global Const $file_share_delete = 4
Global Const $file_share_readwrite = BitOR($file_share_read, $file_share_write)
Global Const $file_share_any = BitOR($file_share_read, $file_share_write, $file_share_delete)
Global Const $generic_all = 268435456
Global Const $generic_execute = 536870912
Global Const $generic_write = 1073741824
Global Const $generic_read = -2147483648
Global Const $generic_readwrite = BitOR($generic_read, $generic_write)
Global Const $file_encoding_utf16le = 32
Global Const $fe_entire_utf8 = 1
Global Const $fe_partialfirst_utf8 = 2
Global Const $fn_fullpath = 0
Global Const $fn_relativepath = 1
Global Const $fv_comments = "Comments"
Global Const $fv_companyname = "CompanyName"
Global Const $fv_filedescription = "FileDescription"
Global Const $fv_fileversion = "FileVersion"
Global Const $fv_internalname = "InternalName"
Global Const $fv_legalcopyright = "LegalCopyright"
Global Const $fv_legaltrademarks = "LegalTrademarks"
Global Const $fv_originalfilename = "OriginalFilename"
Global Const $fv_productname = "ProductName"
Global Const $fv_productversion = "ProductVersion"
Global Const $fv_privatebuild = "PrivateBuild"
Global Const $fv_specialbuild = "SpecialBuild"
Global Const $frta_nocount = 0
Global Const $frta_count = 1
Global Const $frta_intarrays = 2
Global Const $frta_entiresplit = 4
Global Const $flta_filesfolders = 0
Global Const $flta_files = 1
Global Const $flta_folders = 2
Global Const $fltar_filesfolders = 0
Global Const $fltar_files = 1
Global Const $fltar_folders = 2
Global Const $fltar_nohidden = 4
Global Const $fltar_nosystem = 8
Global Const $fltar_nolink = 16
Global Const $fltar_norecur = 0
Global Const $fltar_recur = 1
Global Const $fltar_nosort = 0
Global Const $fltar_sort = 1
Global Const $fltar_fastsort = 2
Global Const $fltar_nopath = 0
Global Const $fltar_relpath = 1
Global Const $fltar_fullpath = 2
Global Const $mb_ok = 0
Global Const $mb_okcancel = 1
Global Const $mb_abortretryignore = 2
Global Const $mb_yesnocancel = 3
Global Const $mb_yesno = 4
Global Const $mb_retrycancel = 5
Global Const $mb_canceltrycontinue = 6
Global Const $mb_help = 16384
Global Const $mb_iconstop = 16
Global Const $mb_iconerror = 16
Global Const $mb_iconhand = 16
Global Const $mb_iconquestion = 32
Global Const $mb_iconexclamation = 48
Global Const $mb_iconwarning = 48
Global Const $mb_iconinformation = 64
Global Const $mb_iconasterisk = 64
Global Const $mb_usericon = 128
Global Const $mb_defbutton1 = 0
Global Const $mb_defbutton2 = 256
Global Const $mb_defbutton3 = 512
Global Const $mb_defbutton4 = 768
Global Const $mb_applmodal = 0
Global Const $mb_systemmodal = 4096
Global Const $mb_taskmodal = 8192
Global Const $mb_default_desktop_only = 131072
Global Const $mb_right = 524288
Global Const $mb_rtlreading = 1048576
Global Const $mb_setforeground = 65536
Global Const $mb_topmost = 262144
Global Const $mb_service_notification = 2097152
Global Const $mb_rightjustified = $mb_right
Global Const $idtimeout = -1
Global Const $idok = 1
Global Const $idcancel = 2
Global Const $idabort = 3
Global Const $idretry = 4
Global Const $idignore = 5
Global Const $idyes = 6
Global Const $idno = 7
Global Const $idclose = 8
Global Const $idhelp = 9
Global Const $idtryagain = 10
Global Const $idcontinue = 11
Global Const $se_assignprimarytoken_name = "SeAssignPrimaryTokenPrivilege"
Global Const $se_audit_name = "SeAuditPrivilege"
Global Const $se_backup_name = "SeBackupPrivilege"
Global Const $se_change_notify_name = "SeChangeNotifyPrivilege"
Global Const $se_create_global_name = "SeCreateGlobalPrivilege"
Global Const $se_create_pagefile_name = "SeCreatePagefilePrivilege"
Global Const $se_create_permanent_name = "SeCreatePermanentPrivilege"
Global Const $se_create_symbolic_link_name = "SeCreateSymbolicLinkPrivilege"
Global Const $se_create_token_name = "SeCreateTokenPrivilege"
Global Const $se_debug_name = "SeDebugPrivilege"
Global Const $se_enable_delegation_name = "SeEnableDelegationPrivilege"
Global Const $se_impersonate_name = "SeImpersonatePrivilege"
Global Const $se_inc_base_priority_name = "SeIncreaseBasePriorityPrivilege"
Global Const $se_inc_working_set_name = "SeIncreaseWorkingSetPrivilege"
Global Const $se_increase_quota_name = "SeIncreaseQuotaPrivilege"
Global Const $se_load_driver_name = "SeLoadDriverPrivilege"
Global Const $se_lock_memory_name = "SeLockMemoryPrivilege"
Global Const $se_machine_account_name = "SeMachineAccountPrivilege"
Global Const $se_manage_volume_name = "SeManageVolumePrivilege"
Global Const $se_prof_single_process_name = "SeProfileSingleProcessPrivilege"
Global Const $se_relabel_name = "SeRelabelPrivilege"
Global Const $se_remote_shutdown_name = "SeRemoteShutdownPrivilege"
Global Const $se_restore_name = "SeRestorePrivilege"
Global Const $se_security_name = "SeSecurityPrivilege"
Global Const $se_shutdown_name = "SeShutdownPrivilege"
Global Const $se_sync_agent_name = "SeSyncAgentPrivilege"
Global Const $se_system_environment_name = "SeSystemEnvironmentPrivilege"
Global Const $se_system_profile_name = "SeSystemProfilePrivilege"
Global Const $se_systemtime_name = "SeSystemtimePrivilege"
Global Const $se_take_ownership_name = "SeTakeOwnershipPrivilege"
Global Const $se_tcb_name = "SeTcbPrivilege"
Global Const $se_time_zone_name = "SeTimeZonePrivilege"
Global Const $se_trusted_credman_access_name = "SeTrustedCredManAccessPrivilege"
Global Const $se_unsolicited_input_name = "SeUnsolicitedInputPrivilege"
Global Const $se_undock_name = "SeUndockPrivilege"
Global Const $se_privilege_enabled_by_default = 1
Global Const $se_privilege_enabled = 2
Global Const $se_privilege_removed = 4
Global Const $se_privilege_used_for_access = -2147483648
Global Const $se_group_mandatory = 1
Global Const $se_group_enabled_by_default = 2
Global Const $se_group_enabled = 4
Global Const $se_group_owner = 8
Global Const $se_group_use_for_deny_only = 16
Global Const $se_group_integrity = 32
Global Const $se_group_integrity_enabled = 64
Global Const $se_group_resource = 536870912
Global Const $se_group_logon_id = -1073741824
Global Enum $tokenprimary = 1, $tokenimpersonation
Global Enum $securityanonymous = 0, $securityidentification, $securityimpersonation, $securitydelegation
Global Enum $tokenuser = 1, $tokengroups, $tokenprivileges, $tokenowner, $tokenprimarygroup, $tokendefaultdacl, $tokensource, $tokentype, $tokenimpersonationlevel, $tokenstatistics, $tokenrestrictedsids, $tokensessionid, $tokengroupsandprivileges, $tokensessionreference, $tokensandboxinert, $tokenauditpolicy, $tokenorigin, $tokenelevationtype, $tokenlinkedtoken, $tokenelevation, $tokenhasrestrictions, $tokenaccessinformation, $tokenvirtualizationallowed, $tokenvirtualizationenabled, $tokenintegritylevel, $tokenuiaccess, $tokenmandatorypolicy, $tokenlogonsid
Global Const $token_assign_primary = 1
Global Const $token_duplicate = 2
Global Const $token_impersonate = 4
Global Const $token_query = 8
Global Const $token_query_source = 16
Global Const $token_adjust_privileges = 32
Global Const $token_adjust_groups = 64
Global Const $token_adjust_default = 128
Global Const $token_adjust_sessionid = 256
Global Const $token_all_access = 983551
Global Const $token_read = 131080
Global Const $token_write = 131296
Global Const $token_execute = 131072
Global Const $token_has_traverse_privilege = 1
Global Const $token_has_backup_privilege = 2
Global Const $token_has_restore_privilege = 4
Global Const $token_has_admin_group = 8
Global Const $token_is_restricted = 16
Global Const $token_session_not_referenced = 32
Global Const $token_sandbox_inert = 64
Global Const $token_has_impersonate_privilege = 128
Global Const $rights_delete = 65536
Global Const $read_control = 131072
Global Const $write_dac = 262144
Global Const $write_owner = 524288
Global Const $synchronize = 1048576
Global Const $access_system_security = 16777216
Global Const $standard_rights_required = 983040
Global Const $standard_rights_read = $read_control
Global Const $standard_rights_write = $read_control
Global Const $standard_rights_execute = $read_control
Global Const $standard_rights_all = 2031616
Global Const $specific_rights_all = 65535
Global Enum $not_used_access = 0, $grant_access, $set_access, $deny_access, $revoke_access, $set_audit_success, $set_audit_failure
Global Enum $trustee_is_unknown = 0, $trustee_is_user, $trustee_is_group, $trustee_is_domain, $trustee_is_alias, $trustee_is_well_known_group, $trustee_is_deleted, $trustee_is_invalid, $trustee_is_computer
Global Const $logon_with_profile = 1
Global Const $logon_netcredentials_only = 2
Global Enum $sidtypeuser = 1, $sidtypegroup, $sidtypedomain, $sidtypealias, $sidtypewellknowngroup, $sidtypedeletedaccount, $sidtypeinvalid, $sidtypeunknown, $sidtypecomputer, $sidtypelabel
Global Const $sid_administrators = "S-1-5-32-544"
Global Const $sid_users = "S-1-5-32-545"
Global Const $sid_guests = "S-1-5-32-546"
Global Const $sid_account_operators = "S-1-5-32-548"
Global Const $sid_server_operators = "S-1-5-32-549"
Global Const $sid_print_operators = "S-1-5-32-550"
Global Const $sid_backup_operators = "S-1-5-32-551"
Global Const $sid_replicator = "S-1-5-32-552"
Global Const $sid_owner = "S-1-3-0"
Global Const $sid_everyone = "S-1-1-0"
Global Const $sid_network = "S-1-5-2"
Global Const $sid_interactive = "S-1-5-4"
Global Const $sid_system = "S-1-5-18"
Global Const $sid_authenticated_users = "S-1-5-11"
Global Const $sid_schannel_authentication = "S-1-5-64-14"
Global Const $sid_digest_authentication = "S-1-5-64-21"
Global Const $sid_nt_service = "S-1-5-80"
Global Const $sid_untrusted_mandatory_level = "S-1-16-0"
Global Const $sid_low_mandatory_level = "S-1-16-4096"
Global Const $sid_medium_mandatory_level = "S-1-16-8192"
Global Const $sid_medium_plus_mandatory_level = "S-1-16-8448"
Global Const $sid_high_mandatory_level = "S-1-16-12288"
Global Const $sid_system_mandatory_level = "S-1-16-16384"
Global Const $sid_protected_process_mandatory_level = "S-1-16-20480"
Global Const $sid_secure_process_mandatory_level = "S-1-16-28672"
Global Const $sid_all_services = "S-1-5-80-0"

Func _winapi_getlasterror(Const $_icurrenterror = @error, Const $_icurrentextended = @extended)
	Local $aresult = DllCall("kernel32.dll", "dword", "GetLastError")
	Return SetError($_icurrenterror, $_icurrentextended, $aresult[0])
EndFunc

Func _winapi_setlasterror($ierrorcode, Const $_icurrenterror = @error, Const $_icurrentextended = @extended)
	DllCall("kernel32.dll", "none", "SetLastError", "dword", $ierrorcode)
	Return SetError($_icurrenterror, $_icurrentextended, NULL )
EndFunc

Func __comerrorformating($ocomerror, $sprefix = @TAB)
	Local Const $str_striptrailing = 2
	Local $serror = "COM Error encountered in " & @ScriptName & " (" & $ocomerror.scriptline & ") :" & @CRLF & $sprefix & "Number        " & @TAB & "= 0x" & Hex($ocomerror.number, 8) & " (" & $ocomerror.number & ")" & @CRLF & $sprefix & "WinDescription" & @TAB & "= " & StringStripWS($ocomerror.windescription, $str_striptrailing) & @CRLF & $sprefix & "Description   " & @TAB & "= " & StringStripWS($ocomerror.description, $str_striptrailing) & @CRLF & $sprefix & "Source        " & @TAB & "= " & $ocomerror.source & @CRLF & $sprefix & "HelpFile      " & @TAB & "= " & $ocomerror.helpfile & @CRLF & $sprefix & "HelpContext   " & @TAB & "= " & $ocomerror.helpcontext & @CRLF & $sprefix & "LastDllError  " & @TAB & "= " & $ocomerror.lastdllerror & @CRLF & $sprefix & "Retcode       " & @TAB & "= 0x" & Hex($ocomerror.retcode)
	Return $serror
EndFunc

Func _security__adjusttokenprivileges($htoken, $bdisableall, $tnewstate, $ibufferlen, $tprevstate = 0, $prequired = 0)
	Local $acall = DllCall("advapi32.dll", "bool", "AdjustTokenPrivileges", "handle", $htoken, "bool", $bdisableall, "struct*", $tnewstate, "dword", $ibufferlen, "struct*", $tprevstate, "struct*", $prequired)
	If @error Then Return SetError(@error, @extended, False)
	Return NOT ($acall[0] = 0)
EndFunc

Func _security__createprocesswithtoken($htoken, $ilogonflags, $scommandline, $icreationflags, $scurdir, $tstartupinfo, $tprocess_information)
	Local $acall = DllCall("advapi32.dll", "bool", "CreateProcessWithTokenW", "handle", $htoken, "dword", $ilogonflags, "ptr", 0, "wstr", $scommandline, "dword", $icreationflags, "struct*", 0, "wstr", $scurdir, "struct*", $tstartupinfo, "struct*", $tprocess_information)
	If @error OR NOT $acall[0] Then Return SetError(@error, @extended, False)
	Return True
EndFunc

Func _security__duplicatetokenex($hexistingtoken, $idesiredaccess, $iimpersonationlevel, $itokentype)
	Local $acall = DllCall("advapi32.dll", "bool", "DuplicateTokenEx", "handle", $hexistingtoken, "dword", $idesiredaccess, "struct*", 0, "int", $iimpersonationlevel, "int", $itokentype, "handle*", 0)
	If @error OR NOT $acall[0] Then Return SetError(@error, @extended, 0)
	Return $acall[6]
EndFunc

Func _security__getaccountsid($saccount, $ssystem = "")
	Local $aacct = _security__lookupaccountname($saccount, $ssystem)
	If @error Then Return SetError(@error, @extended, 0)
	If IsArray($aacct) Then Return _security__stringsidtosid($aacct[0])
	Return ""
EndFunc

Func _security__getlengthsid($psid)
	If NOT _security__isvalidsid($psid) Then Return SetError(@error + 10, @extended, 0)
	Local $acall = DllCall("advapi32.dll", "dword", "GetLengthSid", "struct*", $psid)
	If @error Then Return SetError(@error, @extended, 0)
	Return $acall[0]
EndFunc

Func _security__gettokeninformation($htoken, $iclass)
	Local $acall = DllCall("advapi32.dll", "bool", "GetTokenInformation", "handle", $htoken, "int", $iclass, "struct*", 0, "dword", 0, "dword*", 0)
	If @error OR NOT $acall[5] Then Return SetError(@error + 10, @extended, 0)
	Local $ilen = $acall[5]
	Local $tbuffer = DllStructCreate("byte[" & $ilen & "]")
	$acall = DllCall("advapi32.dll", "bool", "GetTokenInformation", "handle", $htoken, "int", $iclass, "struct*", $tbuffer, "dword", DllStructGetSize($tbuffer), "dword*", 0)
	If @error OR NOT $acall[0] Then Return SetError(@error, @extended, 0)
	Return $tbuffer
EndFunc

Func _security__impersonateself($ilevel = $securityimpersonation)
	Local $acall = DllCall("advapi32.dll", "bool", "ImpersonateSelf", "int", $ilevel)
	If @error Then Return SetError(@error, @extended, False)
	Return NOT ($acall[0] = 0)
EndFunc

Func _security__isvalidsid($psid)
	Local $acall = DllCall("advapi32.dll", "bool", "IsValidSid", "struct*", $psid)
	If @error Then Return SetError(@error, @extended, False)
	Return NOT ($acall[0] = 0)
EndFunc

Func _security__lookupaccountname($saccount, $ssystem = "")
	Local $tdata = DllStructCreate("byte SID[256]")
	Local $acall = DllCall("advapi32.dll", "bool", "LookupAccountNameW", "wstr", $ssystem, "wstr", $saccount, "struct*", $tdata, "dword*", DllStructGetSize($tdata), "wstr", "", "dword*", DllStructGetSize($tdata), "int*", 0)
	If @error OR NOT $acall[0] Then Return SetError(@error, @extended, 0)
	Local $aacct[3]
	$aacct[0] = _security__sidtostringsid(DllStructGetPtr($tdata, "SID"))
	$aacct[1] = $acall[5]
	$aacct[2] = $acall[7]
	Return $aacct
EndFunc

Func _security__lookupaccountsid($vsid, $ssystem = "")
	Local $psid, $aacct[3]
	If IsString($vsid) Then
		$psid = _security__stringsidtosid($vsid)
	Else
		$psid = $vsid
	EndIf
	If NOT _security__isvalidsid($psid) Then Return SetError(@error + 10, @extended, 0)
	Local $stypesystem = "ptr"
	If $ssystem Then $stypesystem = "wstr"
	Local $acall = DllCall("advapi32.dll", "bool", "LookupAccountSidW", $stypesystem, $ssystem, "struct*", $psid, "wstr", "", "dword*", 65536, "wstr", "", "dword*", 65536, "int*", 0)
	If @error OR NOT $acall[0] Then Return SetError(@error, @extended, 0)
	Local $aacct[3]
	$aacct[0] = $acall[3]
	$aacct[1] = $acall[5]
	$aacct[2] = $acall[7]
	Return $aacct
EndFunc

Func _security__lookupprivilegevalue($ssystem, $sname)
	Local $acall = DllCall("advapi32.dll", "bool", "LookupPrivilegeValueW", "wstr", $ssystem, "wstr", $sname, "int64*", 0)
	If @error OR NOT $acall[0] Then Return SetError(@error, @extended, 0)
	Return $acall[3]
EndFunc

Func _security__openprocesstoken($hprocess, $iaccess)
	Local $acall = DllCall("advapi32.dll", "bool", "OpenProcessToken", "handle", $hprocess, "dword", $iaccess, "handle*", 0)
	If @error OR NOT $acall[0] Then Return SetError(@error, @extended, 0)
	Return $acall[3]
EndFunc

Func _security__openthreadtoken($iaccess, $hthread = 0, $bopenasself = False)
	If $hthread = 0 Then
		Local $aresult = DllCall("kernel32.dll", "handle", "GetCurrentThread")
		If @error Then Return SetError(@error + 10, @extended, 0)
		$hthread = $aresult[0]
	EndIf
	Local $acall = DllCall("advapi32.dll", "bool", "OpenThreadToken", "handle", $hthread, "dword", $iaccess, "bool", $bopenasself, "handle*", 0)
	If @error OR NOT $acall[0] Then Return SetError(@error, @extended, 0)
	Return $acall[4]
EndFunc

Func _security__openthreadtokenex($iaccess, $hthread = 0, $bopenasself = False)
	Local $htoken = _security__openthreadtoken($iaccess, $hthread, $bopenasself)
	If $htoken = 0 Then
		Local Const $error_no_token = 1008
		If _winapi_getlasterror() <> $error_no_token Then Return SetError(20, _winapi_getlasterror(), 0)
		If NOT _security__impersonateself() Then Return SetError(@error + 10, _winapi_getlasterror(), 0)
		$htoken = _security__openthreadtoken($iaccess, $hthread, $bopenasself)
		If $htoken = 0 Then Return SetError(@error, _winapi_getlasterror(), 0)
	EndIf
	Return $htoken
EndFunc

Func _security__setprivilege($htoken, $sprivilege, $benable)
	Local $iluid = _security__lookupprivilegevalue("", $sprivilege)
	If $iluid = 0 Then Return SetError(@error + 10, @extended, False)
	Local Const $tagtoken_privileges = "dword Count;align 4;int64 LUID;dword Attributes"
	Local $tcurrstate = DllStructCreate($tagtoken_privileges)
	Local $icurrstate = DllStructGetSize($tcurrstate)
	Local $tprevstate = DllStructCreate($tagtoken_privileges)
	Local $iprevstate = DllStructGetSize($tprevstate)
	Local $trequired = DllStructCreate("int Data")
	DllStructSetData($tcurrstate, "Count", 1)
	DllStructSetData($tcurrstate, "LUID", $iluid)
	If NOT _security__adjusttokenprivileges($htoken, False, $tcurrstate, $icurrstate, $tprevstate, $trequired) Then Return SetError(2, @error, False)
	DllStructSetData($tprevstate, "Count", 1)
	DllStructSetData($tprevstate, "LUID", $iluid)
	Local $iattributes = DllStructGetData($tprevstate, "Attributes")
	If $benable Then
		$iattributes = BitOR($iattributes, $se_privilege_enabled)
	Else
		$iattributes = BitAND($iattributes, BitNOT($se_privilege_enabled))
	EndIf
	DllStructSetData($tprevstate, "Attributes", $iattributes)
	If NOT _security__adjusttokenprivileges($htoken, False, $tprevstate, $iprevstate, $tcurrstate, $trequired) Then Return SetError(3, @error, False)
	Return True
EndFunc

Func _security__settokeninformation($htoken, $itokeninformation, $vtokeninformation, $itokeninformationlength)
	Local $acall = DllCall("advapi32.dll", "bool", "SetTokenInformation", "handle", $htoken, "int", $itokeninformation, "struct*", $vtokeninformation, "dword", $itokeninformationlength)
	If @error OR NOT $acall[0] Then Return SetError(@error, @extended, False)
	Return True
EndFunc

Func _security__sidtostringsid($psid)
	If NOT _security__isvalidsid($psid) Then Return SetError(@error + 10, 0, "")
	Local $acall = DllCall("advapi32.dll", "bool", "ConvertSidToStringSidW", "struct*", $psid, "ptr*", 0)
	If @error OR NOT $acall[0] Then Return SetError(@error, @extended, "")
	Local $pstringsid = $acall[2]
	Local $alen = DllCall("kernel32.dll", "int", "lstrlenW", "struct*", $pstringsid)
	Local $ssid = DllStructGetData(DllStructCreate("wchar Text[" & $alen[0] + 1 & "]", $pstringsid), "Text")
	DllCall("kernel32.dll", "handle", "LocalFree", "handle", $pstringsid)
	Return $ssid
EndFunc

Func _security__sidtypestr($itype)
	Switch $itype
		Case $sidtypeuser
			Return "User"
		Case $sidtypegroup
			Return "Group"
		Case $sidtypedomain
			Return "Domain"
		Case $sidtypealias
			Return "Alias"
		Case $sidtypewellknowngroup
			Return "Well Known Group"
		Case $sidtypedeletedaccount
			Return "Deleted Account"
		Case $sidtypeinvalid
			Return "Invalid"
		Case $sidtypeunknown
			Return "Unknown Type"
		Case $sidtypecomputer
			Return "Computer"
		Case $sidtypelabel
			Return "A mandatory integrity label SID"
		Case Else
			Return "Unknown SID Type"
	EndSwitch
EndFunc

Func _security__stringsidtosid($ssid)
	Local $acall = DllCall("advapi32.dll", "bool", "ConvertStringSidToSidW", "wstr", $ssid, "ptr*", 0)
	If @error OR NOT $acall[0] Then Return SetError(@error, @extended, 0)
	Local $psid = $acall[2]
	Local $tbuffer = DllStructCreate("byte Data[" & _security__getlengthsid($psid) & "]", $psid)
	Local $tsid = DllStructCreate("byte Data[" & DllStructGetSize($tbuffer) & "]")
	DllStructSetData($tsid, "Data", DllStructGetData($tbuffer, "Data"))
	DllCall("kernel32.dll", "handle", "LocalFree", "handle", $psid)
	Return $tsid
EndFunc

Func _sendmessage($hwnd, $imsg, $wparam = 0, $lparam = 0, $ireturn = 0, $wparamtype = "wparam", $lparamtype = "lparam", $sreturntype = "lresult")
	Local $aresult = DllCall("user32.dll", $sreturntype, "SendMessageW", "hwnd", $hwnd, "uint", $imsg, $wparamtype, $wparam, $lparamtype, $lparam)
	If @error Then Return SetError(@error, @extended, "")
	If $ireturn >= 0 AND $ireturn <= 4 Then Return $aresult[$ireturn]
	Return $aresult
EndFunc

Func _sendmessagea($hwnd, $imsg, $wparam = 0, $lparam = 0, $ireturn = 0, $wparamtype = "wparam", $lparamtype = "lparam", $sreturntype = "lresult")
	Local $aresult = DllCall("user32.dll", $sreturntype, "SendMessageA", "hwnd", $hwnd, "uint", $imsg, $wparamtype, $wparam, $lparamtype, $lparam)
	If @error Then Return SetError(@error, @extended, "")
	If $ireturn >= 0 AND $ireturn <= 4 Then Return $aresult[$ireturn]
	Return $aresult
EndFunc

Global Const $str_nocasesense = 0
Global Const $str_casesense = 1
Global Const $str_nocasesensebasic = 2
Global Const $str_stripleading = 1
Global Const $str_striptrailing = 2
Global Const $str_stripspaces = 4
Global Const $str_stripall = 8
Global Const $str_chrsplit = 0
Global Const $str_entiresplit = 1
Global Const $str_nocount = 2
Global Const $str_regexpmatch = 0
Global Const $str_regexparraymatch = 1
Global Const $str_regexparrayfullmatch = 2
Global Const $str_regexparrayglobalmatch = 3
Global Const $str_regexparrayglobalfullmatch = 4
Global Const $str_endisstart = 0
Global Const $str_endnotstart = 1
Global Const $sb_ansi = 1
Global Const $sb_utf16le = 2
Global Const $sb_utf16be = 3
Global Const $sb_utf8 = 4
Global Const $se_utf16 = 0
Global Const $se_ansi = 1
Global Const $se_utf8 = 2
Global Const $str_utf16 = 0
Global Const $str_ucs2 = 1
Global Const $hgdi_error = Ptr(-1)
Global Const $invalid_handle_value = Ptr(-1)
Global Const $clr_invalid = -1
Global Const $null_brush = 5
Global Const $null_pen = 8
Global Const $black_brush = 4
Global Const $dkgray_brush = 3
Global Const $dc_brush = 18
Global Const $gray_brush = 2
Global Const $hollow_brush = $null_brush
Global Const $ltgray_brush = 1
Global Const $white_brush = 0
Global Const $black_pen = 7
Global Const $dc_pen = 19
Global Const $white_pen = 6
Global Const $ansi_fixed_font = 11
Global Const $ansi_var_font = 12
Global Const $device_default_font = 14
Global Const $default_gui_font = 17
Global Const $oem_fixed_font = 10
Global Const $system_font = 13
Global Const $system_fixed_font = 16
Global Const $default_palette = 15
Global Const $mb_precomposed = 1
Global Const $mb_composite = 2
Global Const $mb_useglyphchars = 4
Global Const $ulw_alpha = 2
Global Const $ulw_colorkey = 1
Global Const $ulw_opaque = 4
Global Const $ulw_ex_noresize = 8
Global Const $wh_callwndproc = 4
Global Const $wh_callwndprocret = 12
Global Const $wh_cbt = 5
Global Const $wh_debug = 9
Global Const $wh_foregroundidle = 11
Global Const $wh_getmessage = 3
Global Const $wh_journalplayback = 1
Global Const $wh_journalrecord = 0
Global Const $wh_keyboard = 2
Global Const $wh_keyboard_ll = 13
Global Const $wh_mouse = 7
Global Const $wh_mouse_ll = 14
Global Const $wh_msgfilter = -1
Global Const $wh_shell = 10
Global Const $wh_sysmsgfilter = 6
Global Const $wpf_asyncwindowplacement = 4
Global Const $wpf_restoretomaximized = 2
Global Const $wpf_setminposition = 1
Global Const $kf_extended = 256
Global Const $kf_altdown = 8192
Global Const $kf_up = 32768
Global Const $llkhf_extended = BitShift($kf_extended, 8)
Global Const $llkhf_injected = 16
Global Const $llkhf_altdown = BitShift($kf_altdown, 8)
Global Const $llkhf_up = BitShift($kf_up, 8)
Global Const $ofn_allowmultiselect = 512
Global Const $ofn_createprompt = 8192
Global Const $ofn_dontaddtorecent = 33554432
Global Const $ofn_enablehook = 32
Global Const $ofn_enableincludenotify = 4194304
Global Const $ofn_enablesizing = 8388608
Global Const $ofn_enabletemplate = 64
Global Const $ofn_enabletemplatehandle = 128
Global Const $ofn_explorer = 524288
Global Const $ofn_extensiondifferent = 1024
Global Const $ofn_filemustexist = 4096
Global Const $ofn_forceshowhidden = 268435456
Global Const $ofn_hidereadonly = 4
Global Const $ofn_longnames = 2097152
Global Const $ofn_nochangedir = 8
Global Const $ofn_nodereferencelinks = 1048576
Global Const $ofn_nolongnames = 262144
Global Const $ofn_nonetworkbutton = 131072
Global Const $ofn_noreadonlyreturn = 32768
Global Const $ofn_notestfilecreate = 65536
Global Const $ofn_novalidate = 256
Global Const $ofn_overwriteprompt = 2
Global Const $ofn_pathmustexist = 2048
Global Const $ofn_readonly = 1
Global Const $ofn_shareaware = 16384
Global Const $ofn_showhelp = 16
Global Const $ofn_ex_noplacesbar = 1
Global Const $tmpf_fixed_pitch = 1
Global Const $tmpf_vector = 2
Global Const $tmpf_truetype = 4
Global Const $tmpf_device = 8
Global Const $duplicate_close_source = 1
Global Const $duplicate_same_access = 2
Global Const $di_mask = 1
Global Const $di_image = 2
Global Const $di_normal = 3
Global Const $di_compat = 4
Global Const $di_defaultsize = 8
Global Const $di_nomirror = 16
Global Const $display_device_attached_to_desktop = 1
Global Const $display_device_multi_driver = 2
Global Const $display_device_primary_device = 4
Global Const $display_device_mirroring_driver = 8
Global Const $display_device_vga_compatible = 16
Global Const $display_device_removable = 32
Global Const $display_device_disconnect = 33554432
Global Const $display_device_remote = 67108864
Global Const $display_device_modespruned = 134217728
Global Const $flashw_caption = 1
Global Const $flashw_tray = 2
Global Const $flashw_timer = 4
Global Const $flashw_timernofg = 12
Global Const $format_message_allocate_buffer = 256
Global Const $format_message_ignore_inserts = 512
Global Const $format_message_from_string = 1024
Global Const $format_message_from_hmodule = 2048
Global Const $format_message_from_system = 4096
Global Const $format_message_argument_array = 8192
Global Const $gw_hwndfirst = 0
Global Const $gw_hwndlast = 1
Global Const $gw_hwndnext = 2
Global Const $gw_hwndprev = 3
Global Const $gw_owner = 4
Global Const $gw_child = 5
Global Const $gw_enabledpopup = 6
Global Const $gwl_wndproc = -4
Global Const $gwl_hinstance = -6
Global Const $gwl_hwndparent = -8
Global Const $gwl_id = -12
Global Const $gwl_style = -16
Global Const $gwl_exstyle = -20
Global Const $gwl_userdata = -21
Global Const $std_cut = 0
Global Const $std_copy = 1
Global Const $std_paste = 2
Global Const $std_undo = 3
Global Const $std_redow = 4
Global Const $std_delete = 5
Global Const $std_filenew = 6
Global Const $std_fileopen = 7
Global Const $std_filesave = 8
Global Const $std_printpre = 9
Global Const $std_properties = 10
Global Const $std_help = 11
Global Const $std_find = 12
Global Const $std_replace = 13
Global Const $std_print = 14
Global Const $image_bitmap = 0
Global Const $image_icon = 1
Global Const $image_cursor = 2
Global Const $image_enhmetafile = 3
Global Const $kb_sendspecial = 0
Global Const $kb_sendraw = 1
Global Const $kb_capsoff = 0
Global Const $kb_capson = 1
Global Const $dont_resolve_dll_references = 1
Global Const $load_library_as_datafile = 2
Global Const $load_with_altered_search_path = 8
Global Const $load_ignore_code_authz_level = 16
Global Const $load_library_as_datafile_exclusive = 64
Global Const $load_library_as_image_resource = 32
Global Const $load_library_search_application_dir = 512
Global Const $load_library_search_default_dirs = 4096
Global Const $load_library_search_dll_load_dir = 256
Global Const $load_library_search_system32 = 2048
Global Const $load_library_search_user_dirs = 1024
Global Const $s_ok = 0
Global Const $e_abort = -2147467260
Global Const $e_accessdenied = -2147024891
Global Const $e_fail = -2147467259
Global Const $e_handle = -2147024890
Global Const $e_invalidarg = -2147024809
Global Const $e_nointerface = -2147467262
Global Const $e_notimpl = -2147467263
Global Const $e_outofmemory = -2147024882
Global Const $e_pointer = -2147467261
Global Const $e_unexpected = -2147418113
Global Const $lr_defaultcolor = 0
Global Const $lr_monochrome = 1
Global Const $lr_color = 2
Global Const $lr_copyreturnorg = 4
Global Const $lr_copydeleteorg = 8
Global Const $lr_loadfromfile = 16
Global Const $lr_loadtransparent = 32
Global Const $lr_defaultsize = 64
Global Const $lr_vgacolor = 128
Global Const $lr_loadmap3dcolors = 4096
Global Const $lr_createdibsection = 8192
Global Const $lr_copyfromresource = 16384
Global Const $lr_shared = 32768
Global Const $obm_trtype = 32732
Global Const $obm_lfarrowi = 32734
Global Const $obm_rgarrowi = 32735
Global Const $obm_dnarrowi = 32736
Global Const $obm_uparrowi = 32737
Global Const $obm_combo = 32738
Global Const $obm_mnarrow = 32739
Global Const $obm_lfarrowd = 32740
Global Const $obm_rgarrowd = 32741
Global Const $obm_dnarrowd = 32742
Global Const $obm_uparrowd = 32743
Global Const $obm_restored = 32744
Global Const $obm_zoomd = 32745
Global Const $obm_reduced = 32746
Global Const $obm_restore = 32747
Global Const $obm_zoom = 32748
Global Const $obm_reduce = 32749
Global Const $obm_lfarrow = 32750
Global Const $obm_rgarrow = 32751
Global Const $obm_dnarrow = 32752
Global Const $obm_uparrow = 32753
Global Const $obm_close = 32754
Global Const $obm_old_restore = 32755
Global Const $obm_old_zoom = 32756
Global Const $obm_old_reduce = 32757
Global Const $obm_btncorners = 32758
Global Const $obm_checkboxes = 32759
Global Const $obm_check = 32760
Global Const $obm_btsize = 32761
Global Const $obm_old_lfarrow = 32762
Global Const $obm_old_rgarrow = 32763
Global Const $obm_old_dnarrow = 32764
Global Const $obm_old_uparrow = 32765
Global Const $obm_size = 32766
Global Const $obm_old_close = 32767
Global Const $oic_sample = 32512
Global Const $oic_hand = 32513
Global Const $oic_ques = 32514
Global Const $oic_bang = 32515
Global Const $oic_note = 32516
Global Const $oic_winlogo = 32517
Global Const $oic_warning = $oic_bang
Global Const $oic_error = $oic_hand
Global Const $oic_information = $oic_note
Global $__g_ainprocess_winapi[64][2] = [[0, 0]]
Global $__g_awinlist_winapi[64][2] = [[0, 0]]
Global Const $__winapiconstant_wm_setfont = 48
Global Const $__winapiconstant_fw_normal = 400
Global Const $__winapiconstant_default_charset = 1
Global Const $__winapiconstant_out_default_precis = 0
Global Const $__winapiconstant_clip_default_precis = 0
Global Const $__winapiconstant_default_quality = 0
Global Const $__winapiconstant_logpixelsx = 88
Global Const $__winapiconstant_logpixelsy = 90
Global Const $tagcursorinfo = "dword Size;dword Flags;handle hCursor;" & $tagpoint
Global Const $tagdisplay_device = "dword Size;wchar Name[32];wchar String[128];dword Flags;wchar ID[128];wchar Key[128]"
Global Const $tagflashwinfo = "uint Size;hwnd hWnd;dword Flags;uint Count;dword TimeOut"
Global Const $tagiconinfo = "bool Icon;dword XHotSpot;dword YHotSpot;handle hMask;handle hColor"
Global Const $tagmemorystatusex = "dword Length;dword MemoryLoad;" & "uint64 TotalPhys;uint64 AvailPhys;uint64 TotalPageFile;uint64 AvailPageFile;" & "uint64 TotalVirtual;uint64 AvailVirtual;uint64 AvailExtendedVirtual"

Func _winapi_attachconsole($ipid = -1)
	Local $aresult = DllCall("kernel32.dll", "bool", "AttachConsole", "dword", $ipid)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_attachthreadinput($iattach, $iattachto, $battach)
	Local $aresult = DllCall("user32.dll", "bool", "AttachThreadInput", "dword", $iattach, "dword", $iattachto, "bool", $battach)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_beep($ifreq = 500, $iduration = 1000)
	Local $aresult = DllCall("kernel32.dll", "bool", "Beep", "dword", $ifreq, "dword", $iduration)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_bitblt($hdestdc, $ixdest, $iydest, $iwidth, $iheight, $hsrcdc, $ixsrc, $iysrc, $irop)
	Local $aresult = DllCall("gdi32.dll", "bool", "BitBlt", "handle", $hdestdc, "int", $ixdest, "int", $iydest, "int", $iwidth, "int", $iheight, "handle", $hsrcdc, "int", $ixsrc, "int", $iysrc, "dword", $irop)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_callnexthookex($hhook, $icode, $wparam, $lparam)
	Local $aresult = DllCall("user32.dll", "lresult", "CallNextHookEx", "handle", $hhook, "int", $icode, "wparam", $wparam, "lparam", $lparam)
	If @error Then Return SetError(@error, @extended, -1)
	Return $aresult[0]
EndFunc

Func _winapi_callwindowproc($pprevwndfunc, $hwnd, $imsg, $wparam, $lparam)
	Local $aresult = DllCall("user32.dll", "lresult", "CallWindowProc", "ptr", $pprevwndfunc, "hwnd", $hwnd, "uint", $imsg, "wparam", $wparam, "lparam", $lparam)
	If @error Then Return SetError(@error, @extended, -1)
	Return $aresult[0]
EndFunc

Func _winapi_clienttoscreen($hwnd, ByRef $tpoint)
	Local $aret = DllCall("user32.dll", "bool", "ClientToScreen", "hwnd", $hwnd, "struct*", $tpoint)
	If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
	Return $tpoint
EndFunc

Func _winapi_closehandle($hobject)
	Local $aresult = DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hobject)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_combinergn($hrgndest, $hrgnsrc1, $hrgnsrc2, $icombinemode)
	Local $aresult = DllCall("gdi32.dll", "int", "CombineRgn", "handle", $hrgndest, "handle", $hrgnsrc1, "handle", $hrgnsrc2, "int", $icombinemode)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_commdlgextendederror()
	Local Const $cderr_dialogfailure = 65535
	Local Const $cderr_findresfailure = 6
	Local Const $cderr_initialization = 2
	Local Const $cderr_loadresfailure = 7
	Local Const $cderr_loadstrfailure = 5
	Local Const $cderr_lockresfailure = 8
	Local Const $cderr_memallocfailure = 9
	Local Const $cderr_memlockfailure = 10
	Local Const $cderr_nohinstance = 4
	Local Const $cderr_nohook = 11
	Local Const $cderr_notemplate = 3
	Local Const $cderr_registermsgfail = 12
	Local Const $cderr_structsize = 1
	Local Const $fnerr_buffertoosmall = 12291
	Local Const $fnerr_invalidfilename = 12290
	Local Const $fnerr_subclassfailure = 12289
	Local $aresult = DllCall("comdlg32.dll", "dword", "CommDlgExtendedError")
	If NOT @error Then
		Switch $aresult[0]
			Case $cderr_dialogfailure
				Return SetError($aresult[0], 0, "The dialog box could not be created." & @LF & "The common dialog box function's call to the DialogBox function failed." & @LF & "For example, this error occurs if the common dialog box call specifies an invalid window handle.")
			Case $cderr_findresfailure
				Return SetError($aresult[0], 0, "The common dialog box function failed to find a specified resource.")
			Case $cderr_initialization
				Return SetError($aresult[0], 0, "The common dialog box function failed during initialization." & @LF & "This error often occurs when sufficient memory is not available.")
			Case $cderr_loadresfailure
				Return SetError($aresult[0], 0, "The common dialog box function failed to load a specified resource.")
			Case $cderr_loadstrfailure
				Return SetError($aresult[0], 0, "The common dialog box function failed to load a specified string.")
			Case $cderr_lockresfailure
				Return SetError($aresult[0], 0, "The common dialog box function failed to lock a specified resource.")
			Case $cderr_memallocfailure
				Return SetError($aresult[0], 0, "The common dialog box function was unable to allocate memory for internal structures.")
			Case $cderr_memlockfailure
				Return SetError($aresult[0], 0, "The common dialog box function was unable to lock the memory associated with a handle.")
			Case $cderr_nohinstance
				Return SetError($aresult[0], 0, "The ENABLETEMPLATE flag was set in the Flags member of the initialization structure for the corresponding common dialog box," & @LF & "but you failed to provide a corresponding instance handle.")
			Case $cderr_nohook
				Return SetError($aresult[0], 0, "The ENABLEHOOK flag was set in the Flags member of the initialization structure for the corresponding common dialog box," & @LF & "but you failed to provide a pointer to a corresponding hook procedure.")
			Case $cderr_notemplate
				Return SetError($aresult[0], 0, "The ENABLETEMPLATE flag was set in the Flags member of the initialization structure for the corresponding common dialog box," & @LF & "but you failed to provide a corresponding template.")
			Case $cderr_registermsgfail
				Return SetError($aresult[0], 0, "The RegisterWindowMessage function returned an error code when it was called by the common dialog box function.")
			Case $cderr_structsize
				Return SetError($aresult[0], 0, "The lStructSize member of the initialization structure for the corresponding common dialog box is invalid")
			Case $fnerr_buffertoosmall
				Return SetError($aresult[0], 0, "The buffer pointed to by the lpstrFile member of the OPENFILENAME structure is too small for the file name specified by the user." & @LF & "The first two bytes of the lpstrFile buffer contain an integer value specifying the size, in TCHARs, required to receive the full name.")
			Case $fnerr_invalidfilename
				Return SetError($aresult[0], 0, "A file name is invalid.")
			Case $fnerr_subclassfailure
				Return SetError($aresult[0], 0, "An attempt to subclass a list box failed because sufficient memory was not available.")
		EndSwitch
	EndIf
	Return SetError(@error, @extended, "0x" & Hex($aresult[0]))
EndFunc

Func _winapi_copyicon($hicon)
	Local $aresult = DllCall("user32.dll", "handle", "CopyIcon", "handle", $hicon)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_createbitmap($iwidth, $iheight, $iplanes = 1, $ibitsperpel = 1, $pbits = 0)
	Local $aresult = DllCall("gdi32.dll", "handle", "CreateBitmap", "int", $iwidth, "int", $iheight, "uint", $iplanes, "uint", $ibitsperpel, "struct*", $pbits)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_createcompatiblebitmap($hdc, $iwidth, $iheight)
	Local $aresult = DllCall("gdi32.dll", "handle", "CreateCompatibleBitmap", "handle", $hdc, "int", $iwidth, "int", $iheight)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_createcompatibledc($hdc)
	Local $aresult = DllCall("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $hdc)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_createevent($tattributes = 0, $bmanualreset = True, $binitialstate = True, $sname = "")
	Local $snametype = "wstr"
	If $sname = "" Then
		$sname = 0
		$snametype = "ptr"
	EndIf
	Local $aresult = DllCall("kernel32.dll", "handle", "CreateEventW", "struct*", $tattributes, "bool", $bmanualreset, "bool", $binitialstate, $snametype, $sname)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_createfile($sfilename, $icreation, $iaccess = 4, $ishare = 0, $iattributes = 0, $tsecurity = 0)
	Local $ida = 0, $ism = 0, $icd = 0, $ifa = 0
	If BitAND($iaccess, 1) <> 0 Then $ida = BitOR($ida, $generic_execute)
	If BitAND($iaccess, 2) <> 0 Then $ida = BitOR($ida, $generic_read)
	If BitAND($iaccess, 4) <> 0 Then $ida = BitOR($ida, $generic_write)
	If BitAND($ishare, 1) <> 0 Then $ism = BitOR($ism, $file_share_delete)
	If BitAND($ishare, 2) <> 0 Then $ism = BitOR($ism, $file_share_read)
	If BitAND($ishare, 4) <> 0 Then $ism = BitOR($ism, $file_share_write)
	Switch $icreation
		Case 0
			$icd = $create_new
		Case 1
			$icd = $create_always
		Case 2
			$icd = $open_existing
		Case 3
			$icd = $open_always
		Case 4
			$icd = $truncate_existing
	EndSwitch
	If BitAND($iattributes, 1) <> 0 Then $ifa = BitOR($ifa, $file_attribute_archive)
	If BitAND($iattributes, 2) <> 0 Then $ifa = BitOR($ifa, $file_attribute_hidden)
	If BitAND($iattributes, 4) <> 0 Then $ifa = BitOR($ifa, $file_attribute_readonly)
	If BitAND($iattributes, 8) <> 0 Then $ifa = BitOR($ifa, $file_attribute_system)
	Local $aresult = DllCall("kernel32.dll", "handle", "CreateFileW", "wstr", $sfilename, "dword", $ida, "dword", $ism, "struct*", $tsecurity, "dword", $icd, "dword", $ifa, "ptr", 0)
	If @error OR ($aresult[0] = $invalid_handle_value) Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_createfont($iheight, $iwidth, $iescape = 0, $iorientn = 0, $iweight = $__winapiconstant_fw_normal, $bitalic = False, $bunderline = False, $bstrikeout = False, $icharset = $__winapiconstant_default_charset, $ioutputprec = $__winapiconstant_out_default_precis, $iclipprec = $__winapiconstant_clip_default_precis, $iquality = $__winapiconstant_default_quality, $ipitch = 0, $sface = "Arial")
	Local $aresult = DllCall("gdi32.dll", "handle", "CreateFontW", "int", $iheight, "int", $iwidth, "int", $iescape, "int", $iorientn, "int", $iweight, "dword", $bitalic, "dword", $bunderline, "dword", $bstrikeout, "dword", $icharset, "dword", $ioutputprec, "dword", $iclipprec, "dword", $iquality, "dword", $ipitch, "wstr", $sface)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_createfontindirect($tlogfont)
	Local $aresult = DllCall("gdi32.dll", "handle", "CreateFontIndirectW", "struct*", $tlogfont)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_createpen($ipenstyle, $iwidth, $icolor)
	Local $aresult = DllCall("gdi32.dll", "handle", "CreatePen", "int", $ipenstyle, "int", $iwidth, "INT", $icolor)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_createprocess($sappname, $scommand, $tsecurity, $tthread, $binherit, $iflags, $penviron, $sdir, $tstartupinfo, $tprocess)
	Local $tcommand = 0
	Local $sappnametype = "wstr", $sdirtype = "wstr"
	If $sappname = "" Then
		$sappnametype = "ptr"
		$sappname = 0
	EndIf
	If $scommand <> "" Then
		$tcommand = DllStructCreate("wchar Text[" & 260 + 1 & "]")
		DllStructSetData($tcommand, "Text", $scommand)
	EndIf
	If $sdir = "" Then
		$sdirtype = "ptr"
		$sdir = 0
	EndIf
	Local $aresult = DllCall("kernel32.dll", "bool", "CreateProcessW", $sappnametype, $sappname, "struct*", $tcommand, "struct*", $tsecurity, "struct*", $tthread, "bool", $binherit, "dword", $iflags, "struct*", $penviron, $sdirtype, $sdir, "struct*", $tstartupinfo, "struct*", $tprocess)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_createrectrgn($ileftrect, $itoprect, $irightrect, $ibottomrect)
	Local $aresult = DllCall("gdi32.dll", "handle", "CreateRectRgn", "int", $ileftrect, "int", $itoprect, "int", $irightrect, "int", $ibottomrect)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_createroundrectrgn($ileftrect, $itoprect, $irightrect, $ibottomrect, $iwidthellipse, $iheightellipse)
	Local $aresult = DllCall("gdi32.dll", "handle", "CreateRoundRectRgn", "int", $ileftrect, "int", $itoprect, "int", $irightrect, "int", $ibottomrect, "int", $iwidthellipse, "int", $iheightellipse)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_createsolidbitmap($hwnd, $icolor, $iwidth, $iheight, $brgb = 1)
	Local $hdc = _winapi_getdc($hwnd)
	Local $hdestdc = _winapi_createcompatibledc($hdc)
	Local $hbitmap = _winapi_createcompatiblebitmap($hdc, $iwidth, $iheight)
	Local $hold = _winapi_selectobject($hdestdc, $hbitmap)
	Local $trect = DllStructCreate($tagrect)
	DllStructSetData($trect, 1, 0)
	DllStructSetData($trect, 2, 0)
	DllStructSetData($trect, 3, $iwidth)
	DllStructSetData($trect, 4, $iheight)
	If $brgb Then
		$icolor = BitOR(BitAND($icolor, 65280), BitShift(BitAND($icolor, 255), -16), BitShift(BitAND($icolor, 16711680), 16))
	EndIf
	Local $hbrush = _winapi_createsolidbrush($icolor)
	If NOT _winapi_fillrect($hdestdc, $trect, $hbrush) Then
		_winapi_deleteobject($hbitmap)
		$hbitmap = 0
	EndIf
	_winapi_deleteobject($hbrush)
	_winapi_releasedc($hwnd, $hdc)
	_winapi_selectobject($hdestdc, $hold)
	_winapi_deletedc($hdestdc)
	If NOT $hbitmap Then Return SetError(1, 0, 0)
	Return $hbitmap
EndFunc

Func _winapi_createsolidbrush($icolor)
	Local $aresult = DllCall("gdi32.dll", "handle", "CreateSolidBrush", "INT", $icolor)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_createwindowex($iexstyle, $sclass, $sname, $istyle, $ix, $iy, $iwidth, $iheight, $hparent, $hmenu = 0, $hinstance = 0, $pparam = 0)
	If $hinstance = 0 Then $hinstance = _winapi_getmodulehandle("")
	Local $aresult = DllCall("user32.dll", "hwnd", "CreateWindowExW", "dword", $iexstyle, "wstr", $sclass, "wstr", $sname, "dword", $istyle, "int", $ix, "int", $iy, "int", $iwidth, "int", $iheight, "hwnd", $hparent, "handle", $hmenu, "handle", $hinstance, "struct*", $pparam)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_defwindowproc($hwnd, $imsg, $wparam, $lparam)
	Local $aresult = DllCall("user32.dll", "lresult", "DefWindowProc", "hwnd", $hwnd, "uint", $imsg, "wparam", $wparam, "lparam", $lparam)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_deletedc($hdc)
	Local $aresult = DllCall("gdi32.dll", "bool", "DeleteDC", "handle", $hdc)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_deleteobject($hobject)
	Local $aresult = DllCall("gdi32.dll", "bool", "DeleteObject", "handle", $hobject)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_destroyicon($hicon)
	Local $aresult = DllCall("user32.dll", "bool", "DestroyIcon", "handle", $hicon)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_destroywindow($hwnd)
	Local $aresult = DllCall("user32.dll", "bool", "DestroyWindow", "hwnd", $hwnd)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_drawedge($hdc, $trect, $iedgetype, $iflags)
	Local $aresult = DllCall("user32.dll", "bool", "DrawEdge", "handle", $hdc, "struct*", $trect, "uint", $iedgetype, "uint", $iflags)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_drawframecontrol($hdc, $trect, $itype, $istate)
	Local $aresult = DllCall("user32.dll", "bool", "DrawFrameControl", "handle", $hdc, "struct*", $trect, "uint", $itype, "uint", $istate)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_drawicon($hdc, $ix, $iy, $hicon)
	Local $aresult = DllCall("user32.dll", "bool", "DrawIcon", "handle", $hdc, "int", $ix, "int", $iy, "handle", $hicon)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_drawiconex($hdc, $ix, $iy, $hicon, $iwidth = 0, $iheight = 0, $istep = 0, $hbrush = 0, $iflags = 3)
	Local $ioptions
	Switch $iflags
		Case 1
			$ioptions = $di_mask
		Case 2
			$ioptions = $di_image
		Case 3
			$ioptions = $di_normal
		Case 4
			$ioptions = $di_compat
		Case 5
			$ioptions = $di_defaultsize
		Case Else
			$ioptions = $di_nomirror
	EndSwitch
	Local $aresult = DllCall("user32.dll", "bool", "DrawIconEx", "handle", $hdc, "int", $ix, "int", $iy, "handle", $hicon, "int", $iwidth, "int", $iheight, "uint", $istep, "handle", $hbrush, "uint", $ioptions)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_drawline($hdc, $ix1, $iy1, $ix2, $iy2)
	_winapi_moveto($hdc, $ix1, $iy1)
	If @error Then Return SetError(@error, @extended, False)
	_winapi_lineto($hdc, $ix2, $iy2)
	If @error Then Return SetError(@error + 10, @extended, False)
	Return True
EndFunc

Func _winapi_drawtext($hdc, $stext, ByRef $trect, $iflags)
	Local $aresult = DllCall("user32.dll", "int", "DrawTextW", "handle", $hdc, "wstr", $stext, "int", -1, "struct*", $trect, "uint", $iflags)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_duplicatehandle($hsourceprocesshandle, $hsourcehandle, $htargetprocesshandle, $idesiredaccess, $iinherithandle, $ioptions)
	Local $aresult = DllCall("kernel32.dll", "bool", "DuplicateHandle", "handle", $hsourceprocesshandle, "handle", $hsourcehandle, "handle", $htargetprocesshandle, "handle*", 0, "dword", $idesiredaccess, "bool", $iinherithandle, "dword", $ioptions)
	If @error OR NOT $aresult[0] Then Return SetError(@error, @extended, 0)
	Return $aresult[4]
EndFunc

Func _winapi_enablewindow($hwnd, $benable = True)
	Local $aresult = DllCall("user32.dll", "bool", "EnableWindow", "hwnd", $hwnd, "bool", $benable)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_enumdisplaydevices($sdevice, $idevnum)
	Local $tname = 0, $iflags = 0, $adevice[5]
	If $sdevice <> "" Then
		$tname = DllStructCreate("wchar Text[" & StringLen($sdevice) + 1 & "]")
		DllStructSetData($tname, "Text", $sdevice)
	EndIf
	Local $tdevice = DllStructCreate($tagdisplay_device)
	Local $idevice = DllStructGetSize($tdevice)
	DllStructSetData($tdevice, "Size", $idevice)
	Local $aret = DllCall("user32.dll", "bool", "EnumDisplayDevicesW", "struct*", $tname, "dword", $idevnum, "struct*", $tdevice, "dword", 1)
	If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
	Local $in = DllStructGetData($tdevice, "Flags")
	If BitAND($in, $display_device_attached_to_desktop) <> 0 Then $iflags = BitOR($iflags, 1)
	If BitAND($in, $display_device_primary_device) <> 0 Then $iflags = BitOR($iflags, 2)
	If BitAND($in, $display_device_mirroring_driver) <> 0 Then $iflags = BitOR($iflags, 4)
	If BitAND($in, $display_device_vga_compatible) <> 0 Then $iflags = BitOR($iflags, 8)
	If BitAND($in, $display_device_removable) <> 0 Then $iflags = BitOR($iflags, 16)
	If BitAND($in, $display_device_modespruned) <> 0 Then $iflags = BitOR($iflags, 32)
	$adevice[0] = True
	$adevice[1] = DllStructGetData($tdevice, "Name")
	$adevice[2] = DllStructGetData($tdevice, "String")
	$adevice[3] = $iflags
	$adevice[4] = DllStructGetData($tdevice, "ID")
	Return $adevice
EndFunc

Func _winapi_enumwindows($bvisible = True, $hwnd = Default)
	__winapi_enumwindowsinit()
	If $hwnd = Default Then $hwnd = _winapi_getdesktopwindow()
	__winapi_enumwindowschild($hwnd, $bvisible)
	Return $__g_awinlist_winapi
EndFunc

Func __winapi_enumwindowsadd($hwnd, $sclass = "")
	If $sclass = "" Then $sclass = _winapi_getclassname($hwnd)
	$__g_awinlist_winapi[0][0] += 1
	Local $icount = $__g_awinlist_winapi[0][0]
	If $icount >= $__g_awinlist_winapi[0][1] Then
		ReDim $__g_awinlist_winapi[$icount + 64][2]
		$__g_awinlist_winapi[0][1] += 64
	EndIf
	$__g_awinlist_winapi[$icount][0] = $hwnd
	$__g_awinlist_winapi[$icount][1] = $sclass
EndFunc

Func __winapi_enumwindowschild($hwnd, $bvisible = True)
	$hwnd = _winapi_getwindow($hwnd, $gw_child)
	While $hwnd <> 0
		If (NOT $bvisible) OR _winapi_iswindowvisible($hwnd) Then
			__winapi_enumwindowsadd($hwnd)
			__winapi_enumwindowschild($hwnd, $bvisible)
		EndIf
		$hwnd = _winapi_getwindow($hwnd, $gw_hwndnext)
	WEnd
EndFunc

Func __winapi_enumwindowsinit()
	ReDim $__g_awinlist_winapi[64][2]
	$__g_awinlist_winapi[0][0] = 0
	$__g_awinlist_winapi[0][1] = 64
EndFunc

Func _winapi_enumwindowspopup()
	__winapi_enumwindowsinit()
	Local $hwnd = _winapi_getwindow(_winapi_getdesktopwindow(), $gw_child)
	Local $sclass
	While $hwnd <> 0
		If _winapi_iswindowvisible($hwnd) Then
			$sclass = _winapi_getclassname($hwnd)
			If $sclass = "#32768" Then
				__winapi_enumwindowsadd($hwnd)
			ElseIf $sclass = "ToolbarWindow32" Then
				__winapi_enumwindowsadd($hwnd)
			ElseIf $sclass = "ToolTips_Class32" Then
				__winapi_enumwindowsadd($hwnd)
			ElseIf $sclass = "BaseBar" Then
				__winapi_enumwindowschild($hwnd)
			EndIf
		EndIf
		$hwnd = _winapi_getwindow($hwnd, $gw_hwndnext)
	WEnd
	Return $__g_awinlist_winapi
EndFunc

Func _winapi_enumwindowstop()
	__winapi_enumwindowsinit()
	Local $hwnd = _winapi_getwindow(_winapi_getdesktopwindow(), $gw_child)
	While $hwnd <> 0
		If _winapi_iswindowvisible($hwnd) Then __winapi_enumwindowsadd($hwnd)
		$hwnd = _winapi_getwindow($hwnd, $gw_hwndnext)
	WEnd
	Return $__g_awinlist_winapi
EndFunc

Func _winapi_expandenvironmentstrings($sstring)
	Local $aresult = DllCall("kernel32.dll", "dword", "ExpandEnvironmentStringsW", "wstr", $sstring, "wstr", "", "dword", 4096)
	If @error OR NOT $aresult[0] Then Return SetError(@error + 10, @extended, "")
	Return $aresult[2]
EndFunc

Func _winapi_extracticonex($sfilepath, $iindex, $palarge, $pasmall, $iicons)
	Local $aresult = DllCall("shell32.dll", "uint", "ExtractIconExW", "wstr", $sfilepath, "int", $iindex, "struct*", $palarge, "struct*", $pasmall, "uint", $iicons)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_fatalappexit($smessage)
	DllCall("kernel32.dll", "none", "FatalAppExitW", "uint", 0, "wstr", $smessage)
	If @error Then Return SetError(@error, @extended)
EndFunc

Func _winapi_fillrect($hdc, $trect, $hbrush)
	Local $aresult
	If IsPtr($hbrush) Then
		$aresult = DllCall("user32.dll", "int", "FillRect", "handle", $hdc, "struct*", $trect, "handle", $hbrush)
	Else
		$aresult = DllCall("user32.dll", "int", "FillRect", "handle", $hdc, "struct*", $trect, "dword_ptr", $hbrush)
	EndIf
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_findexecutable($sfilename, $sdirectory = "")
	Local $aresult = DllCall("shell32.dll", "INT", "FindExecutableW", "wstr", $sfilename, "wstr", $sdirectory, "wstr", "")
	If @error Then Return SetError(@error, @extended, "")
	If $aresult[0] <= 32 Then Return SetError(10, $aresult[0], "")
	Return SetExtended($aresult[0], $aresult[3])
EndFunc

Func _winapi_findwindow($sclassname, $swindowname)
	Local $aresult = DllCall("user32.dll", "hwnd", "FindWindowW", "wstr", $sclassname, "wstr", $swindowname)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_flashwindow($hwnd, $binvert = True)
	Local $aresult = DllCall("user32.dll", "bool", "FlashWindow", "hwnd", $hwnd, "bool", $binvert)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_flashwindowex($hwnd, $iflags = 3, $icount = 3, $itimeout = 0)
	Local $tflash = DllStructCreate($tagflashwinfo)
	Local $iflash = DllStructGetSize($tflash)
	Local $imode = 0
	If BitAND($iflags, 1) <> 0 Then $imode = BitOR($imode, $flashw_caption)
	If BitAND($iflags, 2) <> 0 Then $imode = BitOR($imode, $flashw_tray)
	If BitAND($iflags, 4) <> 0 Then $imode = BitOR($imode, $flashw_timer)
	If BitAND($iflags, 8) <> 0 Then $imode = BitOR($imode, $flashw_timernofg)
	DllStructSetData($tflash, "Size", $iflash)
	DllStructSetData($tflash, "hWnd", $hwnd)
	DllStructSetData($tflash, "Flags", $imode)
	DllStructSetData($tflash, "Count", $icount)
	DllStructSetData($tflash, "Timeout", $itimeout)
	Local $aresult = DllCall("user32.dll", "bool", "FlashWindowEx", "struct*", $tflash)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_floattoint($nfloat)
	Local $tfloat = DllStructCreate("float")
	Local $tint = DllStructCreate("int", DllStructGetPtr($tfloat))
	DllStructSetData($tfloat, 1, $nfloat)
	Return DllStructGetData($tint, 1)
EndFunc

Func _winapi_flushfilebuffers($hfile)
	Local $aresult = DllCall("kernel32.dll", "bool", "FlushFileBuffers", "handle", $hfile)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_formatmessage($iflags, $psource, $imessageid, $ilanguageid, ByRef $pbuffer, $isize, $varguments)
	Local $sbuffertype = "struct*"
	If IsString($pbuffer) Then $sbuffertype = "wstr"
	Local $aresult = DllCall("kernel32.dll", "dword", "FormatMessageW", "dword", $iflags, "struct*", $psource, "dword", $imessageid, "dword", $ilanguageid, $sbuffertype, $pbuffer, "dword", $isize, "ptr", $varguments)
	If @error OR NOT $aresult[0] Then Return SetError(@error + 10, @extended, 0)
	If $sbuffertype = "wstr" Then $pbuffer = $aresult[5]
	Return $aresult[0]
EndFunc

Func _winapi_framerect($hdc, $trect, $hbrush)
	Local $aresult = DllCall("user32.dll", "int", "FrameRect", "handle", $hdc, "struct*", $trect, "handle", $hbrush)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_freelibrary($hmodule)
	Local $aresult = DllCall("kernel32.dll", "bool", "FreeLibrary", "handle", $hmodule)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_getancestor($hwnd, $iflags = 1)
	Local $aresult = DllCall("user32.dll", "hwnd", "GetAncestor", "hwnd", $hwnd, "uint", $iflags)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_getasynckeystate($ikey)
	Local $aresult = DllCall("user32.dll", "short", "GetAsyncKeyState", "int", $ikey)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_getbkmode($hdc)
	Local $aresult = DllCall("gdi32.dll", "int", "GetBkMode", "handle", $hdc)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_getclassname($hwnd)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Local $aresult = DllCall("user32.dll", "int", "GetClassNameW", "hwnd", $hwnd, "wstr", "", "int", 4096)
	If @error OR NOT $aresult[0] Then Return SetError(@error, @extended, "")
	Return SetExtended($aresult[0], $aresult[2])
EndFunc

Func _winapi_getclientheight($hwnd)
	Local $trect = _winapi_getclientrect($hwnd)
	If @error Then Return SetError(@error, @extended, 0)
	Return DllStructGetData($trect, "Bottom") - DllStructGetData($trect, "Top")
EndFunc

Func _winapi_getclientwidth($hwnd)
	Local $trect = _winapi_getclientrect($hwnd)
	If @error Then Return SetError(@error, @extended, 0)
	Return DllStructGetData($trect, "Right") - DllStructGetData($trect, "Left")
EndFunc

Func _winapi_getclientrect($hwnd)
	Local $trect = DllStructCreate($tagrect)
	Local $aret = DllCall("user32.dll", "bool", "GetClientRect", "hwnd", $hwnd, "struct*", $trect)
	If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
	Return $trect
EndFunc

Func _winapi_getcurrentprocess()
	Local $aresult = DllCall("kernel32.dll", "handle", "GetCurrentProcess")
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_getcurrentprocessid()
	Local $aresult = DllCall("kernel32.dll", "dword", "GetCurrentProcessId")
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_getcurrentthread()
	Local $aresult = DllCall("kernel32.dll", "handle", "GetCurrentThread")
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_getcurrentthreadid()
	Local $aresult = DllCall("kernel32.dll", "dword", "GetCurrentThreadId")
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_getcursorinfo()
	Local $tcursor = DllStructCreate($tagcursorinfo)
	Local $icursor = DllStructGetSize($tcursor)
	DllStructSetData($tcursor, "Size", $icursor)
	Local $aret = DllCall("user32.dll", "bool", "GetCursorInfo", "struct*", $tcursor)
	If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
	Local $acursor[5]
	$acursor[0] = True
	$acursor[1] = DllStructGetData($tcursor, "Flags") <> 0
	$acursor[2] = DllStructGetData($tcursor, "hCursor")
	$acursor[3] = DllStructGetData($tcursor, "X")
	$acursor[4] = DllStructGetData($tcursor, "Y")
	Return $acursor
EndFunc

Func _winapi_getdc($hwnd)
	Local $aresult = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hwnd)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_getdesktopwindow()
	Local $aresult = DllCall("user32.dll", "hwnd", "GetDesktopWindow")
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_getdevicecaps($hdc, $iindex)
	Local $aresult = DllCall("gdi32.dll", "int", "GetDeviceCaps", "handle", $hdc, "int", $iindex)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_getdibits($hdc, $hbitmap, $istartscan, $iscanlines, $pbits, $tbi, $iusage)
	Local $aresult = DllCall("gdi32.dll", "int", "GetDIBits", "handle", $hdc, "handle", $hbitmap, "uint", $istartscan, "uint", $iscanlines, "struct*", $pbits, "struct*", $tbi, "uint", $iusage)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_getdlgctrlid($hwnd)
	Local $aresult = DllCall("user32.dll", "int", "GetDlgCtrlID", "hwnd", $hwnd)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_getdlgitem($hwnd, $iitemid)
	Local $aresult = DllCall("user32.dll", "hwnd", "GetDlgItem", "hwnd", $hwnd, "int", $iitemid)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_getfilesizeex($hfile)
	Local $aresult = DllCall("kernel32.dll", "bool", "GetFileSizeEx", "handle", $hfile, "int64*", 0)
	If @error OR NOT $aresult[0] Then Return SetError(@error, @extended, -1)
	Return $aresult[2]
EndFunc

Func _winapi_getfocus()
	Local $aresult = DllCall("user32.dll", "hwnd", "GetFocus")
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_getforegroundwindow()
	Local $aresult = DllCall("user32.dll", "hwnd", "GetForegroundWindow")
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_getguiresources($iflag = 0, $hprocess = -1)
	If $hprocess = -1 Then $hprocess = _winapi_getcurrentprocess()
	Local $aresult = DllCall("user32.dll", "dword", "GetGuiResources", "handle", $hprocess, "dword", $iflag)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_geticoninfo($hicon)
	Local $tinfo = DllStructCreate($tagiconinfo)
	Local $aret = DllCall("user32.dll", "bool", "GetIconInfo", "handle", $hicon, "struct*", $tinfo)
	If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
	Local $aicon[6]
	$aicon[0] = True
	$aicon[1] = DllStructGetData($tinfo, "Icon") <> 0
	$aicon[2] = DllStructGetData($tinfo, "XHotSpot")
	$aicon[3] = DllStructGetData($tinfo, "YHotSpot")
	$aicon[4] = DllStructGetData($tinfo, "hMask")
	$aicon[5] = DllStructGetData($tinfo, "hColor")
	Return $aicon
EndFunc

Func _winapi_getlasterrormessage()
	Local $ilasterror = _winapi_getlasterror()
	Local $tbufferptr = DllStructCreate("ptr")
	Local $ncount = _winapi_formatmessage(BitOR($format_message_allocate_buffer, $format_message_from_system), 0, $ilasterror, 0, $tbufferptr, 0, 0)
	If @error Then Return SetError(@error, 0, "")
	Local $stext = ""
	Local $pbuffer = DllStructGetData($tbufferptr, 1)
	If $pbuffer Then
		If $ncount > 0 Then
			Local $tbuffer = DllStructCreate("wchar[" & ($ncount + 1) & "]", $pbuffer)
			$stext = DllStructGetData($tbuffer, 1)
			If StringRight($stext, 2) = @CRLF Then $stext = StringTrimRight($stext, 2)
		EndIf
		_winapi_localfree($pbuffer)
	EndIf
	Return $stext
EndFunc

Func _winapi_getlayeredwindowattributes($hwnd, ByRef $itranscolor, ByRef $itransgui, $bcolorref = False)
	$itranscolor = -1
	$itransgui = -1
	Local $aresult = DllCall("user32.dll", "bool", "GetLayeredWindowAttributes", "hwnd", $hwnd, "INT*", $itranscolor, "byte*", $itransgui, "dword*", 0)
	If @error OR NOT $aresult[0] Then Return SetError(@error, @extended, 0)
	If NOT $bcolorref Then
		$aresult[2] = Int(BinaryMid($aresult[2], 3, 1) & BinaryMid($aresult[2], 2, 1) & BinaryMid($aresult[2], 1, 1))
	EndIf
	$itranscolor = $aresult[2]
	$itransgui = $aresult[3]
	Return $aresult[4]
EndFunc

Func _winapi_getmodulehandle($smodulename)
	Local $smodulenametype = "wstr"
	If $smodulename = "" Then
		$smodulename = 0
		$smodulenametype = "ptr"
	EndIf
	Local $aresult = DllCall("kernel32.dll", "handle", "GetModuleHandleW", $smodulenametype, $smodulename)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_getmousepos($btoclient = False, $hwnd = 0)
	Local $imode = Opt("MouseCoordMode", 1)
	Local $apos = MouseGetPos()
	Opt("MouseCoordMode", $imode)
	Local $tpoint = DllStructCreate($tagpoint)
	DllStructSetData($tpoint, "X", $apos[0])
	DllStructSetData($tpoint, "Y", $apos[1])
	If $btoclient AND NOT _winapi_screentoclient($hwnd, $tpoint) Then Return SetError(@error + 20, @extended, 0)
	Return $tpoint
EndFunc

Func _winapi_getmouseposx($btoclient = False, $hwnd = 0)
	Local $tpoint = _winapi_getmousepos($btoclient, $hwnd)
	If @error Then Return SetError(@error, @extended, 0)
	Return DllStructGetData($tpoint, "X")
EndFunc

Func _winapi_getmouseposy($btoclient = False, $hwnd = 0)
	Local $tpoint = _winapi_getmousepos($btoclient, $hwnd)
	If @error Then Return SetError(@error, @extended, 0)
	Return DllStructGetData($tpoint, "Y")
EndFunc

Func _winapi_getobject($hobject, $isize, $pobject)
	Local $aresult = DllCall("gdi32.dll", "int", "GetObjectW", "handle", $hobject, "int", $isize, "struct*", $pobject)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_getopenfilename($stitle = "", $sfilter = "All files (*.*)", $sinitaldir = ".", $sdefaultfile = "", $sdefaultext = "", $ifilterindex = 1, $iflags = 0, $iflagsex = 0, $hwndowner = 0)
	Local $ipathlen = 4096
	Local $inulls = 0
	Local $tofn = DllStructCreate($tagopenfilename)
	Local $afiles[1] = [0]
	Local $iflag = $iflags
	Local $asflines = StringSplit($sfilter, "|")
	Local $asfilter[$asflines[0] * 2 + 1]
	Local $istart, $ifinal, $tagfilter
	$asfilter[0] = $asflines[0] * 2
	For $i = 1 To $asflines[0]
		$istart = StringInStr($asflines[$i], "(", 0, 1)
		$ifinal = StringInStr($asflines[$i], ")", 0, -1)
		$asfilter[$i * 2 - 1] = StringStripWS(StringLeft($asflines[$i], $istart - 1), $str_stripleading + $str_striptrailing)
		$asfilter[$i * 2] = StringStripWS(StringTrimRight(StringTrimLeft($asflines[$i], $istart), StringLen($asflines[$i]) - $ifinal + 1), $str_stripleading + $str_striptrailing)
		$tagfilter &= "wchar[" & StringLen($asfilter[$i * 2 - 1]) + 1 & "];wchar[" & StringLen($asfilter[$i * 2]) + 1 & "];"
	Next
	Local $ttitle = DllStructCreate("wchar Title[" & StringLen($stitle) + 1 & "]")
	Local $tinitialdir = DllStructCreate("wchar InitDir[" & StringLen($sinitaldir) + 1 & "]")
	Local $tfilter = DllStructCreate($tagfilter & "wchar")
	Local $tpath = DllStructCreate("wchar Path[" & $ipathlen & "]")
	Local $textn = DllStructCreate("wchar Extension[" & StringLen($sdefaultext) + 1 & "]")
	For $i = 1 To $asfilter[0]
		DllStructSetData($tfilter, $i, $asfilter[$i])
	Next
	DllStructSetData($ttitle, "Title", $stitle)
	DllStructSetData($tinitialdir, "InitDir", $sinitaldir)
	DllStructSetData($tpath, "Path", $sdefaultfile)
	DllStructSetData($textn, "Extension", $sdefaultext)
	DllStructSetData($tofn, "StructSize", DllStructGetSize($tofn))
	DllStructSetData($tofn, "hwndOwner", $hwndowner)
	DllStructSetData($tofn, "lpstrFilter", DllStructGetPtr($tfilter))
	DllStructSetData($tofn, "nFilterIndex", $ifilterindex)
	DllStructSetData($tofn, "lpstrFile", DllStructGetPtr($tpath))
	DllStructSetData($tofn, "nMaxFile", $ipathlen)
	DllStructSetData($tofn, "lpstrInitialDir", DllStructGetPtr($tinitialdir))
	DllStructSetData($tofn, "lpstrTitle", DllStructGetPtr($ttitle))
	DllStructSetData($tofn, "Flags", $iflag)
	DllStructSetData($tofn, "lpstrDefExt", DllStructGetPtr($textn))
	DllStructSetData($tofn, "FlagsEx", $iflagsex)
	Local $ares = DllCall("comdlg32.dll", "bool", "GetOpenFileNameW", "struct*", $tofn)
	If @error OR NOT $ares[0] Then Return SetError(@error + 10, @extended, $afiles)
	If BitAND($iflags, $ofn_allowmultiselect) = $ofn_allowmultiselect AND BitAND($iflags, $ofn_explorer) = $ofn_explorer Then
		For $x = 1 To $ipathlen
			If DllStructGetData($tpath, "Path", $x) = Chr(0) Then
				DllStructSetData($tpath, "Path", "|", $x)
				$inulls += 1
			Else
				$inulls = 0
			EndIf
			If $inulls = 2 Then ExitLoop
		Next
		DllStructSetData($tpath, "Path", Chr(0), $x - 1)
		$afiles = StringSplit(DllStructGetData($tpath, "Path"), "|")
		If $afiles[0] = 1 Then Return __winapi_parsefiledialogpath(DllStructGetData($tpath, "Path"))
		Return StringSplit(DllStructGetData($tpath, "Path"), "|")
	ElseIf BitAND($iflags, $ofn_allowmultiselect) = $ofn_allowmultiselect Then
		$afiles = StringSplit(DllStructGetData($tpath, "Path"), " ")
		If $afiles[0] = 1 Then Return __winapi_parsefiledialogpath(DllStructGetData($tpath, "Path"))
		Return StringSplit(StringReplace(DllStructGetData($tpath, "Path"), " ", "|"), "|")
	Else
		Return __winapi_parsefiledialogpath(DllStructGetData($tpath, "Path"))
	EndIf
EndFunc

Func _winapi_getoverlappedresult($hfile, $toverlapped, ByRef $ibytes, $bwait = False)
	Local $aresult = DllCall("kernel32.dll", "bool", "GetOverlappedResult", "handle", $hfile, "struct*", $toverlapped, "dword*", 0, "bool", $bwait)
	If @error OR NOT $aresult[0] Then Return SetError(@error, @extended, False)
	$ibytes = $aresult[3]
	Return $aresult[0]
EndFunc

Func _winapi_getparent($hwnd)
	Local $aresult = DllCall("user32.dll", "hwnd", "GetParent", "hwnd", $hwnd)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_getprocaddress($hmodule, $vname)
	Local $stype = "str"
	If IsNumber($vname) Then $stype = "word"
	Local $aresult = DllCall("kernel32.dll", "ptr", "GetProcAddress", "handle", $hmodule, $stype, $vname)
	If @error OR NOT $aresult[0] Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_getprocessaffinitymask($hprocess)
	Local $aresult = DllCall("kernel32.dll", "bool", "GetProcessAffinityMask", "handle", $hprocess, "dword_ptr*", 0, "dword_ptr*", 0)
	If @error OR NOT $aresult[0] Then Return SetError(@error + 10, @extended, 0)
	Local $amask[3]
	$amask[0] = True
	$amask[1] = $aresult[2]
	$amask[2] = $aresult[3]
	Return $amask
EndFunc

Func _winapi_getsavefilename($stitle = "", $sfilter = "All files (*.*)", $sinitaldir = ".", $sdefaultfile = "", $sdefaultext = "", $ifilterindex = 1, $iflags = 0, $iflagsex = 0, $hwndowner = 0)
	Local $ipathlen = 4096
	Local $tofn = DllStructCreate($tagopenfilename)
	Local $afiles[1] = [0]
	Local $iflag = $iflags
	Local $asflines = StringSplit($sfilter, "|")
	Local $asfilter[$asflines[0] * 2 + 1]
	Local $istart, $ifinal, $tagfilter
	$asfilter[0] = $asflines[0] * 2
	For $i = 1 To $asflines[0]
		$istart = StringInStr($asflines[$i], "(", 0, 1)
		$ifinal = StringInStr($asflines[$i], ")", 0, -1)
		$asfilter[$i * 2 - 1] = StringStripWS(StringLeft($asflines[$i], $istart - 1), $str_stripleading + $str_striptrailing)
		$asfilter[$i * 2] = StringStripWS(StringTrimRight(StringTrimLeft($asflines[$i], $istart), StringLen($asflines[$i]) - $ifinal + 1), $str_stripleading + $str_striptrailing)
		$tagfilter &= "wchar[" & StringLen($asfilter[$i * 2 - 1]) + 1 & "];wchar[" & StringLen($asfilter[$i * 2]) + 1 & "];"
	Next
	Local $ttitle = DllStructCreate("wchar Title[" & StringLen($stitle) + 1 & "]")
	Local $tinitialdir = DllStructCreate("wchar InitDir[" & StringLen($sinitaldir) + 1 & "]")
	Local $tfilter = DllStructCreate($tagfilter & "wchar")
	Local $tpath = DllStructCreate("wchar Path[" & $ipathlen & "]")
	Local $textn = DllStructCreate("wchar Extension[" & StringLen($sdefaultext) + 1 & "]")
	For $i = 1 To $asfilter[0]
		DllStructSetData($tfilter, $i, $asfilter[$i])
	Next
	DllStructSetData($ttitle, "Title", $stitle)
	DllStructSetData($tinitialdir, "InitDir", $sinitaldir)
	DllStructSetData($tpath, "Path", $sdefaultfile)
	DllStructSetData($textn, "Extension", $sdefaultext)
	DllStructSetData($tofn, "StructSize", DllStructGetSize($tofn))
	DllStructSetData($tofn, "hwndOwner", $hwndowner)
	DllStructSetData($tofn, "lpstrFilter", DllStructGetPtr($tfilter))
	DllStructSetData($tofn, "nFilterIndex", $ifilterindex)
	DllStructSetData($tofn, "lpstrFile", DllStructGetPtr($tpath))
	DllStructSetData($tofn, "nMaxFile", $ipathlen)
	DllStructSetData($tofn, "lpstrInitialDir", DllStructGetPtr($tinitialdir))
	DllStructSetData($tofn, "lpstrTitle", DllStructGetPtr($ttitle))
	DllStructSetData($tofn, "Flags", $iflag)
	DllStructSetData($tofn, "lpstrDefExt", DllStructGetPtr($textn))
	DllStructSetData($tofn, "FlagsEx", $iflagsex)
	Local $ares = DllCall("comdlg32.dll", "bool", "GetSaveFileNameW", "struct*", $tofn)
	If @error OR NOT $ares[0] Then Return SetError(@error + 10, @extended, $afiles)
	Return __winapi_parsefiledialogpath(DllStructGetData($tpath, "Path"))
EndFunc

Func _winapi_getstockobject($iobject)
	Local $aresult = DllCall("gdi32.dll", "handle", "GetStockObject", "int", $iobject)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_getstdhandle($istdhandle)
	If $istdhandle < 0 OR $istdhandle > 2 Then Return SetError(2, 0, -1)
	Local Const $ahandle[3] = [-10, -11, -12]
	Local $aresult = DllCall("kernel32.dll", "handle", "GetStdHandle", "dword", $ahandle[$istdhandle])
	If @error Then Return SetError(@error, @extended, -1)
	Return $aresult[0]
EndFunc

Func _winapi_getsyscolor($iindex)
	Local $aresult = DllCall("user32.dll", "INT", "GetSysColor", "int", $iindex)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_getsyscolorbrush($iindex)
	Local $aresult = DllCall("user32.dll", "handle", "GetSysColorBrush", "int", $iindex)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_getsystemmetrics($iindex)
	Local $aresult = DllCall("user32.dll", "int", "GetSystemMetrics", "int", $iindex)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_gettextextentpoint32($hdc, $stext)
	Local $tsize = DllStructCreate($tagsize)
	Local $isize = StringLen($stext)
	Local $aret = DllCall("gdi32.dll", "bool", "GetTextExtentPoint32W", "handle", $hdc, "wstr", $stext, "int", $isize, "struct*", $tsize)
	If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
	Return $tsize
EndFunc

Func _winapi_gettextmetrics($hdc)
	Local $ttextmetric = DllStructCreate($tagtextmetric)
	Local $aret = DllCall("gdi32.dll", "bool", "GetTextMetricsW", "handle", $hdc, "struct*", $ttextmetric)
	If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
	Return $ttextmetric
EndFunc

Func _winapi_getwindow($hwnd, $icmd)
	Local $aresult = DllCall("user32.dll", "hwnd", "GetWindow", "hwnd", $hwnd, "uint", $icmd)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_getwindowdc($hwnd)
	Local $aresult = DllCall("user32.dll", "handle", "GetWindowDC", "hwnd", $hwnd)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_getwindowheight($hwnd)
	Local $trect = _winapi_getwindowrect($hwnd)
	If @error Then Return SetError(@error, @extended, 0)
	Return DllStructGetData($trect, "Bottom") - DllStructGetData($trect, "Top")
EndFunc

Func _winapi_getwindowlong($hwnd, $iindex)
	Local $sfuncname = "GetWindowLongW"
	If @AutoItX64 Then $sfuncname = "GetWindowLongPtrW"
	Local $aresult = DllCall("user32.dll", "long_ptr", $sfuncname, "hwnd", $hwnd, "int", $iindex)
	If @error OR NOT $aresult[0] Then Return SetError(@error + 10, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_getwindowplacement($hwnd)
	Local $twindowplacement = DllStructCreate($tagwindowplacement)
	DllStructSetData($twindowplacement, "length", DllStructGetSize($twindowplacement))
	Local $aret = DllCall("user32.dll", "bool", "GetWindowPlacement", "hwnd", $hwnd, "struct*", $twindowplacement)
	If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
	Return $twindowplacement
EndFunc

Func _winapi_getwindowrect($hwnd)
	Local $trect = DllStructCreate($tagrect)
	Local $aret = DllCall("user32.dll", "bool", "GetWindowRect", "hwnd", $hwnd, "struct*", $trect)
	If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
	Return $trect
EndFunc

Func _winapi_getwindowrgn($hwnd, $hrgn)
	Local $aresult = DllCall("user32.dll", "int", "GetWindowRgn", "hwnd", $hwnd, "handle", $hrgn)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_getwindowtext($hwnd)
	Local $aresult = DllCall("user32.dll", "int", "GetWindowTextW", "hwnd", $hwnd, "wstr", "", "int", 4096)
	If @error OR NOT $aresult[0] Then Return SetError(@error + 10, @extended, "")
	Return SetExtended($aresult[0], $aresult[2])
EndFunc

Func _winapi_getwindowthreadprocessid($hwnd, ByRef $ipid)
	Local $aresult = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $hwnd, "dword*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	$ipid = $aresult[2]
	Return $aresult[0]
EndFunc

Func _winapi_getwindowwidth($hwnd)
	Local $trect = _winapi_getwindowrect($hwnd)
	If @error Then Return SetError(@error, @extended, 0)
	Return DllStructGetData($trect, "Right") - DllStructGetData($trect, "Left")
EndFunc

Func _winapi_getxyfrompoint(ByRef $tpoint, ByRef $ix, ByRef $iy)
	$ix = DllStructGetData($tpoint, "X")
	$iy = DllStructGetData($tpoint, "Y")
EndFunc

Func _winapi_globalmemorystatus()
	Local $tmem = DllStructCreate($tagmemorystatusex)
	DllStructSetData($tmem, 1, DllStructGetSize($tmem))
	Local $aret = DllCall("kernel32.dll", "bool", "GlobalMemoryStatusEx", "struct*", $tmem)
	If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
	Local $amem[7]
	$amem[0] = DllStructGetData($tmem, 2)
	$amem[1] = DllStructGetData($tmem, 3)
	$amem[2] = DllStructGetData($tmem, 4)
	$amem[3] = DllStructGetData($tmem, 5)
	$amem[4] = DllStructGetData($tmem, 6)
	$amem[5] = DllStructGetData($tmem, 7)
	$amem[6] = DllStructGetData($tmem, 8)
	Return $amem
EndFunc

Func _winapi_guidfromstring($sguid)
	Local $tguid = DllStructCreate($tagguid)
	_winapi_guidfromstringex($sguid, $tguid)
	If @error Then Return SetError(@error + 10, @extended, 0)
	Return $tguid
EndFunc

Func _winapi_guidfromstringex($sguid, $tguid)
	Local $aresult = DllCall("ole32.dll", "long", "CLSIDFromString", "wstr", $sguid, "struct*", $tguid)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_hiword($ilong)
	Return BitShift($ilong, 16)
EndFunc

Func _winapi_inprocess($hwnd, ByRef $hlastwnd)
	If $hwnd = $hlastwnd Then Return True
	For $ii = $__g_ainprocess_winapi[0][0] To 1 Step -1
		If $hwnd = $__g_ainprocess_winapi[$ii][0] Then
			If $__g_ainprocess_winapi[$ii][1] Then
				$hlastwnd = $hwnd
				Return True
			Else
				Return False
			EndIf
		EndIf
	Next
	Local $ipid
	_winapi_getwindowthreadprocessid($hwnd, $ipid)
	Local $icount = $__g_ainprocess_winapi[0][0] + 1
	If $icount >= 64 Then $icount = 1
	$__g_ainprocess_winapi[0][0] = $icount
	$__g_ainprocess_winapi[$icount][0] = $hwnd
	$__g_ainprocess_winapi[$icount][1] = ($ipid = @AutoItPID)
	Return $__g_ainprocess_winapi[$icount][1]
EndFunc

Func _winapi_inttofloat($iint)
	Local $tint = DllStructCreate("int")
	Local $tfloat = DllStructCreate("float", DllStructGetPtr($tint))
	DllStructSetData($tint, 1, $iint)
	Return DllStructGetData($tfloat, 1)
EndFunc

Func _winapi_isclassname($hwnd, $sclassname)
	Local $sseparator = Opt("GUIDataSeparatorChar")
	Local $aclassname = StringSplit($sclassname, $sseparator)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Local $sclasscheck = _winapi_getclassname($hwnd)
	For $x = 1 To UBound($aclassname) - 1
		If StringUpper(StringMid($sclasscheck, 1, StringLen($aclassname[$x]))) = StringUpper($aclassname[$x]) Then Return True
	Next
	Return False
EndFunc

Func _winapi_iswindow($hwnd)
	Local $aresult = DllCall("user32.dll", "bool", "IsWindow", "hwnd", $hwnd)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_iswindowvisible($hwnd)
	Local $aresult = DllCall("user32.dll", "bool", "IsWindowVisible", "hwnd", $hwnd)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_invalidaterect($hwnd, $trect = 0, $berase = True)
	Local $aresult = DllCall("user32.dll", "bool", "InvalidateRect", "hwnd", $hwnd, "struct*", $trect, "bool", $berase)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_lineto($hdc, $ix, $iy)
	Local $aresult = DllCall("gdi32.dll", "bool", "LineTo", "handle", $hdc, "int", $ix, "int", $iy)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_loadbitmap($hinstance, $sbitmap)
	Local $sbitmaptype = "int"
	If IsString($sbitmap) Then $sbitmaptype = "wstr"
	Local $aresult = DllCall("user32.dll", "handle", "LoadBitmapW", "handle", $hinstance, $sbitmaptype, $sbitmap)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_loadimage($hinstance, $simage, $itype, $ixdesired, $iydesired, $iload)
	Local $aresult, $simagetype = "int"
	If IsString($simage) Then $simagetype = "wstr"
	$aresult = DllCall("user32.dll", "handle", "LoadImageW", "handle", $hinstance, $simagetype, $simage, "uint", $itype, "int", $ixdesired, "int", $iydesired, "uint", $iload)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_loadlibrary($sfilename)
	Local $aresult = DllCall("kernel32.dll", "handle", "LoadLibraryW", "wstr", $sfilename)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_loadlibraryex($sfilename, $iflags = 0)
	Local $aresult = DllCall("kernel32.dll", "handle", "LoadLibraryExW", "wstr", $sfilename, "ptr", 0, "dword", $iflags)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_loadshell32icon($iiconid)
	Local $ticons = DllStructCreate("ptr Data")
	Local $iicons = _winapi_extracticonex("shell32.dll", $iiconid, 0, $ticons, 1)
	If @error Then Return SetError(@error, @extended, 0)
	If $iicons <= 0 Then Return SetError(10, 0, 0)
	Return DllStructGetData($ticons, "Data")
EndFunc

Func _winapi_loadstring($hinstance, $istringid)
	Local $aresult = DllCall("user32.dll", "int", "LoadStringW", "handle", $hinstance, "uint", $istringid, "wstr", "", "int", 4096)
	If @error OR NOT $aresult[0] Then Return SetError(@error + 10, @extended, "")
	Return SetExtended($aresult[0], $aresult[3])
EndFunc

Func _winapi_localfree($hmemory)
	Local $aresult = DllCall("kernel32.dll", "handle", "LocalFree", "handle", $hmemory)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_loword($ilong)
	Return BitAND($ilong, 65535)
EndFunc

Func _winapi_makelangid($ilngidprimary, $ilngidsub)
	Return BitOR(BitShift($ilngidsub, -10), $ilngidprimary)
EndFunc

Func _winapi_makelcid($ilngid, $isortid)
	Return BitOR(BitShift($isortid, -16), $ilngid)
EndFunc

Func _winapi_makelong($ilo, $ihi)
	Return BitOR(BitShift($ihi, -16), BitAND($ilo, 65535))
EndFunc

Func _winapi_makeqword($ilodword, $ihidword)
	Local $tint64 = DllStructCreate("uint64")
	Local $tdwords = DllStructCreate("dword;dword", DllStructGetPtr($tint64))
	DllStructSetData($tdwords, 1, $ilodword)
	DllStructSetData($tdwords, 2, $ihidword)
	Return DllStructGetData($tint64, 1)
EndFunc

Func _winapi_messagebeep($itype = 1)
	Local $isound
	Switch $itype
		Case 1
			$isound = 0
		Case 2
			$isound = 16
		Case 3
			$isound = 32
		Case 4
			$isound = 48
		Case 5
			$isound = 64
		Case Else
			$isound = -1
	EndSwitch
	Local $aresult = DllCall("user32.dll", "bool", "MessageBeep", "uint", $isound)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_msgbox($iflags, $stitle, $stext)
	BlockInput(0)
	MsgBox($iflags, $stitle, $stext & "      ")
EndFunc

Func _winapi_mouse_event($iflags, $ix = 0, $iy = 0, $idata = 0, $iextrainfo = 0)
	DllCall("user32.dll", "none", "mouse_event", "dword", $iflags, "dword", $ix, "dword", $iy, "dword", $idata, "ulong_ptr", $iextrainfo)
	If @error Then Return SetError(@error, @extended)
EndFunc

Func _winapi_moveto($hdc, $ix, $iy)
	Local $aresult = DllCall("gdi32.dll", "bool", "MoveToEx", "handle", $hdc, "int", $ix, "int", $iy, "ptr", 0)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_movewindow($hwnd, $ix, $iy, $iwidth, $iheight, $brepaint = True)
	Local $aresult = DllCall("user32.dll", "bool", "MoveWindow", "hwnd", $hwnd, "int", $ix, "int", $iy, "int", $iwidth, "int", $iheight, "bool", $brepaint)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_muldiv($inumber, $inumerator, $idenominator)
	Local $aresult = DllCall("kernel32.dll", "int", "MulDiv", "int", $inumber, "int", $inumerator, "int", $idenominator)
	If @error Then Return SetError(@error, @extended, -1)
	Return $aresult[0]
EndFunc

Func _winapi_multibytetowidechar($vtext, $icodepage = 0, $iflags = 0, $bretstring = False)
	Local $stexttype = "str"
	If NOT IsString($vtext) Then $stexttype = "struct*"
	Local $aresult = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", $icodepage, "dword", $iflags, $stexttype, $vtext, "int", -1, "ptr", 0, "int", 0)
	If @error OR NOT $aresult[0] Then Return SetError(@error + 10, @extended, 0)
	Local $iout = $aresult[0]
	Local $tout = DllStructCreate("wchar[" & $iout & "]")
	$aresult = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", $icodepage, "dword", $iflags, $stexttype, $vtext, "int", -1, "struct*", $tout, "int", $iout)
	If @error OR NOT $aresult[0] Then Return SetError(@error + 20, @extended, 0)
	If $bretstring Then Return DllStructGetData($tout, 1)
	Return $tout
EndFunc

Func _winapi_multibytetowidecharex($stext, $ptext, $icodepage = 0, $iflags = 0)
	Local $aresult = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", $icodepage, "dword", $iflags, "STR", $stext, "int", -1, "struct*", $ptext, "int", (StringLen($stext) + 1) * 2)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_openprocess($iaccess, $binherit, $ipid, $bdebugpriv = False)
	Local $aresult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iaccess, "bool", $binherit, "dword", $ipid)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return $aresult[0]
	If NOT $bdebugpriv Then Return SetError(100, 0, 0)
	Local $htoken = _security__openthreadtokenex(BitOR($token_adjust_privileges, $token_query))
	If @error Then Return SetError(@error + 10, @extended, 0)
	_security__setprivilege($htoken, "SeDebugPrivilege", True)
	Local $ierror = @error
	Local $iextended = @extended
	Local $iret = 0
	If NOT @error Then
		$aresult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iaccess, "bool", $binherit, "dword", $ipid)
		$ierror = @error
		$iextended = @extended
		If $aresult[0] Then $iret = $aresult[0]
		_security__setprivilege($htoken, "SeDebugPrivilege", False)
		If @error Then
			$ierror = @error + 20
			$iextended = @extended
		EndIf
	Else
		$ierror = @error + 30
	EndIf
	_winapi_closehandle($htoken)
	Return SetError($ierror, $iextended, $iret)
EndFunc

Func __winapi_parsefiledialogpath($spath)
	Local $afiles[3]
	$afiles[0] = 2
	Local $stemp = StringMid($spath, 1, StringInStr($spath, "\", 0, -1) - 1)
	$afiles[1] = $stemp
	$afiles[2] = StringMid($spath, StringInStr($spath, "\", 0, -1) + 1)
	Return $afiles
EndFunc

Func _winapi_pathfindonpath(Const $sfilepath, $aextrapaths = "", Const $spathdelimiter = @LF)
	Local $iextracount = 0
	If IsString($aextrapaths) Then
		If StringLen($aextrapaths) Then
			$aextrapaths = StringSplit($aextrapaths, $spathdelimiter, $str_entiresplit + $str_nocount)
			$iextracount = UBound($aextrapaths, $ubound_rows)
		EndIf
	ElseIf IsArray($aextrapaths) Then
		$iextracount = UBound($aextrapaths)
	EndIf
	Local $tpaths, $tpathptrs
	If $iextracount Then
		Local $tagstruct = ""
		For $path In $aextrapaths
			$tagstruct &= "wchar[" & StringLen($path) + 1 & "];"
		Next
		$tpaths = DllStructCreate($tagstruct)
		$tpathptrs = DllStructCreate("ptr[" & $iextracount + 1 & "]")
		For $i = 1 To $iextracount
			DllStructSetData($tpaths, $i, $aextrapaths[$i - 1])
			DllStructSetData($tpathptrs, 1, DllStructGetPtr($tpaths, $i), $i)
		Next
		DllStructSetData($tpathptrs, 1, Ptr(0), $iextracount + 1)
	EndIf
	Local $aresult = DllCall("shlwapi.dll", "bool", "PathFindOnPathW", "wstr", $sfilepath, "struct*", $tpathptrs)
	If @error OR NOT $aresult[0] Then Return SetError(@error + 10, @extended, $sfilepath)
	Return $aresult[1]
EndFunc

Func _winapi_pointfromrect(ByRef $trect, $bcenter = True)
	Local $ix1 = DllStructGetData($trect, "Left")
	Local $iy1 = DllStructGetData($trect, "Top")
	Local $ix2 = DllStructGetData($trect, "Right")
	Local $iy2 = DllStructGetData($trect, "Bottom")
	If $bcenter Then
		$ix1 = $ix1 + (($ix2 - $ix1) / 2)
		$iy1 = $iy1 + (($iy2 - $iy1) / 2)
	EndIf
	Local $tpoint = DllStructCreate($tagpoint)
	DllStructSetData($tpoint, "X", $ix1)
	DllStructSetData($tpoint, "Y", $iy1)
	Return $tpoint
EndFunc

Func _winapi_postmessage($hwnd, $imsg, $wparam, $lparam)
	Local $aresult = DllCall("user32.dll", "bool", "PostMessage", "hwnd", $hwnd, "uint", $imsg, "wparam", $wparam, "lparam", $lparam)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_primarylangid($ilngid)
	Return BitAND($ilngid, 1023)
EndFunc

Func _winapi_ptinrect(ByRef $trect, ByRef $tpoint)
	Local $aresult = DllCall("user32.dll", "bool", "PtInRect", "struct*", $trect, "struct", $tpoint)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_readfile($hfile, $pbuffer, $itoread, ByRef $iread, $toverlapped = 0)
	Local $aresult = DllCall("kernel32.dll", "bool", "ReadFile", "handle", $hfile, "struct*", $pbuffer, "dword", $itoread, "dword*", 0, "struct*", $toverlapped)
	If @error Then Return SetError(@error, @extended, False)
	$iread = $aresult[4]
	Return $aresult[0]
EndFunc

Func _winapi_readprocessmemory($hprocess, $pbaseaddress, $pbuffer, $isize, ByRef $iread)
	Local $aresult = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $hprocess, "ptr", $pbaseaddress, "struct*", $pbuffer, "ulong_ptr", $isize, "ulong_ptr*", 0)
	If @error Then Return SetError(@error, @extended, False)
	$iread = $aresult[5]
	Return $aresult[0]
EndFunc

Func _winapi_rectisempty(ByRef $trect)
	Return (DllStructGetData($trect, "Left") = 0) AND (DllStructGetData($trect, "Top") = 0) AND (DllStructGetData($trect, "Right") = 0) AND (DllStructGetData($trect, "Bottom") = 0)
EndFunc

Func _winapi_redrawwindow($hwnd, $trect = 0, $hregion = 0, $iflags = 5)
	Local $aresult = DllCall("user32.dll", "bool", "RedrawWindow", "hwnd", $hwnd, "struct*", $trect, "handle", $hregion, "uint", $iflags)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_registerwindowmessage($smessage)
	Local $aresult = DllCall("user32.dll", "uint", "RegisterWindowMessageW", "wstr", $smessage)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_releasecapture()
	Local $aresult = DllCall("user32.dll", "bool", "ReleaseCapture")
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_releasedc($hwnd, $hdc)
	Local $aresult = DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hwnd, "handle", $hdc)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_screentoclient($hwnd, ByRef $tpoint)
	Local $aresult = DllCall("user32.dll", "bool", "ScreenToClient", "hwnd", $hwnd, "struct*", $tpoint)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_selectobject($hdc, $hgdiobj)
	Local $aresult = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdc, "handle", $hgdiobj)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_setbkcolor($hdc, $icolor)
	Local $aresult = DllCall("gdi32.dll", "INT", "SetBkColor", "handle", $hdc, "INT", $icolor)
	If @error Then Return SetError(@error, @extended, -1)
	Return $aresult[0]
EndFunc

Func _winapi_setbkmode($hdc, $ibkmode)
	Local $aresult = DllCall("gdi32.dll", "int", "SetBkMode", "handle", $hdc, "int", $ibkmode)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_setcapture($hwnd)
	Local $aresult = DllCall("user32.dll", "hwnd", "SetCapture", "hwnd", $hwnd)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_setcursor($hcursor)
	Local $aresult = DllCall("user32.dll", "handle", "SetCursor", "handle", $hcursor)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_setdefaultprinter($sprinter)
	Local $aresult = DllCall("winspool.drv", "bool", "SetDefaultPrinterW", "wstr", $sprinter)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_setdibits($hdc, $hbitmap, $istartscan, $iscanlines, $pbits, $tbmi, $icoloruse = 0)
	Local $aresult = DllCall("gdi32.dll", "int", "SetDIBits", "handle", $hdc, "handle", $hbitmap, "uint", $istartscan, "uint", $iscanlines, "struct*", $pbits, "struct*", $tbmi, "INT", $icoloruse)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_setendoffile($hfile)
	Local $aresult = DllCall("kernel32.dll", "bool", "SetEndOfFile", "handle", $hfile)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_setevent($hevent)
	Local $aresult = DllCall("kernel32.dll", "bool", "SetEvent", "handle", $hevent)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_setfilepointer($hfile, $ipos, $imethod = 0)
	Local $aresult = DllCall("kernel32.dll", "INT", "SetFilePointer", "handle", $hfile, "long", $ipos, "ptr", 0, "long", $imethod)
	If @error Then Return SetError(@error, @extended, -1)
	Return $aresult[0]
EndFunc

Func _winapi_setfocus($hwnd)
	Local $aresult = DllCall("user32.dll", "hwnd", "SetFocus", "hwnd", $hwnd)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_setfont($hwnd, $hfont, $bredraw = True)
	_sendmessage($hwnd, $__winapiconstant_wm_setfont, $hfont, $bredraw, 0, "hwnd")
EndFunc

Func _winapi_sethandleinformation($hobject, $imask, $iflags)
	Local $aresult = DllCall("kernel32.dll", "bool", "SetHandleInformation", "handle", $hobject, "dword", $imask, "dword", $iflags)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_setlayeredwindowattributes($hwnd, $itranscolor, $itransgui = 255, $iflags = 3, $bcolorref = False)
	If $iflags = Default OR $iflags = "" OR $iflags < 0 Then $iflags = 3
	If NOT $bcolorref Then
		$itranscolor = Int(BinaryMid($itranscolor, 3, 1) & BinaryMid($itranscolor, 2, 1) & BinaryMid($itranscolor, 1, 1))
	EndIf
	Local $aresult = DllCall("user32.dll", "bool", "SetLayeredWindowAttributes", "hwnd", $hwnd, "INT", $itranscolor, "byte", $itransgui, "dword", $iflags)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_setparent($hwndchild, $hwndparent)
	Local $aresult = DllCall("user32.dll", "hwnd", "SetParent", "hwnd", $hwndchild, "hwnd", $hwndparent)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_setprocessaffinitymask($hprocess, $imask)
	Local $aresult = DllCall("kernel32.dll", "bool", "SetProcessAffinityMask", "handle", $hprocess, "ulong_ptr", $imask)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_setsyscolors($velements, $vcolors)
	Local $bisearray = IsArray($velements), $biscarray = IsArray($vcolors)
	Local $ielementnum
	If NOT $biscarray AND NOT $bisearray Then
		$ielementnum = 1
	ElseIf $biscarray OR $bisearray Then
		If NOT $biscarray OR NOT $bisearray Then Return SetError(-1, -1, False)
		If UBound($velements) <> UBound($vcolors) Then Return SetError(-1, -1, False)
		$ielementnum = UBound($velements)
	EndIf
	Local $telements = DllStructCreate("int Element[" & $ielementnum & "]")
	Local $tcolors = DllStructCreate("INT NewColor[" & $ielementnum & "]")
	If NOT $bisearray Then
		DllStructSetData($telements, "Element", $velements, 1)
	Else
		For $x = 0 To $ielementnum - 1
			DllStructSetData($telements, "Element", $velements[$x], $x + 1)
		Next
	EndIf
	If NOT $biscarray Then
		DllStructSetData($tcolors, "NewColor", $vcolors, 1)
	Else
		For $x = 0 To $ielementnum - 1
			DllStructSetData($tcolors, "NewColor", $vcolors[$x], $x + 1)
		Next
	EndIf
	Local $aresult = DllCall("user32.dll", "bool", "SetSysColors", "int", $ielementnum, "struct*", $telements, "struct*", $tcolors)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_settextcolor($hdc, $icolor)
	Local $aresult = DllCall("gdi32.dll", "INT", "SetTextColor", "handle", $hdc, "INT", $icolor)
	If @error Then Return SetError(@error, @extended, -1)
	Return $aresult[0]
EndFunc

Func _winapi_setwindowlong($hwnd, $iindex, $ivalue)
	_winapi_setlasterror(0)
	Local $sfuncname = "SetWindowLongW"
	If @AutoItX64 Then $sfuncname = "SetWindowLongPtrW"
	Local $aresult = DllCall("user32.dll", "long_ptr", $sfuncname, "hwnd", $hwnd, "int", $iindex, "long_ptr", $ivalue)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_setwindowplacement($hwnd, $twindowplacement)
	Local $aresult = DllCall("user32.dll", "bool", "SetWindowPlacement", "hwnd", $hwnd, "struct*", $twindowplacement)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_setwindowpos($hwnd, $hafter, $ix, $iy, $icx, $icy, $iflags)
	Local $aresult = DllCall("user32.dll", "bool", "SetWindowPos", "hwnd", $hwnd, "hwnd", $hafter, "int", $ix, "int", $iy, "int", $icx, "int", $icy, "uint", $iflags)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_setwindowrgn($hwnd, $hrgn, $bredraw = True)
	Local $aresult = DllCall("user32.dll", "int", "SetWindowRgn", "hwnd", $hwnd, "handle", $hrgn, "bool", $bredraw)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_setwindowshookex($ihook, $pproc, $hdll, $ithreadid = 0)
	Local $aresult = DllCall("user32.dll", "handle", "SetWindowsHookEx", "int", $ihook, "ptr", $pproc, "handle", $hdll, "dword", $ithreadid)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_setwindowtext($hwnd, $stext)
	Local $aresult = DllCall("user32.dll", "bool", "SetWindowTextW", "hwnd", $hwnd, "wstr", $stext)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_showcursor($bshow)
	Local $aresult = DllCall("user32.dll", "int", "ShowCursor", "bool", $bshow)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_showerror($stext, $bexit = True)
	_winapi_msgbox($mb_systemmodal, "Error", $stext)
	If $bexit Then Exit
EndFunc

Func _winapi_showmsg($stext)
	_winapi_msgbox($mb_systemmodal, "Information", $stext)
EndFunc

Func _winapi_showwindow($hwnd, $icmdshow = 5)
	Local $aresult = DllCall("user32.dll", "bool", "ShowWindow", "hwnd", $hwnd, "int", $icmdshow)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_stringfromguid($tguid)
	Local $aresult = DllCall("ole32.dll", "int", "StringFromGUID2", "struct*", $tguid, "wstr", "", "int", 40)
	If @error OR NOT $aresult[0] Then Return SetError(@error, @extended, "")
	Return SetExtended($aresult[0], $aresult[2])
EndFunc

Func _winapi_stringlena(Const ByRef $tstring)
	Local $aresult = DllCall("kernel32.dll", "int", "lstrlenA", "struct*", $tstring)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_stringlenw(Const ByRef $tstring)
	Local $aresult = DllCall("kernel32.dll", "int", "lstrlenW", "struct*", $tstring)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_sublangid($ilngid)
	Return BitShift($ilngid, 10)
EndFunc

Func _winapi_systemparametersinfo($iaction, $iparam = 0, $vparam = 0, $iwinini = 0)
	Local $aresult = DllCall("user32.dll", "bool", "SystemParametersInfoW", "uint", $iaction, "uint", $iparam, "struct*", $vparam, "uint", $iwinini)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_twipsperpixelx()
	Local $hdc, $itwipsperpixelx
	$hdc = _winapi_getdc(0)
	$itwipsperpixelx = 1440 / _winapi_getdevicecaps($hdc, $__winapiconstant_logpixelsx)
	_winapi_releasedc(0, $hdc)
	Return $itwipsperpixelx
EndFunc

Func _winapi_twipsperpixely()
	Local $hdc, $itwipsperpixely
	$hdc = _winapi_getdc(0)
	$itwipsperpixely = 1440 / _winapi_getdevicecaps($hdc, $__winapiconstant_logpixelsy)
	_winapi_releasedc(0, $hdc)
	Return $itwipsperpixely
EndFunc

Func _winapi_unhookwindowshookex($hhook)
	Local $aresult = DllCall("user32.dll", "bool", "UnhookWindowsHookEx", "handle", $hhook)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_updatelayeredwindow($hwnd, $hdestdc, $tptdest, $tsize, $hsrcdc, $tptsrce, $irgb, $tblend, $iflags)
	Local $aresult = DllCall("user32.dll", "bool", "UpdateLayeredWindow", "hwnd", $hwnd, "handle", $hdestdc, "struct*", $tptdest, "struct*", $tsize, "handle", $hsrcdc, "struct*", $tptsrce, "dword", $irgb, "struct*", $tblend, "dword", $iflags)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_updatewindow($hwnd)
	Local $aresult = DllCall("user32.dll", "bool", "UpdateWindow", "hwnd", $hwnd)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_waitforinputidle($hprocess, $itimeout = -1)
	Local $aresult = DllCall("user32.dll", "dword", "WaitForInputIdle", "handle", $hprocess, "dword", $itimeout)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_waitformultipleobjects($icount, $pahandles, $bwaitall = False, $itimeout = -1)
	Local $aresult = DllCall("kernel32.dll", "INT", "WaitForMultipleObjects", "dword", $icount, "struct*", $pahandles, "bool", $bwaitall, "dword", $itimeout)
	If @error Then Return SetError(@error, @extended, -1)
	Return $aresult[0]
EndFunc

Func _winapi_waitforsingleobject($hhandle, $itimeout = -1)
	Local $aresult = DllCall("kernel32.dll", "INT", "WaitForSingleObject", "handle", $hhandle, "dword", $itimeout)
	If @error Then Return SetError(@error, @extended, -1)
	Return $aresult[0]
EndFunc

Func _winapi_widechartomultibyte($vunicode, $icodepage = 0, $bretstring = True)
	Local $sunicodetype = "wstr"
	If NOT IsString($vunicode) Then $sunicodetype = "struct*"
	Local $aresult = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", $icodepage, "dword", 0, $sunicodetype, $vunicode, "int", -1, "ptr", 0, "int", 0, "ptr", 0, "ptr", 0)
	If @error OR NOT $aresult[0] Then Return SetError(@error + 20, @extended, "")
	Local $tmultibyte = DllStructCreate("char[" & $aresult[0] & "]")
	$aresult = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", $icodepage, "dword", 0, $sunicodetype, $vunicode, "int", -1, "struct*", $tmultibyte, "int", $aresult[0], "ptr", 0, "ptr", 0)
	If @error OR NOT $aresult[0] Then Return SetError(@error + 10, @extended, "")
	If $bretstring Then Return DllStructGetData($tmultibyte, 1)
	Return $tmultibyte
EndFunc

Func _winapi_windowfrompoint(ByRef $tpoint)
	Local $aresult = DllCall("user32.dll", "hwnd", "WindowFromPoint", "struct", $tpoint)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _winapi_writeconsole($hconsole, $stext)
	Local $aresult = DllCall("kernel32.dll", "bool", "WriteConsoleW", "handle", $hconsole, "wstr", $stext, "dword", StringLen($stext), "dword*", 0, "ptr", 0)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _winapi_writefile($hfile, $pbuffer, $itowrite, ByRef $iwritten, $toverlapped = 0)
	Local $aresult = DllCall("kernel32.dll", "bool", "WriteFile", "handle", $hfile, "struct*", $pbuffer, "dword", $itowrite, "dword*", 0, "struct*", $toverlapped)
	If @error Then Return SetError(@error, @extended, False)
	$iwritten = $aresult[4]
	Return $aresult[0]
EndFunc

Func _winapi_writeprocessmemory($hprocess, $pbaseaddress, $pbuffer, $isize, ByRef $iwritten, $sbuffer = "ptr")
	Local $aresult = DllCall("kernel32.dll", "bool", "WriteProcessMemory", "handle", $hprocess, "ptr", $pbaseaddress, $sbuffer, $pbuffer, "ulong_ptr", $isize, "ulong_ptr*", 0)
	If @error Then Return SetError(@error, @extended, False)
	$iwritten = $aresult[5]
	Return $aresult[0]
EndFunc

Global Const $fr_private = 16
Global Const $fr_not_enum = 32
Global Const $compression_bitmap_png = 0
Global Const $compression_bitmap_jpeg = 1
Global Const $bs_dibpattern = 5
Global Const $bs_dibpattern8x8 = 8
Global Const $bs_dibpatternpt = 6
Global Const $bs_hatched = 2
Global Const $bs_hollow = 1
Global Const $bs_null = 1
Global Const $bs_pattern = 3
Global Const $bs_pattern8x8 = 7
Global Const $bs_solid = 0
Global Const $hs_bdiagonal = 3
Global Const $hs_cross = 4
Global Const $hs_diagcross = 5
Global Const $hs_fdiagonal = 2
Global Const $hs_horizontal = 0
Global Const $hs_vertical = 1
Global Const $dib_pal_colors = 1
Global Const $dib_rgb_colors = 0
Global Const $ca_negative = 1
Global Const $ca_log_filter = 2
Global Const $illuminant_device_default = 0
Global Const $illuminant_a = 1
Global Const $illuminant_b = 2
Global Const $illuminant_c = 3
Global Const $illuminant_d50 = 4
Global Const $illuminant_d55 = 5
Global Const $illuminant_d65 = 6
Global Const $illuminant_d75 = 7
Global Const $illuminant_f2 = 8
Global Const $illuminant_tungsten = $illuminant_a
Global Const $illuminant_daylight = $illuminant_c
Global Const $illuminant_fluorescent = $illuminant_f2
Global Const $illuminant_ntsc = $illuminant_c
Global Const $bi_rgb = 0
Global Const $bi_rle8 = 1
Global Const $bi_rle4 = 2
Global Const $bi_bitfields = 3
Global Const $bi_jpeg = 4
Global Const $bi_png = 5
Global Const $alternate = 1
Global Const $winding = 2
Global Const $dwmwa_ncrendering_enabled = 1
Global Const $dwmwa_ncrendering_policy = 2
Global Const $dwmwa_transitions_forcedisabled = 3
Global Const $dwmwa_allow_ncpaint = 4
Global Const $dwmwa_caption_button_bounds = 5
Global Const $dwmwa_nonclient_rtl_layout = 6
Global Const $dwmwa_force_iconic_representation = 7
Global Const $dwmwa_flip3d_policy = 8
Global Const $dwmwa_extended_frame_bounds = 9
Global Const $dwmwa_has_iconic_bitmap = 10
Global Const $dwmwa_disallow_peek = 11
Global Const $dwmwa_excluded_from_peek = 12
Global Const $dwmncrp_usewindowstyle = 0
Global Const $dwmncrp_disabled = 1
Global Const $dwmncrp_enabled = 2
Global Const $dwmflip3d_default = 0
Global Const $dwmflip3d_excludebelow = 1
Global Const $dwmflip3d_excludeabove = 2
Global Const $dm_bitsperpel = 262144
Global Const $dm_collate = 32768
Global Const $dm_color = 2048
Global Const $dm_copies = 256
Global Const $dm_defaultsource = 512
Global Const $dm_displayfixedoutput = 536870912
Global Const $dm_displayflags = 2097152
Global Const $dm_displayfrequency = 4194304
Global Const $dm_displayorientation = 128
Global Const $dm_dithertype = 67108864
Global Const $dm_duplex = 4096
Global Const $dm_formname = 65536
Global Const $dm_icmintent = 16777216
Global Const $dm_icmmethod = 8388608
Global Const $dm_logpixels = 131072
Global Const $dm_mediatype = 33554432
Global Const $dm_nup = 64
Global Const $dm_orientation = 1
Global Const $dm_panningheight = 268435456
Global Const $dm_panningwidth = 134217728
Global Const $dm_paperlength = 4
Global Const $dm_papersize = 2
Global Const $dm_paperwidth = 8
Global Const $dm_pelsheight = 1048576
Global Const $dm_pelswidth = 524288
Global Const $dm_position = 32
Global Const $dm_printquality = 1024
Global Const $dm_scale = 16
Global Const $dm_ttoption = 16384
Global Const $dm_yresolution = 8192
Global Const $dmpaper_letter = 1
Global Const $dmpaper_lettersmall = 2
Global Const $dmpaper_tabloid = 3
Global Const $dmpaper_ledger = 4
Global Const $dmpaper_legal = 5
Global Const $dmpaper_statement = 6
Global Const $dmpaper_executive = 7
Global Const $dmpaper_a3 = 8
Global Const $dmpaper_a4 = 9
Global Const $dmpaper_a4small = 10
Global Const $dmpaper_a5 = 11
Global Const $dmpaper_b4 = 12
Global Const $dmpaper_b5 = 13
Global Const $dmpaper_folio = 14
Global Const $dmpaper_quarto = 15
Global Const $dmpaper_10x14 = 16
Global Const $dmpaper_11x17 = 17
Global Const $dmpaper_note = 18
Global Const $dmpaper_env_9 = 19
Global Const $dmpaper_env_10 = 20
Global Const $dmpaper_env_11 = 21
Global Const $dmpaper_env_12 = 22
Global Const $dmpaper_env_14 = 23
Global Const $dmpaper_csheet = 24
Global Const $dmpaper_dsheet = 25
Global Const $dmpaper_esheet = 26
Global Const $dmpaper_env_dl = 27
Global Const $dmpaper_env_c5 = 28
Global Const $dmpaper_env_c3 = 29
Global Const $dmpaper_env_c4 = 30
Global Const $dmpaper_env_c6 = 31
Global Const $dmpaper_env_c65 = 32
Global Const $dmpaper_env_b4 = 33
Global Const $dmpaper_env_b5 = 34
Global Const $dmpaper_env_b6 = 35
Global Const $dmpaper_env_italy = 36
Global Const $dmpaper_env_monarch = 37
Global Const $dmpaper_env_personal = 38
Global Const $dmpaper_fanfold_us = 39
Global Const $dmpaper_fanfold_std_german = 40
Global Const $dmpaper_fanfold_lgl_german = 41
Global Const $dmpaper_iso_b4 = 42
Global Const $dmpaper_japanese_postcard = 43
Global Const $dmpaper_9x11 = 44
Global Const $dmpaper_10x11 = 45
Global Const $dmpaper_15x11 = 46
Global Const $dmpaper_env_invite = 47
Global Const $dmpaper_reserved_48 = 48
Global Const $dmpaper_reserved_49 = 49
Global Const $dmpaper_letter_extra = 50
Global Const $dmpaper_legal_extra = 51
Global Const $dmpaper_tabloid_extra = 52
Global Const $dmpaper_a4_extra = 53
Global Const $dmpaper_letter_transverse = 54
Global Const $dmpaper_a4_transverse = 55
Global Const $dmpaper_letter_extra_transverse = 56
Global Const $dmpaper_a_plus = 57
Global Const $dmpaper_b_plus = 58
Global Const $dmpaper_letter_plus = 59
Global Const $dmpaper_a4_plus = 60
Global Const $dmpaper_a5_transverse = 61
Global Const $dmpaper_b5_transverse = 62
Global Const $dmpaper_a3_extra = 63
Global Const $dmpaper_a5_extra = 64
Global Const $dmpaper_b5_extra = 65
Global Const $dmpaper_a2 = 66
Global Const $dmpaper_a3_transverse = 67
Global Const $dmpaper_a3_extra_transverse = 68
Global Const $dmpaper_dbl_japanese_postcard = 69
Global Const $dmpaper_a6 = 70
Global Const $dmpaper_jenv_kaku2 = 71
Global Const $dmpaper_jenv_kaku3 = 72
Global Const $dmpaper_jenv_chou3 = 73
Global Const $dmpaper_jenv_chou4 = 74
Global Const $dmpaper_letter_rotated = 75
Global Const $dmpaper_a3_rotated = 76
Global Const $dmpaper_a4_rotated = 77
Global Const $dmpaper_a5_rotated = 78
Global Const $dmpaper_b4_jis_rotated = 79
Global Const $dmpaper_b5_jis_rotated = 80
Global Const $dmpaper_japanese_postcard_rotated = 81
Global Const $dmpaper_dbl_japanese_postcard_rotated = 82
Global Const $dmpaper_a6_rotated = 83
Global Const $dmpaper_jenv_kaku2_rotated = 84
Global Const $dmpaper_jenv_kaku3_rotated = 85
Global Const $dmpaper_jenv_chou3_rotated = 86
Global Const $dmpaper_jenv_chou4_rotated = 87
Global Const $dmpaper_b6_jis = 88
Global Const $dmpaper_b6_jis_rotated = 89
Global Const $dmpaper_12x11 = 90
Global Const $dmpaper_jenv_you4 = 91
Global Const $dmpaper_jenv_you4_rotated = 92
Global Const $dmpaper_p16k = 93
Global Const $dmpaper_p32k = 94
Global Const $dmpaper_p32kbig = 95
Global Const $dmpaper_penv_1 = 96
Global Const $dmpaper_penv_2 = 97
Global Const $dmpaper_penv_3 = 98
Global Const $dmpaper_penv_4 = 99
Global Const $dmpaper_penv_5 = 100
Global Const $dmpaper_penv_6 = 101
Global Const $dmpaper_penv_7 = 102
Global Const $dmpaper_penv_8 = 103
Global Const $dmpaper_penv_9 = 104
Global Const $dmpaper_penv_10 = 105
Global Const $dmpaper_p16k_rotated = 106
Global Const $dmpaper_p32k_rotated = 107
Global Const $dmpaper_p32kbig_rotated = 108
Global Const $dmpaper_penv_1_rotated = 109
Global Const $dmpaper_penv_2_rotated = 110
Global Const $dmpaper_penv_3_rotated = 111
Global Const $dmpaper_penv_4_rotated = 112
Global Const $dmpaper_penv_5_rotated = 113
Global Const $dmpaper_penv_6_rotated = 114
Global Const $dmpaper_penv_7_rotated = 115
Global Const $dmpaper_penv_8_rotated = 116
Global Const $dmpaper_penv_9_rotated = 117
Global Const $dmpaper_penv_10_rotated = 118
Global Const $dmpaper_user = 256
Global Const $dmbin_upper = 1
Global Const $dmbin_lower = 2
Global Const $dmbin_middle = 3
Global Const $dmbin_manual = 4
Global Const $dmbin_envelope = 5
Global Const $dmbin_envmanual = 6
Global Const $dmbin_auto = 7
Global Const $dmbin_tractor = 8
Global Const $dmbin_smallfmt = 9
Global Const $dmbin_largefmt = 10
Global Const $dmbin_largecapacity = 11
Global Const $dmbin_cassette = 14
Global Const $dmbin_formsource = 15
Global Const $dmbin_user = 256
Global Const $dmres_draft = -1
Global Const $dmres_low = -2
Global Const $dmres_medium = -3
Global Const $dmres_high = -4
Global Const $dmdo_default = 0
Global Const $dmdo_90 = 1
Global Const $dmdo_180 = 2
Global Const $dmdo_270 = 3
Global Const $dmdfo_default = 0
Global Const $dmdfo_stretch = 1
Global Const $dmdfo_center = 2
Global Const $dmcolor_monochrome = 1
Global Const $dmcolor_color = 2
Global Const $dmdup_simplex = 1
Global Const $dmdup_vertical = 2
Global Const $dmdup_horizontal = 3
Global Const $dmtt_bitmap = 1
Global Const $dmtt_download = 2
Global Const $dmtt_subdev = 3
Global Const $dmtt_download_outline = 4
Global Const $dmcollate_false = 0
Global Const $dmcollate_true = 1
Global Const $dm_grayscale = 1
Global Const $dm_interlaced = 2
Global Const $dmnup_system = 1
Global Const $dmnup_oneup = 2
Global Const $dmicmmethod_none = 1
Global Const $dmicmmethod_system = 2
Global Const $dmicmmethod_driver = 3
Global Const $dmicmmethod_device = 4
Global Const $dmicmmethod_user = 256
Global Const $dmicm_saturate = 1
Global Const $dmicm_contrast = 2
Global Const $dmicm_colorimetric = 3
Global Const $dmicm_abs_colorimetric = 4
Global Const $dmicm_user = 256
Global Const $dmmedia_standard = 1
Global Const $dmmedia_transparency = 2
Global Const $dmmedia_glossy = 3
Global Const $dmmedia_user = 256
Global Const $dmdither_none = 1
Global Const $dmdither_coarse = 2
Global Const $dmdither_fine = 3
Global Const $dmdither_lineart = 4
Global Const $dmdither_errordiffusion = 5
Global Const $dmdither_reserved6 = 6
Global Const $dmdither_reserved7 = 7
Global Const $dmdither_reserved8 = 8
Global Const $dmdither_reserved9 = 9
Global Const $dmdither_grayscale = 10
Global Const $dmdither_user = 256
Global Const $enum_current_settings = -1
Global Const $enum_registry_settings = -2
Global Const $device_fonttype = 2
Global Const $raster_fonttype = 1
Global Const $truetype_fonttype = 4
Global Const $ntm_bold = 32
Global Const $ntm_dsig = 2097152
Global Const $ntm_italic = 1
Global Const $ntm_multiplemaster = 524288
Global Const $ntm_nonnegative_ac = 65536
Global Const $ntm_ps_opentype = 131072
Global Const $ntm_regular = 64
Global Const $ntm_tt_opentype = 262144
Global Const $ntm_type1 = 1048576
Global Const $floodfillborder = 0
Global Const $floodfillsurface = 1
Global Const $ad_counterclockwise = 1
Global Const $ad_clockwise = 2
Global Const $dcb_accumulate = 2
Global Const $dcb_disable = 8
Global Const $dcb_enable = 4
Global Const $dcb_reset = 1
Global Const $dcb_set = BitOR($dcb_reset, $dcb_accumulate)
Global Const $obj_bitmap = 7
Global Const $obj_brush = 2
Global Const $obj_colorspace = 14
Global Const $obj_dc = 3
Global Const $obj_enhmetadc = 12
Global Const $obj_enhmetafile = 13
Global Const $obj_extpen = 11
Global Const $obj_font = 6
Global Const $obj_memdc = 10
Global Const $obj_metadc = 4
Global Const $obj_metafile = 9
Global Const $obj_pal = 5
Global Const $obj_pen = 1
Global Const $obj_region = 8
Global Const $dcx_window = 1
Global Const $dcx_cache = 2
Global Const $dcx_parentclip = 32
Global Const $dcx_clipsiblings = 16
Global Const $dcx_clipchildren = 8
Global Const $dcx_noresetattrs = 4
Global Const $dcx_lockwindowupdate = 1024
Global Const $dcx_excludergn = 64
Global Const $dcx_intersectrgn = 128
Global Const $dcx_intersectupdate = 512
Global Const $dcx_validate = 2097152
Global Const $ggo_bezier = 3
Global Const $ggo_bitmap = 1
Global Const $ggo_glyph_index = 128
Global Const $ggo_gray2_bitmap = 4
Global Const $ggo_gray4_bitmap = 5
Global Const $ggo_gray8_bitmap = 6
Global Const $ggo_metrics = 0
Global Const $ggo_native = 2
Global Const $ggo_unhinted = 256
Global Const $gm_compatible = 1
Global Const $gm_advanced = 2
Global Const $mm_anisotropic = 8
Global Const $mm_hienglish = 5
Global Const $mm_himetric = 3
Global Const $mm_isotropic = 7
Global Const $mm_loenglish = 4
Global Const $mm_lometric = 2
Global Const $mm_text = 1
Global Const $mm_twips = 6
Global Const $r2_black = 1
Global Const $r2_copypen = 13
Global Const $r2_last = 16
Global Const $r2_masknotpen = 3
Global Const $r2_maskpen = 9
Global Const $r2_maskpennot = 5
Global Const $r2_mergenotpen = 12
Global Const $r2_mergepen = 15
Global Const $r2_mergepennot = 14
Global Const $r2_nop = 11
Global Const $r2_not = 6
Global Const $r2_notcopypen = 4
Global Const $r2_notmaskpen = 8
Global Const $r2_notmergepen = 2
Global Const $r2_notxorpen = 10
Global Const $r2_white = 16
Global Const $r2_xorpen = 7
Global Const $blackonwhite = 1
Global Const $coloroncolor = 3
Global Const $halftone = 4
Global Const $whiteonblack = 2
Global Const $stretch_andscans = $blackonwhite
Global Const $stretch_deletescans = $coloroncolor
Global Const $stretch_halftone = $halftone
Global Const $stretch_orscans = $whiteonblack
Global Const $ta_baseline = 24
Global Const $ta_bottom = 8
Global Const $ta_top = 0
Global Const $ta_center = 6
Global Const $ta_left = 0
Global Const $ta_right = 2
Global Const $ta_noupdatecp = 0
Global Const $ta_rtlreading = 256
Global Const $ta_updatecp = 1
Global Const $vta_baseline = $ta_baseline
Global Const $vta_bottom = $ta_right
Global Const $vta_top = $ta_left
Global Const $vta_center = $ta_center
Global Const $vta_left = $ta_bottom
Global Const $vta_right = $ta_top
Global Const $udf_bgr = 1
Global Const $udf_rgb = 0
Global Const $mwt_identity = 1
Global Const $mwt_leftmultiply = 2
Global Const $mwt_rightmultiply = 3
Global Const $mwt_set = 4
Global Const $monitor_defaulttonearest = 2
Global Const $monitor_defaulttonull = 0
Global Const $monitor_defaulttoprimary = 1
Global Const $pt_bezierto = 4
Global Const $pt_lineto = 2
Global Const $pt_moveto = 6
Global Const $pt_closefigure = 1
Global Const $coinit_apartmentthreaded = 2
Global Const $coinit_disable_ole1dde = 4
Global Const $coinit_multithreaded = 0
Global Const $coinit_speed_over_memory = 8
#Region Global Variables and Constants
	Global $__g_venum, $__g_vext = 0
	Global $__g_hheap = 0, $__g_irgbmode = 1
	Global Const $tagosversioninfo = "struct;dword OSVersionInfoSize;dword MajorVersion;dword MinorVersion;dword BuildNumber;dword PlatformId;wchar CSDVersion[128];endstruct"
	Global Const $__winver = __winver()
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions

	Func _winapi_arraytostruct(Const ByRef $adata, $istart = 0, $iend = -1)
		If __checkerrorarraybounds($adata, $istart, $iend) Then Return SetError(@error + 10, @extended, 0)
		Local $tagstruct = ""
		For $i = $istart To $iend
			$tagstruct &= "wchar[" & (StringLen($adata[$i]) + 1) & "];"
		Next
		Local $tdata = DllStructCreate($tagstruct & "wchar[1]")
		Local $icount = 1
		For $i = $istart To $iend
			DllStructSetData($tdata, $icount, $adata[$i])
			$icount += 1
		Next
		DllStructSetData($tdata, $icount, ChrW(0))
		Return $tdata
	EndFunc

	Func _winapi_createmargins($ileftwidth, $irightwidth, $itopheight, $ibottomheight)
		Local $tmargins = DllStructCreate($tagmargins)
		DllStructSetData($tmargins, 1, $ileftwidth)
		DllStructSetData($tmargins, 2, $irightwidth)
		DllStructSetData($tmargins, 3, $itopheight)
		DllStructSetData($tmargins, 4, $ibottomheight)
		Return $tmargins
	EndFunc

	Func _winapi_createpoint($ix, $iy)
		Local $tpoint = DllStructCreate($tagpoint)
		DllStructSetData($tpoint, 1, $ix)
		DllStructSetData($tpoint, 2, $iy)
		Return $tpoint
	EndFunc

	Func _winapi_createrect($ileft, $itop, $iright, $ibottom)
		Local $trect = DllStructCreate($tagrect)
		DllStructSetData($trect, 1, $ileft)
		DllStructSetData($trect, 2, $itop)
		DllStructSetData($trect, 3, $iright)
		DllStructSetData($trect, 4, $ibottom)
		Return $trect
	EndFunc

	Func _winapi_createrectex($ix, $iy, $iwidth, $iheight)
		Local $trect = DllStructCreate($tagrect)
		DllStructSetData($trect, 1, $ix)
		DllStructSetData($trect, 2, $iy)
		DllStructSetData($trect, 3, $ix + $iwidth)
		DllStructSetData($trect, 4, $iy + $iheight)
		Return $trect
	EndFunc

	Func _winapi_createsize($iwidth, $iheight)
		Local $tsize = DllStructCreate($tagsize)
		DllStructSetData($tsize, 1, $iwidth)
		DllStructSetData($tsize, 2, $iheight)
		Return $tsize
	EndFunc

	Func _winapi_fatalexit($icode)
		DllCall("kernel32.dll", "none", "FatalExit", "int", $icode)
		If @error Then Return SetError(@error, @extended)
	EndFunc

	Func _winapi_getbitmapdimension($hbitmap)
		Local Const $tagbitmap = "struct;long bmType;long bmWidth;long bmHeight;long bmWidthBytes;ushort bmPlanes;ushort bmBitsPixel;ptr bmBits;endstruct"
		Local $tobj = DllStructCreate($tagbitmap)
		Local $aret = DllCall("gdi32.dll", "int", "GetObject", "handle", $hbitmap, "int", DllStructGetSize($tobj), "struct*", $tobj)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return _winapi_createsize(DllStructGetData($tobj, "bmWidth"), DllStructGetData($tobj, "bmHeight"))
	EndFunc

	Func _winapi_getstring($pstring, $bunicode = True)
		Local $ilength = _winapi_strlen($pstring, $bunicode)
		If @error OR NOT $ilength Then Return SetError(@error + 10, @extended, "")
		Local $tstring = DllStructCreate(__iif($bunicode, "wchar", "char") & "[" & ($ilength + 1) & "]", $pstring)
		If @error Then Return SetError(@error, @extended, "")
		Return SetExtended($ilength, DllStructGetData($tstring, 1))
	EndFunc

	Func _winapi_isbadreadptr($paddress, $ilength)
		Local $aret = DllCall("kernel32.dll", "bool", "IsBadReadPtr", "struct*", $paddress, "uint_ptr", $ilength)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_isbadwriteptr($paddress, $ilength)
		Local $aret = DllCall("kernel32.dll", "bool", "IsBadWritePtr", "struct*", $paddress, "uint_ptr", $ilength)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_iswow64process($ipid = 0)
		If NOT $ipid Then $ipid = @AutoItPID
		Local $hprocess = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", __iif($__winver < 1536, 1024, 4096), "bool", 0, "dword", $ipid)
		If @error OR NOT $hprocess[0] Then Return SetError(@error + 20, @extended, False)
		Local $aret = DllCall("kernel32.dll", "bool", "IsWow64Process", "handle", $hprocess[0], "bool*", 0)
		If __checkerrorclosehandle($aret, $hprocess[0]) Then Return SetError(@error, @extended, False)
		Return $aret[2]
	EndFunc

	Func _winapi_movememory($pdestination, $psource, $ilength)
		If _winapi_isbadreadptr($psource, $ilength) Then Return SetError(10, @extended, 0)
		If _winapi_isbadwriteptr($pdestination, $ilength) Then Return SetError(11, @extended, 0)
		DllCall("ntdll.dll", "none", "RtlMoveMemory", "struct*", $pdestination, "struct*", $psource, "ulong_ptr", $ilength)
		If @error Then Return SetError(@error, @extended, 0)
		Return 1
	EndFunc

	Func _winapi_pathisdirectory($sfilepath)
		Local $aret = DllCall("shlwapi.dll", "bool", "PathIsDirectoryW", "wstr", $sfilepath)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_strlen($pstring, $bunicode = True)
		Local $w = ""
		If $bunicode Then $w = "W"
		Local $aret = DllCall("kernel32.dll", "int", "lstrlen" & $w, "struct*", $pstring)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_structtoarray(ByRef $tstruct, $iitems = 0)
		Local $isize = 2 * Floor(DllStructGetSize($tstruct) / 2)
		Local $pstruct = DllStructGetPtr($tstruct)
		If NOT $isize OR NOT $pstruct Then Return SetError(1, 0, 0)
		Local $tdata, $ilength, $ioffset = 0
		Local $aresult[101] = [0]
		While 1
			$ilength = _winapi_strlen($pstruct + $ioffset)
			If NOT $ilength Then
				ExitLoop
			EndIf
			If 2 * (1 + $ilength) + $ioffset > $isize Then Return SetError(3, 0, 0)
			$tdata = DllStructCreate("wchar[" & (1 + $ilength) & "]", $pstruct + $ioffset)
			If @error Then Return SetError(@error + 10, 0, 0)
			__inc($aresult)
			$aresult[$aresult[0]] = DllStructGetData($tdata, 1)
			If $aresult[0] = $iitems Then
				ExitLoop
			EndIf
			$ioffset += 2 * (1 + $ilength)
			If $ioffset >= $isize Then Return SetError(3, 0, 0)
		WEnd
		If NOT $aresult[0] Then Return SetError(2, 0, 0)
		__inc($aresult, -1)
		Return $aresult
	EndFunc

	Func _winapi_swapdword($ivalue)
		Local $tstruct1 = DllStructCreate("dword;dword")
		Local $tstruct2 = DllStructCreate("byte[4];byte[4]", DllStructGetPtr($tstruct1))
		DllStructSetData($tstruct1, 1, $ivalue)
		For $i = 1 To 4
			DllStructSetData($tstruct2, 2, DllStructGetData($tstruct2, 1, 5 - $i), $i)
		Next
		Return DllStructGetData($tstruct1, 2)
	EndFunc

	Func _winapi_swapqword($ivalue)
		Local $tstruct1 = DllStructCreate("int64;int64")
		Local $tstruct2 = DllStructCreate("byte[8];byte[8]", DllStructGetPtr($tstruct1))
		DllStructSetData($tstruct1, 1, $ivalue)
		For $i = 1 To 8
			DllStructSetData($tstruct2, 2, DllStructGetData($tstruct2, 1, 9 - $i), $i)
		Next
		Return DllStructGetData($tstruct1, 2)
	EndFunc

	Func _winapi_swapword($ivalue)
		Local $tstruct1 = DllStructCreate("word;word")
		Local $tstruct2 = DllStructCreate("byte[2];byte[2]", DllStructGetPtr($tstruct1))
		DllStructSetData($tstruct1, 1, $ivalue)
		For $i = 1 To 2
			DllStructSetData($tstruct2, 2, DllStructGetData($tstruct2, 1, 3 - $i), $i)
		Next
		Return DllStructGetData($tstruct1, 2)
	EndFunc

	Func _winapi_switchcolor($icolor)
		If $icolor = -1 Then Return $icolor
		Return BitOR(BitAND($icolor, 65280), BitShift(BitAND($icolor, 255), -16), BitShift(BitAND($icolor, 16711680), 16))
	EndFunc

	Func _winapi_zeromemory($pmemory, $ilength)
		If _winapi_isbadwriteptr($pmemory, $ilength) Then Return SetError(11, @extended, 0)
		DllCall("ntdll.dll", "none", "RtlZeroMemory", "struct*", $pmemory, "ulong_ptr", $ilength)
		If @error Then Return SetError(@error, @extended, 0)
		Return 1
	EndFunc

#EndRegion Public Functions
#Region Internal Functions

	Func __checkerrorarraybounds(Const ByRef $adata, ByRef $istart, ByRef $iend, $ndim = 1, $idim = $ubound_dimensions)
		If NOT IsArray($adata) Then Return SetError(1, 0, 1)
		If UBound($adata, $idim) <> $ndim Then Return SetError(2, 0, 1)
		If $istart < 0 Then $istart = 0
		Local $iubound = UBound($adata) - 1
		If $iend < 1 OR $iend > $iubound Then $iend = $iubound
		If $istart > $iend Then Return SetError(4, 0, 1)
		Return 0
	EndFunc

	Func __checkerrorclosehandle($aret, $hfile, $blasterror = 0, $icurerr = @error, $icurext = @extended)
		If NOT $icurerr AND NOT $aret[0] Then $icurerr = 10
		Local $ilasterror = _winapi_getlasterror()
		DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hfile)
		If $icurerr Then _winapi_setlasterror($ilasterror)
		If $blasterror Then $icurext = $ilasterror
		Return SetError($icurerr, $icurext, $icurerr)
	EndFunc

	Func __dll($spath, $bpin = False)
		Local $aret = DllCall("kernel32.dll", "bool", "GetModuleHandleExW", "dword", __iif($bpin, 1, 2), "wstr", $spath, "ptr*", 0)
		If NOT $aret[3] Then
			Local $aresult = DllCall("kernel32.dll", "handle", "LoadLibraryW", "wstr", $spath)
			If NOT $aresult[0] Then Return 0
		EndIf
		Return 1
	EndFunc

	Func __enumwindowsproc($hwnd, $bvisible)
		Local $aresult
		If $bvisible Then
			$aresult = DllCall("user32.dll", "bool", "IsWindowVisible", "hwnd", $hwnd)
			If NOT $aresult[0] Then
				Return 1
			EndIf
		EndIf
		__inc($__g_venum)
		$__g_venum[$__g_venum[0][0]][0] = $hwnd
		$aresult = DllCall("user32.dll", "int", "GetClassNameW", "hwnd", $hwnd, "wstr", "", "int", 4096)
		$__g_venum[$__g_venum[0][0]][1] = $aresult[2]
		Return 1
	EndFunc

	Func __fatalexit($icode, $stext = "")
		If $stext Then MsgBox($mb_systemmodal, "AutoIt", $stext)
		_winapi_fatalexit($icode)
	EndFunc

	Func __heapalloc($isize, $babort = False)
		Local $aret
		If NOT $__g_hheap Then
			$aret = DllCall("kernel32.dll", "handle", "HeapCreate", "dword", 0, "ulong_ptr", 0, "ulong_ptr", 0)
			If @error OR NOT $aret[0] Then __fatalexit(1, "Error allocating memory.")
			$__g_hheap = $aret[0]
		EndIf
		$aret = DllCall("kernel32.dll", "ptr", "HeapAlloc", "handle", $__g_hheap, "dword", 8, "ulong_ptr", $isize)
		If @error OR NOT $aret[0] Then
			If $babort Then __fatalexit(1, "Error allocating memory.")
			Return SetError(@error + 30, @extended, 0)
		EndIf
		Return $aret[0]
	EndFunc

	Func __heapfree(ByRef $pmemory, $bcheck = False, $icurerr = @error, $icurext = @extended)
		If $bcheck AND (NOT __heapvalidate($pmemory)) Then Return SetError(@error, @extended, 0)
		Local $aret = DllCall("kernel32.dll", "int", "HeapFree", "handle", $__g_hheap, "dword", 0, "ptr", $pmemory)
		If @error OR NOT $aret[0] Then Return SetError(@error + 40, @extended, 0)
		$pmemory = 0
		Return SetError($icurerr, $icurext, 1)
	EndFunc

	Func __heaprealloc($pmemory, $isize, $bamount = False, $babort = False)
		Local $aret, $pret
		If __heapvalidate($pmemory) Then
			If $bamount AND (__heapsize($pmemory) >= $isize) Then Return SetExtended(1, Ptr($pmemory))
			$aret = DllCall("kernel32.dll", "ptr", "HeapReAlloc", "handle", $__g_hheap, "dword", 8, "ptr", $pmemory, "ulong_ptr", $isize)
			If @error OR NOT $aret[0] Then
				If $babort Then __fatalexit(1, "Error allocating memory.")
				Return SetError(@error + 20, @extended, Ptr($pmemory))
			EndIf
			$pret = $aret[0]
		Else
			$pret = __heapalloc($isize, $babort)
			If @error Then Return SetError(@error, @extended, 0)
		EndIf
		Return $pret
	EndFunc

	Func __heapsize($pmemory, $bcheck = False)
		If $bcheck AND (NOT __heapvalidate($pmemory)) Then Return SetError(@error, @extended, 0)
		Local $aret = DllCall("kernel32.dll", "ulong_ptr", "HeapSize", "handle", $__g_hheap, "dword", 0, "ptr", $pmemory)
		If @error OR ($aret[0] = Ptr(-1)) Then Return SetError(@error + 50, @extended, 0)
		Return $aret[0]
	EndFunc

	Func __heapvalidate($pmemory)
		If (NOT $__g_hheap) OR (NOT Ptr($pmemory)) Then Return SetError(9, 0, False)
		Local $aret = DllCall("kernel32.dll", "int", "HeapValidate", "handle", $__g_hheap, "dword", 0, "ptr", $pmemory)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func __inc(ByRef $adata, $iincrement = 100)
		Select
			Case UBound($adata, $ubound_columns)
				If $iincrement < 0 Then
					ReDim $adata[$adata[0][0] + 1][UBound($adata, $ubound_columns)]
				Else
					$adata[0][0] += 1
					If $adata[0][0] > UBound($adata) - 1 Then
						ReDim $adata[$adata[0][0] + $iincrement][UBound($adata, $ubound_columns)]
					EndIf
				EndIf
			Case UBound($adata, $ubound_rows)
				If $iincrement < 0 Then
					ReDim $adata[$adata[0] + 1]
				Else
					$adata[0] += 1
					If $adata[0] > UBound($adata) - 1 Then
						ReDim $adata[$adata[0] + $iincrement]
					EndIf
				EndIf
			Case Else
				Return 0
		EndSelect
		Return 1
	EndFunc

	Func __iif($btest, $vtrue, $vfalse)
		Return $btest ? $vtrue : $vfalse
	EndFunc

	Func __init($ddata)
		Local $ilength = BinaryLen($ddata)
		Local $aret = DllCall("kernel32.dll", "ptr", "VirtualAlloc", "ptr", 0, "ulong_ptr", $ilength, "dword", 4096, "dword", 64)
		If @error OR NOT $aret[0] Then __fatalexit(1, "Error allocating memory.")
		Local $tdata = DllStructCreate("byte[" & $ilength & "]", $aret[0])
		DllStructSetData($tdata, 1, $ddata)
		Return $aret[0]
	EndFunc

	Func __rgb($icolor)
		If $__g_irgbmode Then
			$icolor = _winapi_switchcolor($icolor)
		EndIf
		Return $icolor
	EndFunc

	Func __winver()
		Local $tosvi = DllStructCreate($tagosversioninfo)
		DllStructSetData($tosvi, 1, DllStructGetSize($tosvi))
		Local $aret = DllCall("kernel32.dll", "bool", "GetVersionExW", "struct*", $tosvi)
		If @error OR NOT $aret[0] Then Return SetError(@error, @extended, 0)
		Return BitOR(BitShift(DllStructGetData($tosvi, 2), -8), DllStructGetData($tosvi, 3))
	EndFunc

#EndRegion Internal Functions
#Region Global Variables and Constants
	Global Const $__tagwinapicom_guid = "struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];endstruct"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions

	Func _winapi_clsidfromprogid($sprogid)
		Local $tguid = DllStructCreate($__tagwinapicom_guid)
		Local $areturn = DllCall("ole32.dll", "long", "CLSIDFromProgID", "wstr", $sprogid, "struct*", $tguid)
		If @error Then Return SetError(@error, @extended, "")
		If $areturn[0] Then Return SetError(10, $areturn[0], "")
		$areturn = DllCall("ole32.dll", "int", "StringFromGUID2", "struct*", $tguid, "wstr", "", "int", 39)
		If @error OR NOT $areturn[0] Then Return SetError(@error + 20, @extended, "")
		Return $areturn[2]
	EndFunc

	Func _winapi_coinitialize($iflags = 0)
		Local $areturn = DllCall("ole32.dll", "long", "CoInitializeEx", "ptr", 0, "dword", $iflags)
		If @error Then Return SetError(@error, @extended, 0)
		If $areturn[0] Then Return SetError(10, $areturn[0], 0)
		Return 1
	EndFunc

	Func _winapi_cotaskmemalloc($isize)
		Local $areturn = DllCall("ole32.dll", "ptr", "CoTaskMemAlloc", "uint_ptr", $isize)
		If @error Then Return SetError(@error, @extended, 0)
		Return $areturn[0]
	EndFunc

	Func _winapi_cotaskmemfree($pmemory)
		DllCall("ole32.dll", "none", "CoTaskMemFree", "ptr", $pmemory)
		If @error Then Return SetError(@error, @extended, 0)
		Return 1
	EndFunc

	Func _winapi_cotaskmemrealloc($pmemory, $isize)
		Local $areturn = DllCall("ole32.dll", "ptr", "CoTaskMemRealloc", "ptr", $pmemory, "ulong_ptr", $isize)
		If @error Then Return SetError(@error, @extended, 0)
		Return $areturn[0]
	EndFunc

	Func _winapi_couninitialize()
		DllCall("ole32.dll", "none", "CoUninitialize")
		If @error Then Return SetError(@error, @extended, 0)
		Return 1
	EndFunc

	Func _winapi_createguid()
		Local $tguid = DllStructCreate($__tagwinapicom_guid)
		Local $areturn = DllCall("ole32.dll", "long", "CoCreateGuid", "struct*", $tguid)
		If @error Then Return SetError(@error, @extended, "")
		If $areturn[0] Then Return SetError(10, $areturn[0], "")
		$areturn = DllCall("ole32.dll", "int", "StringFromGUID2", "struct*", $tguid, "wstr", "", "int", 65536)
		If @error OR NOT $areturn[0] Then Return SetError(@error + 20, @extended, "")
		Return $areturn[2]
	EndFunc

	Func _winapi_createstreamonhglobal($hglobal = 0, $bdeleteonrelease = True)
		Local $areturn = DllCall("ole32.dll", "long", "CreateStreamOnHGlobal", "handle", $hglobal, "bool", $bdeleteonrelease, "ptr*", 0)
		If @error Then Return SetError(@error, @extended, 0)
		If $areturn[0] Then Return SetError(10, $areturn[0], 0)
		Return $areturn[3]
	EndFunc

	Func _winapi_gethglobalfromstream($pstream)
		Local $areturn = DllCall("ole32.dll", "uint", "GetHGlobalFromStream", "ptr", $pstream, "ptr*", 0)
		If @error Then Return SetError(@error, @extended, 0)
		If $areturn[0] Then Return SetError(10, $areturn[0], 0)
		Return $areturn[2]
	EndFunc

	Func _winapi_progidfromclsid($sclsid)
		Local $tguid = DllStructCreate($__tagwinapicom_guid)
		Local $areturn = DllCall("ole32.dll", "uint", "CLSIDFromString", "wstr", $sclsid, "struct*", $tguid)
		If @error OR $areturn[0] Then Return SetError(@error + 20, @extended, "")
		$areturn = DllCall("ole32.dll", "uint", "ProgIDFromCLSID", "struct*", $tguid, "ptr*", 0)
		If @error Then Return SetError(@error, @extended, "")
		If $areturn[0] Then Return SetError(10, $areturn[0], "")
		Local $sid = _winapi_getstring($areturn[2])
		_winapi_cotaskmemfree($areturn[2])
		Return $sid
	EndFunc

	Func _winapi_releasestream($pstream)
		Local $areturn = DllCall("oleaut32.dll", "long", "DispCallFunc", "ptr", $pstream, "ulong_ptr", 8 * (1 + @AutoItX64), "uint", 4, "ushort", 23, "uint", 0, "ptr", 0, "ptr", 0, "str", "")
		If @error Then Return SetError(@error, @extended, 0)
		If $areturn[0] Then Return SetError(10, $areturn[0], 0)
		Return 1
	EndFunc

#EndRegion Public Functions
#Region Global Variables and Constants
	Global Const $tagbitmap = "struct;long bmType;long bmWidth;long bmHeight;long bmWidthBytes;ushort bmPlanes;ushort bmBitsPixel;ptr bmBits;endstruct"
	Global Const $tagbitmapv4header = "struct;dword bV4Size;long bV4Width;long bV4Height;ushort bV4Planes;ushort bV4BitCount;dword bV4Compression;dword bV4SizeImage;long bV4XPelsPerMeter;long bV4YPelsPerMeter;dword bV4ClrUsed;dword bV4ClrImportant;dword bV4RedMask;dword bV4GreenMask;dword bV4BlueMask;dword bV4AlphaMask;dword bV4CSType;int bV4Endpoints[9];dword bV4GammaRed;dword bV4GammaGreen;dword bV4GammaBlue;endstruct"
	Global Const $tagbitmapv5header = "struct;dword bV5Size;long bV5Width;long bV5Height;ushort bV5Planes;ushort bV5BitCount;dword bV5Compression;dword bV5SizeImage;long bV5XPelsPerMeter;long bV5YPelsPerMeter;dword bV5ClrUsed;dword bV5ClrImportant;dword bV5RedMask;dword bV5GreenMask;dword bV5BlueMask;dword bV5AlphaMask;dword bV5CSType;int bV5Endpoints[9];dword bV5GammaRed;dword bV5GammaGreen;dword bV5GammaBlue;dword bV5Intent;dword bV5ProfileData;dword bV5ProfileSize;dword bV5Reserved;endstruct"
	Global Const $tagcoloradjustment = "ushort Size;ushort Flags;ushort IlluminantIndex;ushort RedGamma;ushort GreenGamma;ushort BlueGamma;ushort ReferenceBlack;ushort ReferenceWhite;short Contrast;short Brightness;short Colorfulness;short RedGreenTint"
	Global Const $tagdevmode_display = "wchar DeviceName[32];ushort SpecVersion;ushort DriverVersion;ushort Size;ushort DriverExtra;dword Fields;" & $tagpoint & ";dword DisplayOrientation;dword DisplayFixedOutput;short Unused1[5];wchar Unused2[32];ushort LogPixels;dword BitsPerPel;dword PelsWidth;dword PelsHeight;dword DisplayFlags;dword DisplayFrequency"
	Global Const $tagdibsection = $tagbitmap & ";" & $tagbitmapinfoheader & ";dword dsBitfields[3];ptr dshSection;dword dsOffset"
	Global Const $tagdwm_colorization_parameters = "dword Color;dword AfterGlow;uint ColorBalance;uint AfterGlowBalance;uint BlurBalance;uint GlassReflectionIntensity; uint OpaqueBlend"
	Global Const $tagenhmetaheader = "struct;dword Type;dword Size;long rcBounds[4];long rcFrame[4];dword Signature;dword Version;dword Bytes;dword Records;ushort Handles;ushort Reserved;dword Description;dword OffDescription;dword PalEntries;long Device[2];long Millimeters[2];dword PixelFormat;dword OffPixelFormat;dword OpenGL;long Micrometers[2];endstruct"
	Global Const $tagextlogpen = "dword PenStyle;dword Width;uint BrushStyle;dword Color;ulong_ptr Hatch;dword NumEntries"
	Global Const $tagfontsignature = "dword fsUsb[4];dword fsCsb[2]"
	Global Const $tagglyphmetrics = "uint BlackBoxX;uint BlackBoxY;" & $tagpoint & ";short CellIncX;short CellIncY"
	Global Const $taglogbrush = "uint Style;dword Color;ulong_ptr Hatch"
	Global Const $taglogpen = "uint Style;dword Width;dword Color"
	Global Const $tagmat2 = "short eM11[2];short eM12[2];short eM21[2];short eM22[2]"
	Global Const $tagnewtextmetric = $tagtextmetric & ";dword ntmFlags;uint ntmSizeEM;uint ntmCellHeight;uint ntmAvgWidth"
	Global Const $tagnewtextmetricex = $tagnewtextmetric & ";" & $tagfontsignature
	Global Const $tagpanose = "struct;byte bFamilyType;byte bSerifStyle;byte bWeight;byte bProportion;byte bContrast;byte bStrokeVariation;byte bArmStyle;byte bLetterform;byte bMidline;byte bXHeight;endstruct"
	Global Const $tagoutlinetextmetric = "struct;uint otmSize;" & $tagtextmetric & ";byte otmFiller;" & $tagpanose & ";byte bugFiller[3];uint otmSelection;uint otmType;int otmCharSlopeRise;int otmCharSlopeRun;int otmItalicAngle;uint otmEMSquare;int otmAscent;int otmDescent;uint otmLineGap;uint otmCapEmHeight;uint otmXHeight;long otmFontBox[4];int otmMacAscent;int otmMacDescent;uint otmMacLineGap;uint otmMinimumPPEM;long otmSubscriptSize[2];long otmSubscriptOffset[2];long otmSuperscriptSize[2];long otmSuperscriptOffse[2];uint otmStrikeoutSize;int otmStrikeoutPosition;int otmUnderscoreSize;int otmUnderscorePosition;uint_ptr otmFamilyName;uint_ptr otmFaceName;uint_ptr otmStyleName;uint_ptr otmFullName;endstruct"
	Global Const $tagpaintstruct = "hwnd hDC;int fErase;dword rPaint[4];int fRestore;int fIncUpdate;byte rgbReserved[32]"
	Global Const $tagrgndataheader = "struct;dword Size;dword Type;dword Count;dword RgnSize;" & $tagrect & ";endstruct"
	Global Const $tagxform = "float eM11;float eM12;float eM21;float eM22;float eDx;float eDy"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions

	Func _winapi_abortpath($hdc)
		Local $aret = DllCall("gdi32.dll", "bool", "AbortPath", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_addfontmemresourceex($pdata, $isize)
		Local $aret = DllCall("gdi32.dll", "handle", "AddFontMemResourceEx", "ptr", $pdata, "dword", $isize, "ptr", 0, "dword*", 0)
		If @error Then Return SetError(@error, @extended, 0)
		Return SetExtended($aret[4], $aret[0])
	EndFunc

	Func _winapi_addfontresourceex($sfont, $iflag = 0, $bnotify = False)
		Local $aret = DllCall("gdi32.dll", "int", "AddFontResourceExW", "wstr", $sfont, "dword", $iflag, "ptr", 0)
		If @error OR NOT $aret[0] Then Return SetError(@error, @extended, 0)
		If $bnotify Then
			Local Const $wm_fontchange = 29
			Local Const $hwnd_broadcast = 65535
			DllCall("user32.dll", "lresult", "SendMessage", "hwnd", $hwnd_broadcast, "uint", $wm_fontchange, "wparam", 0, "lparam", 0)
		EndIf
		Return $aret[0]
	EndFunc

	Func _winapi_addiconoverlay($hicon, $hoverlay)
		Local $aret, $hresult = 0, $ierror = 0
		Local $ahdev[2] = [0, 0]
		Local $tsize = _winapi_geticondimension($hicon)
		Local $hil = DllCall("comctl32.dll", "handle", "ImageList_Create", "int", DllStructGetData($tsize, 1), "int", DllStructGetData($tsize, 2), "uint", 33, "int", 2, "int", 2)
		If @error OR NOT $hil[0] Then Return SetError(@error + 10, @extended, 0)
		Do
			$ahdev[0] = _winapi_create32bithicon($hicon)
			If @error Then
				$ierror = @error + 100
				ExitLoop
			EndIf
			$aret = DllCall("comctl32.dll", "int", "ImageList_ReplaceIcon", "handle", $hil[0], "int", -1, "handle", $ahdev[0])
			If @error OR ($aret[0] = -1) Then
				$ierror = @error + 200
				ExitLoop
			EndIf
			$ahdev[1] = _winapi_create32bithicon($hoverlay)
			If @error Then
				$ierror = @error + 300
				ExitLoop
			EndIf
			$aret = DllCall("comctl32.dll", "int", "ImageList_ReplaceIcon", "handle", $hil[0], "int", -1, "handle", $ahdev[1])
			If @error OR ($aret[0] = -1) Then
				$ierror = @error + 400
				ExitLoop
			EndIf
			$aret = DllCall("comctl32.dll", "bool", "ImageList_SetOverlayImage", "handle", $hil[0], "int", 1, "int", 1)
			If @error OR NOT $aret[0] Then
				$ierror = @error + 500
				ExitLoop
			EndIf
			$aret = DllCall("comctl32.dll", "handle", "ImageList_GetIcon", "handle", $hil[0], "int", 0, "uint", 256)
			If @error OR NOT $aret[0] Then
				$ierror = @error + 600
				ExitLoop
			EndIf
			$hresult = $aret[0]
		Until 1
		DllCall("comctl32.dll", "bool", "ImageList_Destroy", "handle", $hil[0])
		For $i = 0 To 1
			If $ahdev[$i] Then
				_winapi_destroyicon($ahdev[$i])
			EndIf
		Next
		If NOT $hresult Then Return SetError($ierror, 0, 0)
		Return $hresult
	EndFunc

	Func _winapi_adjustbitmap($hbitmap, $iwidth, $iheight, $imode = 3, $tadjustment = 0)
		Local $tobj = DllStructCreate($tagbitmap)
		Local $aret = DllCall("gdi32.dll", "int", "GetObject", "handle", $hbitmap, "int", DllStructGetSize($tobj), "struct*", $tobj)
		If @error OR NOT $aret[0] Then Return SetError(@error, @extended, 0)
		If $iwidth = -1 Then
			$iwidth = DllStructGetData($tobj, "bmWidth")
		EndIf
		If $iheight = -1 Then
			$iheight = DllStructGetData($tobj, "bmHeight")
		EndIf
		$aret = DllCall("user32.dll", "handle", "GetDC", "hwnd", 0)
		Local $hdc = $aret[0]
		$aret = DllCall("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $hdc)
		Local $hdestdc = $aret[0]
		$aret = DllCall("gdi32.dll", "handle", "CreateCompatibleBitmap", "handle", $hdc, "int", $iwidth, "int", $iheight)
		Local $hbmp = $aret[0]
		$aret = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdestdc, "handle", $hbmp)
		Local $hdestsv = $aret[0]
		$aret = DllCall("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $hdc)
		Local $hsrcdc = $aret[0]
		$aret = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hsrcdc, "handle", $hbitmap)
		Local $hsrcsv = $aret[0]
		If _winapi_setstretchbltmode($hdestdc, $imode) Then
			Switch $imode
				Case 4
					If IsDllStruct($tadjustment) Then
						If NOT _winapi_setcoloradjustment($hdestdc, $tadjustment) Then
						EndIf
					EndIf
				Case Else
			EndSwitch
		EndIf
		$aret = _winapi_stretchblt($hdestdc, 0, 0, $iwidth, $iheight, $hsrcdc, 0, 0, DllStructGetData($tobj, "bmWidth"), DllStructGetData($tobj, "bmHeight"), 13369376)
		DllCall("user32.dll", "int", "ReleaseDC", "hwnd", 0, "handle", $hdc)
		DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdestdc, "handle", $hdestsv)
		DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hsrcdc, "handle", $hsrcsv)
		DllCall("gdi32.dll", "bool", "DeleteDC", "handle", $hdestdc)
		DllCall("gdi32.dll", "bool", "DeleteDC", "handle", $hsrcdc)
		If NOT $aret Then Return SetError(10, 0, 0)
		Return $hbmp
	EndFunc

	Func _winapi_alphablend($hdestdc, $ixdest, $iydest, $iwidthdest, $iheightdest, $hsrcdc, $ixsrc, $iysrc, $iwidthsrc, $iheightsrc, $ialpha, $balpha = False)
		Local $iblend = BitOR(BitShift(NOT ($balpha = False), -24), BitShift(BitAND($ialpha, 255), -16))
		Local $aret = DllCall("gdi32.dll", "bool", "GdiAlphaBlend", "handle", $hdestdc, "int", $ixdest, "int", $iydest, "int", $iwidthdest, "int", $iheightdest, "handle", $hsrcdc, "int", $ixsrc, "int", $iysrc, "int", $iwidthsrc, "int", $iheightsrc, "dword", $iblend)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_anglearc($hdc, $ix, $iy, $iradius, $nstartangle, $nsweepangle)
		Local $aret = DllCall("gdi32.dll", "bool", "AngleArc", "handle", $hdc, "int", $ix, "int", $iy, "dword", $iradius, "float", $nstartangle, "float", $nsweepangle)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_arc($hdc, $trect, $ixstartarc, $iystartarc, $ixendarc, $iyendarc)
		Local $aret = DllCall("gdi32.dll", "bool", "Arc", "handle", $hdc, "int", DllStructGetData($trect, 1), "int", DllStructGetData($trect, 2), "int", DllStructGetData($trect, 3), "int", DllStructGetData($trect, 4), "int", $ixstartarc, "int", $iystartarc, "int", $ixendarc, "int", $iyendarc)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_arcto($hdc, $trect, $ixradial1, $iyradial1, $ixradial2, $iyradial2)
		Local $aret = DllCall("gdi32.dll", "bool", "ArcTo", "handle", $hdc, "int", DllStructGetData($trect, 1), "int", DllStructGetData($trect, 2), "int", DllStructGetData($trect, 3), "int", DllStructGetData($trect, 4), "int", $ixradial1, "int", $iyradial1, "int", $ixradial2, "int", $iyradial2)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_beginpaint($hwnd, ByRef $tpaintstruct)
		$tpaintstruct = DllStructCreate($tagpaintstruct)
		Local $aret = DllCall("user32.dll", "handle", "BeginPaint", "hwnd", $hwnd, "struct*", $tpaintstruct)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_beginpath($hdc)
		Local $aret = DllCall("gdi32.dll", "bool", "BeginPath", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_closeenhmetafile($hdc)
		Local $aret = DllCall("gdi32.dll", "handle", "CloseEnhMetaFile", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_closefigure($hdc)
		Local $aret = DllCall("gdi32.dll", "bool", "CloseFigure", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_coloradjustluma($irgb, $ipercent, $bscale = True)
		If $irgb = -1 Then Return SetError(10, 0, -1)
		If $bscale Then
			$ipercent = Floor($ipercent * 10)
		EndIf
		Local $aret = DllCall("shlwapi.dll", "dword", "ColorAdjustLuma", "dword", __rgb($irgb), "int", $ipercent, "bool", $bscale)
		If @error Then Return SetError(@error, @extended, -1)
		Return __rgb($aret[0])
	EndFunc

	Func _winapi_colorhlstorgb($ihue, $iluminance, $isaturation)
		If NOT $isaturation Then $ihue = 160
		Local $aret = DllCall("shlwapi.dll", "dword", "ColorHLSToRGB", "word", $ihue, "word", $iluminance, "word", $isaturation)
		If @error Then Return SetError(@error, @extended, -1)
		Return __rgb($aret[0])
	EndFunc

	Func _winapi_colorrgbtohls($irgb, ByRef $ihue, ByRef $iluminance, ByRef $isaturation)
		Local $aret = DllCall("shlwapi.dll", "none", "ColorRGBToHLS", "dword", __rgb($irgb), "word*", 0, "word*", 0, "word*", 0)
		If @error Then Return SetError(@error, @extended, 0)
		$ihue = $aret[2]
		$iluminance = $aret[3]
		$isaturation = $aret[4]
		Return 1
	EndFunc

	Func _winapi_combinetransform($txform1, $txform2)
		Local $txform = DllStructCreate($tagxform)
		Local $aret = DllCall("gdi32.dll", "bool", "CombineTransform", "struct*", $txform, "struct*", $txform1, "struct*", $txform2)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $txform
	EndFunc

	Func _winapi_compressbitmapbits($hbitmap, ByRef $pbuffer, $icompression = 0, $iquality = 100)
		If NOT __dll("gdiplus.dll") Then Return SetError(103, 0, 0)
		Local $asize[2], $icount, $iformat, $ilength, $smime, $aret, $hdc, $hsv, $hmem, $tbits, $tdata, $pdata, $ierror = 1
		Local $hsource = 0, $himage = 0, $htoken = 0, $pstream = 0, $tparam = 0
		Local $tdib = DllStructCreate($tagdibsection)
		Do
			Switch $icompression
				Case 0
					$smime = "image/png"
				Case 1
					$smime = "image/jpeg"
				Case Else
					$ierror = 10
					ExitLoop
			EndSwitch
			While $hbitmap
				If NOT _winapi_getobject($hbitmap, DllStructGetSize($tdib), $tdib) Then
					$ierror = 11
					ExitLoop 2
				EndIf
				If (DllStructGetData($tdib, "bmBitsPixel") = 32) AND (NOT DllStructGetData($tdib, "biCompression")) Then
					$ierror = 12
					ExitLoop
				EndIf
				If $hsource Then
					$ierror = 13
					ExitLoop 2
				EndIf
				$hsource = _winapi_createdib(DllStructGetData($tdib, "bmWidth"), DllStructGetData($tdib, "bmHeight"))
				If NOT $hsource Then
					$ierror = @error + 100
					ExitLoop 2
				EndIf
				$hdc = _winapi_createcompatibledc(0)
				$hsv = _winapi_selectobject($hdc, $hsource)
				If _winapi_drawbitmap($hdc, 0, 0, $hbitmap) Then
					$hbitmap = $hsource
				Else
					$ierror = @error + 200
					$hbitmap = 0
				EndIf
				_winapi_selectobject($hdc, $hsv)
				_winapi_deletedc($hdc)
			WEnd
			If NOT $hbitmap Then
				ExitLoop
			EndIf
			For $i = 0 To 1
				$asize[$i] = DllStructGetData($tdib, $i + 2)
			Next
			$tbits = DllStructCreate("byte[" & ($asize[0] * $asize[1] * 4) & "]")
			If NOT _winapi_getbitmapbits($hbitmap, DllStructGetSize($tbits), $tbits) Then
				$ierror = @error + 300
				ExitLoop
			EndIf
			$tdata = DllStructCreate($taggdipstartupinput)
			DllStructSetData($tdata, "Version", 1)
			$aret = DllCall("gdiplus.dll", "int", "GdiplusStartup", "ulong_ptr*", 0, "struct*", $tdata, "ptr", 0)
			If @error OR $aret[0] Then
				$ierror = @error + 400
				ExitLoop
			EndIf
			If _winapi_isalphabitmap($hbitmap) Then
				$iformat = 2498570
			Else
				$iformat = 139273
			EndIf
			$htoken = $aret[1]
			$aret = DllCall("gdiplus.dll", "int", "GdipCreateBitmapFromScan0", "int", $asize[0], "int", $asize[1], "uint", $asize[0] * 4, "int", $iformat, "struct*", $tbits, "ptr*", 0)
			If @error OR $aret[0] Then
				$ierror = @error + 500
				ExitLoop
			EndIf
			$himage = $aret[6]
			$aret = DllCall("gdiplus.dll", "int", "GdipGetImageEncodersSize", "uint*", 0, "uint*", 0)
			If @error OR $aret[0] Then
				$ierror = @error + 600
				ExitLoop
			EndIf
			$icount = $aret[1]
			$tdata = DllStructCreate("byte[" & $aret[2] & "]")
			If @error Then
				$ierror = @error + 700
				ExitLoop
			EndIf
			$pdata = DllStructGetPtr($tdata)
			$aret = DllCall("gdiplus.dll", "int", "GdipGetImageEncoders", "uint", $icount, "uint", $aret[2], "struct*", $tdata)
			If @error OR $aret[0] Then
				$ierror = @error + 800
				ExitLoop
			EndIf
			Local $tcodec, $pencoder = 0
			For $i = 1 To $icount
				$tcodec = DllStructCreate($taggdipimagecodecinfo, $pdata)
				If NOT StringInStr(_winapi_widechartomultibyte(DllStructGetData($tcodec, "MimeType")), $smime) Then
					$pdata += DllStructGetSize($taggdipimagecodecinfo)
				Else
					$pencoder = $pdata
					$ierror = 0
					ExitLoop
				EndIf
			Next
			If NOT $pencoder Then
				$ierror = 15
				ExitLoop
			EndIf
			Switch $icompression
				Case 0
				Case 1
					Local Const $tagencoderparameter = "byte[16] GUID;ulong NumberOfValues;dword Type;ptr pValue"
					$tparam = DllStructCreate("dword Count;" & $tagencoderparameter & ";ulong Quality")
					DllStructSetData($tparam, "Count", 1)
					DllStructSetData($tparam, "NumberOfValues", 1)
					DllStructSetData($tparam, "Type", 4)
					DllStructSetData($tparam, "pValue", DllStructGetPtr($tparam, "Quality"))
					DllStructSetData($tparam, "Quality", $iquality)
					$aret = DllCall("ole32.dll", "long", "CLSIDFromString", "wstr", "{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}", "ptr", DllStructGetPtr($tparam, 2))
					If @error OR $aret[0] Then
						$tparam = 0
					EndIf
			EndSwitch
			$pstream = _winapi_createstreamonhglobal()
			$aret = DllCall("gdiplus.dll", "int", "GdipSaveImageToStream", "handle", $himage, "ptr", $pstream, "ptr", $pencoder, "struct*", $tparam)
			If @error OR $aret[0] Then
				$ierror = @error + 900
				ExitLoop
			EndIf
			$hmem = _winapi_gethglobalfromstream($pstream)
			$aret = DllCall("kernel32.dll", "ulong_ptr", "GlobalSize", "handle", $hmem)
			If @error OR NOT $aret[0] Then
				$ierror = @error + 1000
				ExitLoop
			EndIf
			$ilength = $aret[0]
			$aret = DllCall("kernel32.dll", "ptr", "GlobalLock", "handle", $hmem)
			If @error OR NOT $aret[0] Then
				$ierror = @error + 1100
				ExitLoop
			EndIf
			$pbuffer = __heaprealloc($pbuffer, $ilength, 1)
			If NOT @error Then
				_winapi_movememory($pbuffer, $aret[0], $ilength)
			Else
				$ierror = @error + 1300
			EndIf
		Until 1
		If $pstream Then
			_winapi_releasestream($pstream)
		EndIf
		If $himage Then
			DllCall("gdiplus.dll", "int", "GdipDisposeImage", "handle", $himage)
		EndIf
		If $htoken Then
			DllCall("gdiplus.dll", "none", "GdiplusShutdown", "ulong_ptr", $htoken)
		EndIf
		If $hsource Then
			_winapi_deleteobject($hsource)
		EndIf
		If $ierror Then Return SetError($ierror, 0, 0)
		Return $ilength
	EndFunc

	Func _winapi_copybitmap($hbitmap)
		$hbitmap = _winapi_copyimage($hbitmap, 0, 0, 0, 8192)
		Return SetError(@error, @extended, $hbitmap)
	EndFunc

	Func _winapi_copyenhmetafile($hemf, $sfilepath = "")
		Local $stypeoffile = "wstr"
		If NOT StringStripWS($sfilepath, $str_stripleading + $str_striptrailing) Then
			$stypeoffile = "ptr"
			$sfilepath = 0
		EndIf
		Local $aret = DllCall("gdi32.dll", "handle", "CopyEnhMetaFileW", "handle", $hemf, $stypeoffile, $sfilepath)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_copyimage($himage, $itype = 0, $ixdesiredpixels = 0, $iydesiredpixels = 0, $iflags = 0)
		Local $aret = DllCall("user32.dll", "handle", "CopyImage", "handle", $himage, "uint", $itype, "int", $ixdesiredpixels, "int", $iydesiredpixels, "uint", $iflags)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_copyrect($trect)
		Local $tdata = DllStructCreate($tagrect)
		Local $aret = DllCall("user32.dll", "bool", "CopyRect", "struct*", $tdata, "struct*", $trect)
		If @error OR NOT $aret[0] Then SetError(@error + 10, @extended, 0)
		Return $tdata
	EndFunc

	Func _winapi_create32bithbitmap($hicon, $bdib = False, $bdelete = False)
		Local $hbitmap = 0
		Local $adib[2] = [0, 0]
		Local $htemp = _winapi_create32bithicon($hicon)
		If @error Then Return SetError(@error, @extended, 0)
		Local $ierror = 0
		Do
			Local $ticoninfo = DllStructCreate($tagiconinfo)
			Local $aret = DllCall("user32.dll", "bool", "GetIconInfo", "handle", $htemp, "struct*", $ticoninfo)
			If @error OR NOT $aret[0] Then
				$ierror = @error + 10
				ExitLoop
			EndIf
			For $i = 0 To 1
				$adib[$i] = DllStructGetData($ticoninfo, $i + 4)
			Next
			Local $tbitmap = DllStructCreate($tagbitmap)
			If NOT _winapi_getobject($adib[0], DllStructGetSize($tbitmap), $tbitmap) Then
				$ierror = @error + 20
				ExitLoop
			EndIf
			If $bdib Then
				$hbitmap = _winapi_createdib(DllStructGetData($tbitmap, "bmWidth"), DllStructGetData($tbitmap, "bmHeight"))
				Local $hdc = _winapi_createcompatibledc(0)
				Local $hsv = _winapi_selectobject($hdc, $hbitmap)
				_winapi_drawiconex($hdc, 0, 0, $htemp)
				_winapi_selectobject($hdc, $hsv)
				_winapi_deletedc($hdc)
			Else
				$hbitmap = $adib[1]
				$adib[1] = 0
			EndIf
		Until 1
		For $i = 0 To 1
			If $adib[$i] Then
				_winapi_deleteobject($adib[$i])
			EndIf
		Next
		_winapi_destroyicon($htemp)
		If $ierror Then Return SetError($ierror, 0, 0)
		If NOT $hbitmap Then Return SetError(12, 0, 0)
		If $bdelete Then
			_winapi_destroyicon($hicon)
		EndIf
		Return $hbitmap
	EndFunc

	Func _winapi_create32bithicon($hicon, $bdelete = False)
		Local $ahbitmap[2], $hresult = 0
		Local $adib[2][2] = [[0, 0], [0, 0]]
		Local $ticoninfo = DllStructCreate($tagiconinfo)
		Local $aret = DllCall("user32.dll", "bool", "GetIconInfo", "handle", $hicon, "struct*", $ticoninfo)
		If @error Then Return SetError(@error, @extended, 0)
		If NOT $aret[0] Then Return SetError(10, 0, 0)
		For $i = 0 To 1
			$ahbitmap[$i] = DllStructGetData($ticoninfo, $i + 4)
		Next
		If _winapi_isalphabitmap($ahbitmap[1]) Then
			$adib[0][0] = _winapi_createandbitmap($ahbitmap[1])
			If NOT @error Then
				$hresult = _winapi_createiconindirect($ahbitmap[1], $adib[0][0])
			EndIf
		Else
			Local $tsize = _winapi_getbitmapdimension($ahbitmap[1])
			Local $asize[2]
			For $i = 0 To 1
				$asize[$i] = DllStructGetData($tsize, $i + 1)
			Next
			Local $hsrcdc = _winapi_createcompatibledc(0)
			Local $hdstdc = _winapi_createcompatibledc(0)
			Local $hsrcsv, $hdstsv
			For $i = 0 To 1
				$adib[$i][0] = _winapi_createdib($asize[0], $asize[1])
				$adib[$i][1] = $__g_vext
				$hsrcsv = _winapi_selectobject($hsrcdc, $ahbitmap[$i])
				$hdstsv = _winapi_selectobject($hdstdc, $adib[$i][0])
				_winapi_bitblt($hdstdc, 0, 0, $asize[0], $asize[1], $hsrcdc, 0, 0, 12583114)
				_winapi_selectobject($hsrcdc, $hsrcsv)
				_winapi_selectobject($hdstdc, $hdstsv)
			Next
			_winapi_deletedc($hsrcdc)
			_winapi_deletedc($hdstdc)
			$aret = DllCall("user32.dll", "lresult", "CallWindowProc", "ptr", __xorproc(), "ptr", 0, "uint", $asize[0] * $asize[1] * 4, "wparam", $adib[0][1], "lparam", $adib[1][1])
			If NOT @error AND $aret[0] Then
				$hresult = _winapi_createiconindirect($adib[1][0], $ahbitmap[0])
			EndIf
		EndIf
		For $i = 0 To 1
			_winapi_deleteobject($ahbitmap[$i])
			If $adib[$i][0] Then
				_winapi_deleteobject($adib[$i][0])
			EndIf
		Next
		If NOT $hresult Then Return SetError(11, 0, 0)
		If $bdelete Then
			_winapi_destroyicon($hicon)
		EndIf
		Return $hresult
	EndFunc

	Func _winapi_createandbitmap($hbitmap)
		Local $ierror = 0, $hdib = 0
		$hbitmap = _winapi_copybitmap($hbitmap)
		If NOT $hbitmap Then Return SetError(@error + 20, @extended, 0)
		Do
			Local $atdib[2]
			$atdib[0] = DllStructCreate($tagdibsection)
			If (NOT _winapi_getobject($hbitmap, DllStructGetSize($atdib[0]), $atdib[0])) OR (DllStructGetData($atdib[0], "bmBitsPixel") <> 32) OR (DllStructGetData($atdib[0], "biCompression")) Then
				$ierror = 10
				ExitLoop
			EndIf
			$atdib[1] = DllStructCreate($tagbitmap)
			$hdib = _winapi_createdib(DllStructGetData($atdib[0], "bmWidth"), DllStructGetData($atdib[0], "bmHeight"), 1)
			If NOT _winapi_getobject($hdib, DllStructGetSize($atdib[1]), $atdib[1]) Then
				$ierror = 11
				ExitLoop
			EndIf
			Local $aret = DllCall("user32.dll", "lresult", "CallWindowProc", "ptr", __andproc(), "ptr", 0, "uint", 0, "wparam", DllStructGetPtr($atdib[0]), "lparam", DllStructGetPtr($atdib[1]))
			If @error Then
				$ierror = @error
				ExitLoop
			EndIf
			If NOT $aret[0] Then
				$ierror = 12
				ExitLoop
			EndIf
			$ierror = 0
		Until 1
		_winapi_deleteobject($hbitmap)
		If $ierror Then
			If $hdib Then
				_winapi_deleteobject($hdib)
			EndIf
			$hdib = 0
		EndIf
		Return SetError($ierror, 0, $hdib)
	EndFunc

	Func _winapi_createbitmapindirect(ByRef $tbitmap)
		Local $aret = DllCall("gdi32.dll", "handle", "CreateBitmapIndirect", "struct*", $tbitmap)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_createbrushindirect($istyle, $irgb, $ihatch = 0)
		Local $tlogbrush = DllStructCreate($taglogbrush)
		DllStructSetData($tlogbrush, 1, $istyle)
		DllStructSetData($tlogbrush, 2, __rgb($irgb))
		DllStructSetData($tlogbrush, 3, $ihatch)
		Local $aret = DllCall("gdi32.dll", "handle", "CreateBrushIndirect", "struct*", $tlogbrush)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_createcoloradjustment($iflags = 0, $iilluminant = 0, $igammar = 10000, $igammag = 10000, $igammab = 10000, $iblack = 0, $iwhite = 10000, $icontrast = 0, $ibrightness = 0, $icolorfulness = 0, $itint = 0)
		Local $tca = DllStructCreate($tagcoloradjustment)
		DllStructSetData($tca, 1, DllStructGetSize($tca))
		DllStructSetData($tca, 2, $iflags)
		DllStructSetData($tca, 3, $iilluminant)
		DllStructSetData($tca, 4, $igammar)
		DllStructSetData($tca, 5, $igammag)
		DllStructSetData($tca, 6, $igammab)
		DllStructSetData($tca, 7, $iblack)
		DllStructSetData($tca, 8, $iwhite)
		DllStructSetData($tca, 9, $icontrast)
		DllStructSetData($tca, 10, $ibrightness)
		DllStructSetData($tca, 11, $icolorfulness)
		DllStructSetData($tca, 12, $itint)
		Return $tca
	EndFunc

	Func _winapi_createcompatiblebitmapex($hdc, $iwidth, $iheight, $irgb)
		Local $hbrush = _winapi_createbrushindirect(0, $irgb)
		Local $aret = DllCall("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $hdc)
		Local $hdestdc = $aret[0]
		$aret = DllCall("gdi32.dll", "handle", "CreateCompatibleBitmap", "handle", $hdc, "int", $iwidth, "int", $iheight)
		Local $hbmp = $aret[0]
		$aret = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdestdc, "handle", $hbmp)
		Local $hdestsv = $aret[0]
		Local $trect = _winapi_createrectex(0, 0, $iwidth, $iheight)
		Local $ierror = 0
		$aret = DllCall("user32.dll", "int", "FillRect", "handle", $hdestdc, "struct*", $trect, "handle", $hbrush)
		If @error OR NOT $aret[0] Then
			$ierror = @error + 10
			_winapi_deleteobject($hbmp)
		EndIf
		_winapi_deleteobject($hbrush)
		DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hdestdc, "handle", $hdestsv)
		DllCall("gdi32.dll", "bool", "DeleteDC", "handle", $hdestdc)
		If $ierror Then Return SetError($ierror, 0, 0)
		Return $hbmp
	EndFunc

	Func _winapi_createdib($iwidth, $iheight, $ibitsperpel = 32, $tcolortable = 0, $icolorcount = 0)
		Local $argbq[2], $icolors, $tagrgbq
		Switch $ibitsperpel
			Case 1
				$icolors = 2
			Case 4
				$icolors = 16
			Case 8
				$icolors = 256
			Case Else
				$icolors = 0
		EndSwitch
		If $icolors Then
			If NOT IsDllStruct($tcolortable) Then
				Switch $ibitsperpel
					Case 1
						$argbq[0] = 0
						$argbq[1] = 16777215
						$tcolortable = _winapi_createdibcolortable($argbq)
					Case Else
				EndSwitch
			Else
				If $icolors > $icolorcount Then
					$icolors = $icolorcount
				EndIf
				If (NOT $icolors) OR ((4 * $icolors) > DllStructGetSize($tcolortable)) Then
					Return SetError(20, 0, 0)
				EndIf
			EndIf
			$tagrgbq = ";dword aRGBQuad[" & $icolors & "]"
		Else
			$tagrgbq = ""
		EndIf
		Local $tbitmapinfo = DllStructCreate($tagbitmapinfoheader & $tagrgbq)
		DllStructSetData($tbitmapinfo, "biSize", 40)
		DllStructSetData($tbitmapinfo, "biWidth", $iwidth)
		DllStructSetData($tbitmapinfo, "biHeight", $iheight)
		DllStructSetData($tbitmapinfo, "biPlanes", 1)
		DllStructSetData($tbitmapinfo, "biBitCount", $ibitsperpel)
		DllStructSetData($tbitmapinfo, "biCompression", 0)
		DllStructSetData($tbitmapinfo, "biSizeImage", 0)
		DllStructSetData($tbitmapinfo, "biXPelsPerMeter", 0)
		DllStructSetData($tbitmapinfo, "biYPelsPerMeter", 0)
		DllStructSetData($tbitmapinfo, "biClrUsed", $icolors)
		DllStructSetData($tbitmapinfo, "biClrImportant", 0)
		If $icolors Then
			If IsDllStruct($tcolortable) Then
				_winapi_movememory(DllStructGetPtr($tbitmapinfo, "aRGBQuad"), $tcolortable, 4 * $icolors)
			Else
				_winapi_zeromemory(DllStructGetPtr($tbitmapinfo, "aRGBQuad"), 4 * $icolors)
			EndIf
		EndIf
		Local $hbitmap = _winapi_createdibsection(0, $tbitmapinfo, 0, $__g_vext)
		If NOT $hbitmap Then Return SetError(@error, @extended, 0)
		Return $hbitmap
	EndFunc

	Func _winapi_createdibcolortable(Const ByRef $acolortable, $istart = 0, $iend = -1)
		If __checkerrorarraybounds($acolortable, $istart, $iend) Then Return SetError(@error + 10, @extended, 0)
		Local $tcolortable = DllStructCreate("dword[" & ($iend - $istart + 1) & "]")
		Local $icount = 1
		For $i = $istart To $iend
			DllStructSetData($tcolortable, 1, _winapi_switchcolor(__rgb($acolortable[$i])), $icount)
			$icount += 1
		Next
		Return $tcolortable
	EndFunc

	Func _winapi_createdibitmap($hdc, ByRef $tbitmapinfo, $iusage, $pbits = 0)
		Local $iinit = 0
		If $pbits Then
			$iinit = 4
		EndIf
		Local $aret = DllCall("gdi32.dll", "handle", "CreateDIBitmap", "handle", $hdc, "struct*", $tbitmapinfo, "dword", $iinit, "struct*", $pbits, "struct*", $tbitmapinfo, "uint", $iusage)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_createdibsection($hdc, $tbitmapinfo, $iusage, ByRef $pbits, $hsection = 0, $ioffset = 0)
		$pbits = 0
		Local $aret = DllCall("gdi32.dll", "handle", "CreateDIBSection", "handle", $hdc, "struct*", $tbitmapinfo, "uint", $iusage, "ptr*", 0, "handle", $hsection, "dword", $ioffset)
		If @error OR NOT $aret[0] Then Return SetError(@error, @extended, 0)
		$pbits = $aret[4]
		Return $aret[0]
	EndFunc

	Func _winapi_createellipticrgn($trect)
		Local $aret = DllCall("gdi32.dll", "handle", "CreateEllipticRgnIndirect", "struct*", $trect)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_createemptyicon($iwidth, $iheight, $ibitsperpel = 32)
		Local $hxor = _winapi_createdib($iwidth, $iheight, $ibitsperpel)
		Local $hand = _winapi_createdib($iwidth, $iheight, 1)
		Local $hdc = _winapi_createcompatibledc(0)
		Local $hsv = _winapi_selectobject($hdc, $hand)
		Local $hbrush = _winapi_createsolidbrush(16777215)
		Local $trect = _winapi_createrect(0, 0, $iwidth, $iheight)
		_winapi_fillrect($hdc, $trect, $hbrush)
		_winapi_deleteobject($hbrush)
		_winapi_selectobject($hdc, $hsv)
		_winapi_deletedc($hdc)
		Local $hicon = _winapi_createiconindirect($hxor, $hand)
		Local $ierror = @error
		If $hxor Then
			_winapi_deleteobject($hxor)
		EndIf
		If $hand Then
			_winapi_deleteobject($hand)
		EndIf
		If NOT $hicon Then Return SetError($ierror + 10, 0, 0)
		Return $hicon
	EndFunc

	Func _winapi_createenhmetafile($hdc = 0, $trect = 0, $bpixels = False, $sfilepath = "", $sdescription = "")
		Local $stypeoffile = "wstr"
		If NOT StringStripWS($sfilepath, $str_stripleading + $str_striptrailing) Then
			$stypeoffile = "ptr"
			$sfilepath = 0
		EndIf
		Local $tdata = 0, $adata = StringSplit($sdescription, "|", $str_nocount)
		If UBound($adata) < 2 Then
			ReDim $adata[2]
			$adata[1] = ""
		EndIf
		For $i = 0 To 1
			$adata[$i] = StringStripWS($adata[$i], $str_stripleading + $str_striptrailing)
		Next
		If ($adata[0]) OR ($adata[1]) Then
			$tdata = _winapi_arraytostruct($adata)
		EndIf
		Local $ixp, $iyp, $ixm, $iym, $href = 0
		If $bpixels AND (IsDllStruct($trect)) Then
			If NOT $hdc Then
				$href = _winapi_getdc(0)
			EndIf
			$ixp = _winapi_getdevicecaps($href, 8)
			$iyp = _winapi_getdevicecaps($href, 10)
			$ixm = _winapi_getdevicecaps($href, 4)
			$iym = _winapi_getdevicecaps($href, 6)
			If $href Then
				_winapi_releasedc(0, $href)
			EndIf
			For $i = 1 To 3 Step 2
				DllStructSetData($trect, $i, Round(DllStructGetData($trect, $i) * $ixm / $ixp * 100))
			Next
			For $i = 2 To 4 Step 2
				DllStructSetData($trect, $i, Round(DllStructGetData($trect, $i) * $iym / $iyp * 100))
			Next
		EndIf
		Local $aret = DllCall("gdi32.dll", "handle", "CreateEnhMetaFileW", "handle", $hdc, $stypeoffile, $sfilepath, "struct*", $trect, "struct*", $tdata)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_createfontex($iheight, $iwidth = 0, $iescapement = 0, $iorientation = 0, $iweight = 400, $bitalic = False, $bunderline = False, $bstrikeout = False, $icharset = 1, $ioutprecision = 0, $iclipprecision = 0, $iquality = 0, $ipitchandfamily = 0, $sfacename = "", $istyle = 0)
		Local $aret = DllCall("gdi32.dll", "handle", "CreateFontW", "int", $iheight, "int", $iwidth, "int", $iescapement, "int", $iorientation, "int", $iweight, "dword", $bitalic, "dword", $bunderline, "dword", $bstrikeout, "dword", $icharset, "dword", $ioutprecision, "dword", $iclipprecision, "dword", $iquality, "dword", $ipitchandfamily, "wstr", _winapi_getfontname($sfacename, $istyle, $icharset))
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_createiconindirect($hbitmap, $hmask, $ixhotspot = 0, $iyhotspot = 0, $bicon = True)
		Local $ticoninfo = DllStructCreate($tagiconinfo)
		DllStructSetData($ticoninfo, 1, $bicon)
		DllStructSetData($ticoninfo, 2, $ixhotspot)
		DllStructSetData($ticoninfo, 3, $iyhotspot)
		DllStructSetData($ticoninfo, 4, $hmask)
		DllStructSetData($ticoninfo, 5, $hbitmap)
		Local $aret = DllCall("user32.dll", "handle", "CreateIconIndirect", "struct*", $ticoninfo)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_createnullrgn()
		Local $aret = DllCall("gdi32.dll", "handle", "CreateRectRgn", "int", 0, "int", 0, "int", 0, "int", 0)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_createpolygonrgn(Const ByRef $apoint, $istart = 0, $iend = -1, $imode = 1)
		If __checkerrorarraybounds($apoint, $istart, $iend, 2, 2) Then Return SetError(@error + 10, @extended, 0)
		Local $tagstruct = ""
		For $i = $istart To $iend
			$tagstruct &= "int[2];"
		Next
		Local $tdata = DllStructCreate($tagstruct)
		Local $icount = 1
		For $i = $istart To $iend
			For $j = 0 To 1
				DllStructSetData($tdata, $icount, $apoint[$i][$j], $j + 1)
			Next
			$icount += 1
		Next
		Local $aret = DllCall("gdi32.dll", "handle", "CreatePolygonRgn", "struct*", $tdata, "int", $icount - 1, "int", $imode)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_createrectrgnindirect($trect)
		Local $aret = DllCall("gdi32.dll", "handle", "CreateRectRgnIndirect", "struct*", $trect)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_createtransform($nm11 = 1, $nm12 = 0, $nm21 = 0, $nm22 = 1, $ndx = 0, $ndy = 0)
		Local $txform = DllStructCreate($tagxform)
		DllStructSetData($txform, 1, $nm11)
		DllStructSetData($txform, 2, $nm12)
		DllStructSetData($txform, 3, $nm21)
		DllStructSetData($txform, 4, $nm22)
		DllStructSetData($txform, 5, $ndx)
		DllStructSetData($txform, 6, $ndy)
		Return $txform
	EndFunc

	Func _winapi_deleteenhmetafile($hemf)
		Local $aret = DllCall("gdi32.dll", "bool", "DeleteEnhMetaFile", "handle", $hemf)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_dptolp($hdc, ByRef $tpoint, $icount = 1)
		Local $aret = DllCall("gdi32.dll", "bool", "DPtoLP", "handle", $hdc, "struct*", $tpoint, "int", $icount)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_drawanimatedrects($hwnd, $trectfrom, $trectto)
		Local $aret = DllCall("user32.dll", "bool", "DrawAnimatedRects", "hwnd", $hwnd, "int", 3, "struct*", $trectfrom, "struct*", $trectto)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_drawbitmap($hdc, $ix, $iy, $hbitmap, $irop = 13369376)
		Local $tobj = DllStructCreate($tagbitmap)
		Local $aret = DllCall("gdi32.dll", "int", "GetObject", "handle", $hbitmap, "int", DllStructGetSize($tobj), "struct*", $tobj)
		If @error OR NOT $aret[0] Then Return SetError(@error + 20, @extended, 0)
		$aret = DllCall("user32.dll", "handle", "GetDC", "hwnd", 0)
		Local $_hdc = $aret[0]
		$aret = DllCall("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $_hdc)
		Local $hsrcdc = $aret[0]
		$aret = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hsrcdc, "handle", $hbitmap)
		Local $hsrcsv = $aret[0]
		Local $ierror = 0
		$aret = DllCall("gdi32.dll", "int", "BitBlt", "hwnd", $hdc, "int", $ix, "int", $iy, "int", DllStructGetData($tobj, "bmWidth"), "int", DllStructGetData($tobj, "bmHeight"), "hwnd", $hsrcdc, "int", 0, "int", 0, "int", $irop)
		If @error OR NOT $aret[0] Then
			$ierror = @error + 1
		EndIf
		DllCall("user32.dll", "int", "ReleaseDC", "hwnd", 0, "handle", $_hdc)
		DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hsrcdc, "handle", $hsrcsv)
		DllCall("gdi32.dll", "bool", "DeleteDC", "handle", $hsrcdc)
		If $ierror Then Return SetError(10, 0, 0)
		Return 1
	EndFunc

	Func _winapi_drawfocusrect($hdc, $trect)
		Local $aret = DllCall("user32.dll", "bool", "DrawFocusRect", "handle", $hdc, "struct*", $trect)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_drawshadowtext($hdc, $stext, $irgbtext, $irgbshadow, $ixoffset = 0, $iyoffset = 0, $trect = 0, $iflags = 0)
		Local $aret
		If NOT IsDllStruct($trect) Then
			$trect = DllStructCreate($tagrect)
			$aret = DllCall("user32.dll", "bool", "GetClientRect", "hwnd", _winapi_windowfromdc($hdc), "struct*", $trect)
			If @error Then Return SetError(@error + 10, @extended, 0)
			If NOT $aret[0] Then Return SetError(10, 0, 0)
		EndIf
		$aret = DllCall("comctl32.dll", "int", "DrawShadowText", "handle", $hdc, "wstr", $stext, "uint", -1, "struct*", $trect, "dword", $iflags, "int", __rgb($irgbtext), "int", __rgb($irgbshadow), "int", $ixoffset, "int", $iyoffset)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_dwmdefwindowproc($hwnd, $imsg, $wparam, $lparam)
		Local $aret = DllCall("dwmapi.dll", "bool", "DwmDefWindowProc", "hwnd", $hwnd, "uint", $imsg, "wparam", $wparam, "lparam", $lparam, "lresult*", 0)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $aret[5]
	EndFunc

	Func _winapi_dwmenableblurbehindwindow($hwnd, $benable = True, $btransition = False, $hrgn = 0)
		Local $tblurbehind = DllStructCreate("dword;bool;handle;bool")
		Local $iflags = 0
		If $hrgn Then
			$iflags += 2
			DllStructSetData($tblurbehind, 3, $hrgn)
		EndIf
		DllStructSetData($tblurbehind, 1, BitOR($iflags, 5))
		DllStructSetData($tblurbehind, 2, $benable)
		DllStructSetData($tblurbehind, 4, $btransition)
		Local $aret = DllCall("dwmapi.dll", "long", "DwmEnableBlurBehindWindow", "hwnd", $hwnd, "struct*", $tblurbehind)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return 1
	EndFunc

	Func _winapi_dwmenablecomposition($benable)
		If $benable Then $benable = 1
		Local $aret = DllCall("dwmapi.dll", "long", "DwmEnableComposition", "uint", $benable)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return 1
	EndFunc

	Func _winapi_dwmextendframeintoclientarea($hwnd, $tmargins = 0)
		If NOT IsDllStruct($tmargins) Then
			$tmargins = _winapi_createmargins(-1, -1, -1, -1)
		EndIf
		Local $aret = DllCall("dwmapi.dll", "long", "DwmExtendFrameIntoClientArea", "hwnd", $hwnd, "struct*", $tmargins)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return 1
	EndFunc

	Func _winapi_dwmgetcolorizationcolor()
		Local $aret = DllCall("dwmapi.dll", "long", "DwmGetColorizationColor", "dword*", 0, "bool*", 0)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return SetExtended($aret[2], $aret[1])
	EndFunc

	Func _winapi_dwmgetcolorizationparameters()
		Local $tdwmcp = DllStructCreate($tagdwm_colorization_parameters)
		Local $aret = DllCall("dwmapi.dll", "uint", 127, "struct*", $tdwmcp)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return $tdwmcp
	EndFunc

	Func _winapi_dwmgetwindowattribute($hwnd, $iattribute)
		Local $tagstruct
		Switch $iattribute
			Case 5, 9
				$tagstruct = $tagrect
			Case 1
				$tagstruct = "uint"
			Case Else
				Return SetError(11, 0, 0)
		EndSwitch
		Local $tdata = DllStructCreate($tagstruct)
		Local $aret = DllCall("dwmapi.dll", "long", "DwmGetWindowAttribute", "hwnd", $hwnd, "dword", $iattribute, "struct*", $tdata, "dword", DllStructGetSize($tdata))
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Switch $iattribute
			Case 1
				Return DllStructGetData($tdata, 1)
			Case Else
				Return $tdata
		EndSwitch
	EndFunc

	Func _winapi_dwminvalidateiconicbitmaps($hwnd)
		Local $aret = DllCall("dwmapi.dll", "long", "DwmInvalidateIconicBitmaps", "hwnd", $hwnd)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return 1
	EndFunc

	Func _winapi_dwmiscompositionenabled()
		Local $aret = DllCall("dwmapi.dll", "long", "DwmIsCompositionEnabled", "bool*", 0)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return $aret[1]
	EndFunc

	Func _winapi_dwmquerythumbnailsourcesize($hthumbnail)
		Local $tsize = DllStructCreate($tagsize)
		Local $aret = DllCall("dwmapi.dll", "long", "DwmQueryThumbnailSourceSize", "handle", $hthumbnail, "struct*", $tsize)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return $tsize
	EndFunc

	Func _winapi_dwmregisterthumbnail($hdestination, $hsource)
		Local $aret = DllCall("dwmapi.dll", "long", "DwmRegisterThumbnail", "hwnd", $hdestination, "hwnd", $hsource, "handle*", 0)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return $aret[3]
	EndFunc

	Func _winapi_dwmsetcolorizationparameters($tdwmcp)
		Local $aret = DllCall("dwmapi.dll", "uint", 131, "struct*", $tdwmcp, "uint", 0)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return 1
	EndFunc

	Func _winapi_dwmseticoniclivepreviewbitmap($hwnd, $hbitmap, $bframe = False, $tclient = 0)
		Local $iflags
		If $bframe Then
			$iflags = 1
		Else
			$iflags = 0
		EndIf
		Local $aret = DllCall("dwmapi.dll", "uint", "DwmSetIconicLivePreviewBitmap", "hwnd", $hwnd, "handle", $hbitmap, "struct*", $tclient, "dword", $iflags)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return 1
	EndFunc

	Func _winapi_dwmseticonicthumbnail($hwnd, $hbitmap, $bframe = False)
		Local $iflags
		If $bframe Then
			$iflags = 1
		Else
			$iflags = 0
		EndIf
		Local $aret = DllCall("dwmapi.dll", "long", "DwmSetIconicThumbnail", "hwnd", $hwnd, "handle", $hbitmap, "dword", $iflags)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return 1
	EndFunc

	Func _winapi_dwmsetwindowattribute($hwnd, $iattribute, $idata)
		Switch $iattribute
			Case 2, 3, 4, 6, 7, 8, 10, 11, 12
			Case Else
				Return SetError(1, 0, 0)
		EndSwitch
		Local $aret = DllCall("dwmapi.dll", "long", "DwmSetWindowAttribute", "hwnd", $hwnd, "dword", $iattribute, "dword*", $idata, "dword", 4)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return 1
	EndFunc

	Func _winapi_dwmunregisterthumbnail($hthumbnail)
		Local $aret = DllCall("dwmapi.dll", "long", "DwmUnregisterThumbnail", "handle", $hthumbnail)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return 1
	EndFunc

	Func _winapi_dwmupdatethumbnailproperties($hthumbnail, $bvisible = True, $bclientareaonly = False, $iopacity = 255, $trectdest = 0, $trectsrc = 0)
		Local Const $tagdwm_thumbnail_properties = "struct;dword dwFlags;int rcDestination[4];int rcSource[4];byte opacity;bool opacity;bool fSourceClientAreaOnly;endstruct"
		Local $tthumbnailproperties = DllStructCreate($tagdwm_thumbnail_properties)
		Local $tsize, $iflags = 0
		If NOT IsDllStruct($trectdest) Then
			$tsize = _winapi_dwmquerythumbnailsourcesize($hthumbnail)
			If @error Then
				Return SetError(@error + 10, @extended, 0)
			EndIf
			$trectdest = _winapi_createrectex(0, 0, DllStructGetData($tsize, 1), DllStructGetData($tsize, 2))
		EndIf
		For $i = 1 To 4
			DllStructSetData($tthumbnailproperties, 2, DllStructGetData($trectdest, $i), $i)
		Next
		If IsDllStruct($trectsrc) Then
			$iflags += 2
			For $i = 1 To 4
				DllStructSetData($tthumbnailproperties, 3, DllStructGetData($trectsrc, $i), $i)
			Next
		EndIf
		DllStructSetData($tthumbnailproperties, 1, BitOR($iflags, 29))
		DllStructSetData($tthumbnailproperties, 4, $iopacity)
		DllStructSetData($tthumbnailproperties, 5, $bvisible)
		DllStructSetData($tthumbnailproperties, 6, $bclientareaonly)
		Local $aret = DllCall("dwmapi.dll", "long", "DwmUpdateThumbnailProperties", "handle", $hthumbnail, "struct*", $tthumbnailproperties)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] Then Return SetError(10, $aret[0], 0)
		Return 1
	EndFunc

	Func _winapi_ellipse($hdc, $trect)
		Local $aret = DllCall("gdi32.dll", "bool", "Ellipse", "handle", $hdc, "int", DllStructGetData($trect, 1), "int", DllStructGetData($trect, 2), "int", DllStructGetData($trect, 3), "int", DllStructGetData($trect, 4))
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_endpaint($hwnd, ByRef $tpaintstruct)
		Local $aret = DllCall("user32.dll", "bool", "EndPaint", "hwnd", $hwnd, "struct*", $tpaintstruct)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_endpath($hdc)
		Local $aret = DllCall("gdi32.dll", "bool", "EndPath", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_enumdisplaymonitors($hdc = 0, $trect = 0)
		Local $henumproc = DllCallbackRegister("__EnumDisplayMonitorsProc", "bool", "handle;handle;ptr;lparam")
		Dim $__g_venum[101][2] = [[0]]
		Local $aret = DllCall("user32.dll", "bool", "EnumDisplayMonitors", "handle", $hdc, "struct*", $trect, "ptr", DllCallbackGetPtr($henumproc), "lparam", 0)
		If @error OR NOT $aret[0] OR NOT $__g_venum[0][0] Then
			$__g_venum = @error + 10
		EndIf
		DllCallbackFree($henumproc)
		If $__g_venum Then Return SetError($__g_venum, 0, 0)
		__inc($__g_venum, -1)
		Return $__g_venum
	EndFunc

	Func _winapi_enumdisplaysettings($sdevice, $imode)
		Local $stypeofdevice = "wstr"
		If NOT StringStripWS($sdevice, $str_stripleading + $str_striptrailing) Then
			$stypeofdevice = "ptr"
			$sdevice = 0
		EndIf
		Local $tdevmode = DllStructCreate($tagdevmode_display)
		DllStructSetData($tdevmode, "Size", DllStructGetSize($tdevmode))
		DllStructSetData($tdevmode, "DriverExtra", 0)
		Local $aret = DllCall("user32.dll", "bool", "EnumDisplaySettingsW", $stypeofdevice, $sdevice, "dword", $imode, "struct*", $tdevmode)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Local $aresult[5]
		$aresult[0] = DllStructGetData($tdevmode, "PelsWidth")
		$aresult[1] = DllStructGetData($tdevmode, "PelsHeight")
		$aresult[2] = DllStructGetData($tdevmode, "BitsPerPel")
		$aresult[3] = DllStructGetData($tdevmode, "DisplayFrequency")
		$aresult[4] = DllStructGetData($tdevmode, "DisplayFlags")
		Return $aresult
	EndFunc

	Func _winapi_enumfontfamilies($hdc = 0, $sfacename = "", $icharset = 1, $ifonttype = 7, $spattern = "", $bexclude = False)
		Local $tlogfont = DllStructCreate($taglogfont)
		Local $tpattern = DllStructCreate("uint;uint;ptr;wchar[" & (StringLen($spattern) + 1) & "]")
		DllStructSetData($tpattern, 1, $ifonttype)
		If NOT $spattern Then
			DllStructSetData($tpattern, 2, 0)
			DllStructSetData($tpattern, 3, 0)
		Else
			DllStructSetData($tpattern, 2, $bexclude)
			DllStructSetData($tpattern, 3, DllStructGetPtr($tpattern, 4))
			DllStructSetData($tpattern, 4, $spattern)
		EndIf
		DllStructSetData($tlogfont, 9, $icharset)
		DllStructSetData($tlogfont, 13, 0)
		DllStructSetData($tlogfont, 14, StringLeft($sfacename, 31))
		Local $hcdc
		If NOT $hdc Then
			$hcdc = _winapi_createcompatibledc(0)
		Else
			$hcdc = $hdc
		EndIf
		Dim $__g_venum[101][8] = [[0]]
		Local $henumproc = DllCallbackRegister("__EnumFontFamiliesProc", "int", "ptr;ptr;dword;PTR")
		Local $aret = DllCall("gdi32.dll", "int", "EnumFontFamiliesExW", "handle", $hcdc, "struct*", $tlogfont, "ptr", DllCallbackGetPtr($henumproc), "struct*", $tpattern, "dword", 0)
		If @error OR NOT $aret[0] OR NOT $__g_venum[0][0] Then
			$__g_venum = @error + 10
		EndIf
		DllCallbackFree($henumproc)
		If NOT $hdc Then
			_winapi_deletedc($hcdc)
		EndIf
		If $__g_venum Then Return SetError($__g_venum, 0, 0)
		__inc($__g_venum, -1)
		Return $__g_venum
	EndFunc

	Func _winapi_equalrect($trect1, $trect2)
		Local $aret = DllCall("user32.dll", "bool", "EqualRect", "struct*", $trect1, "struct*", $trect2)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_equalrgn($hrgn1, $hrgn2)
		Local $aret = DllCall("gdi32.dll", "bool", "EqualRgn", "handle", $hrgn1, "handle", $hrgn2)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_excludecliprect($hdc, $trect)
		Local $aret = DllCall("gdi32.dll", "int", "ExcludeClipRect", "handle", $hdc, "int", DllStructGetData($trect, 1), "int", DllStructGetData($trect, 2), "int", DllStructGetData($trect, 3), "int", DllStructGetData($trect, 4))
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_extcreatepen($ipenstyle, $iwidth, $ibrushstyle, $irgb, $ihatch = 0, $auserstyle = 0, $istart = 0, $iend = -1)
		Local $icount = 0, $tstyle = 0
		If BitAND($ipenstyle, 255) = 7 Then
			If __checkerrorarraybounds($auserstyle, $istart, $iend) Then Return SetError(@error + 10, @extended, 0)
			$tstyle = DllStructCreate("dword[" & ($iend - $istart + 1) & "]")
			For $i = $istart To $iend
				DllStructSetData($tstyle, 1, $auserstyle[$i], $icount + 1)
				$icount += 1
			Next
		EndIf
		Local $tlogbrush = DllStructCreate($taglogbrush)
		DllStructSetData($tlogbrush, 1, $ibrushstyle)
		DllStructSetData($tlogbrush, 2, __rgb($irgb))
		DllStructSetData($tlogbrush, 3, $ihatch)
		Local $aret = DllCall("gdi32.dll", "handle", "ExtCreatePen", "dword", $ipenstyle, "dword", $iwidth, "struct*", $tlogbrush, "dword", $icount, "struct*", $tstyle)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_extcreateregion($trgndata, $txform = 0)
		Local $aret = DllCall("gdi32.dll", "handle", "ExtCreateRegion", "struct*", $txform, "dword", DllStructGetSize($trgndata), "struct*", $trgndata)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_extfloodfill($hdc, $ix, $iy, $irgb, $itype = 0)
		Local $aret = DllCall("gdi32.dll", "bool", "ExtFloodFill", "handle", $hdc, "int", $ix, "int", $iy, "dword", __rgb($irgb), "uint", $itype)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_extselectcliprgn($hdc, $hrgn, $imode = 5)
		Local $aret = DllCall("gdi32.dll", "int", "ExtSelectClipRgn", "handle", $hdc, "handle", $hrgn, "int", $imode)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_fillpath($hdc)
		Local $aret = DllCall("gdi32.dll", "bool", "FillPath", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_fillrgn($hdc, $hrgn, $hbrush)
		Local $aret = DllCall("gdi32.dll", "bool", "FillRgn", "handle", $hdc, "handle", $hrgn, "handle", $hbrush)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_flattenpath($hdc)
		Local $aret = DllCall("gdi32.dll", "bool", "FlattenPath", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_framergn($hdc, $hrgn, $hbrush, $iwidth, $iheight)
		Local $aret = DllCall("gdi32.dll", "bool", "FrameRgn", "handle", $hdc, "handle", $hrgn, "handle", $hbrush, "int", $iwidth, "int", $iheight)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_gdicomment($hdc, $pbuffer, $isize)
		Local $aret = DllCall("gdi32.dll", "bool", "GdiComment", "handle", $hdc, "uint", $isize, "struct*", $pbuffer)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_getarcdirection($hdc)
		Local $aret = DllCall("gdi32.dll", "int", "GetArcDirection", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, 0)
		If ($aret[0] < 1) OR ($aret[0] > 2) Then Return SetError(10, $aret[0], 0)
		Return $aret[0]
	EndFunc

	Func _winapi_getbitmapbits($hbitmap, $isize, $pbits)
		Local $aret = DllCall("gdi32.dll", "long", "GetBitmapBits", "handle", $hbitmap, "long", $isize, "struct*", $pbits)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_getbitmapdimensionex($hbitmap)
		Local $tsize = DllStructCreate($tagsize)
		Local $aret = DllCall("gdi32.dll", "bool", "GetBitmapDimensionEx", "handle", $hbitmap, "struct*", $tsize)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $tsize
	EndFunc

	Func _winapi_getbkcolor($hdc)
		Local $aret = DllCall("gdi32.dll", "dword", "GetBkColor", "handle", $hdc)
		If @error OR ($aret[0] = -1) Then Return SetError(@error, @extended, -1)
		Return __rgb($aret[0])
	EndFunc

	Func _winapi_getboundsrect($hdc, $iflags = 0)
		Local $trect = DllStructCreate($tagrect)
		Local $aret = DllCall("gdi32.dll", "uint", "GetBoundsRect", "handle", $hdc, "struct*", $trect, "uint", $iflags)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return SetExtended($aret[0], $trect)
	EndFunc

	Func _winapi_getbrushorg($hdc)
		Local $tpoint = DllStructCreate($tagpoint)
		Local $aret = DllCall("gdi32.dll", "bool", "GetBrushOrgEx", "handle", $hdc, "struct*", $tpoint)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $tpoint
	EndFunc

	Func _winapi_getbvalue($irgb)
		Return BitShift(BitAND(__rgb($irgb), 16711680), 16)
	EndFunc

	Func _winapi_getclipbox($hdc, ByRef $trect)
		$trect = DllStructCreate($tagrect)
		Local $aret = DllCall("gdi32.dll", "int", "GetClipBox", "handle", $hdc, "struct*", $trect)
		If @error OR NOT $aret[0] Then
			$trect = 0
			Return SetError(@error, @extended, 0)
		EndIf
		Return $aret[0]
	EndFunc

	Func _winapi_getcliprgn($hdc)
		Local $hrgn = _winapi_createrectrgn(0, 0, 0, 0)
		Local $ierror = 0
		Local $aret = DllCall("gdi32.dll", "int", "GetClipRgn", "handle", $hdc, "handle", $hrgn)
		If @error OR ($aret[0] = -1) Then $ierror = @error + 10
		If $ierror OR NOT $aret[0] Then
			_winapi_deleteobject($hrgn)
			$hrgn = 0
		EndIf
		Return SetError($ierror, 0, $hrgn)
	EndFunc

	Func _winapi_getcoloradjustment($hdc)
		Local $tadjustment = DllStructCreate($tagcoloradjustment)
		Local $aret = DllCall("gdi32.dll", "bool", "GetColorAdjustment", "handle", $hdc, "struct*", $tadjustment)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $tadjustment
	EndFunc

	Func _winapi_getcurrentobject($hdc, $itype)
		Local $aret = DllCall("gdi32.dll", "handle", "GetCurrentObject", "handle", $hdc, "uint", $itype)
		If @error OR NOT $aret[0] Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_getcurrentposition($hdc)
		Local $tpoint = DllStructCreate($tagpoint)
		Local $aret = DllCall("gdi32.dll", "int", "GetCurrentPositionEx", "handle", $hdc, "struct*", $tpoint)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $tpoint
	EndFunc

	Func _winapi_getdcex($hwnd, $hrgn, $iflags)
		Local $aret = DllCall("user32.dll", "handle", "GetDCEx", "hwnd", $hwnd, "handle", $hrgn, "dword", $iflags)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_getdevicegammaramp($hdc, ByRef $aramp)
		$aramp = 0
		Local $tdata = DllStructCreate("word[256];word[256];word[256]")
		Local $aret = DllCall("gdi32.dll", "bool", "GetDeviceGammaRamp", "handle", $hdc, "struct*", $tdata)
		If @error OR NOT $aret[0] Then Return SetError(@error, @extended, 0)
		Dim $aramp[256][3]
		For $i = 0 To 2
			For $j = 0 To 255
				$aramp[$j][$i] = DllStructGetData($tdata, $i + 1, $j + 1)
			Next
		Next
		Return 1
	EndFunc

	Func _winapi_getdibcolortable($hbitmap)
		Local $hdc = _winapi_createcompatibledc(0)
		Local $hsv = _winapi_selectobject($hdc, $hbitmap)
		Local $tpeak = DllStructCreate("dword[256]")
		Local $ierror = 0
		Local $aret = DllCall("gdi32.dll", "uint", "GetDIBColorTable", "handle", $hdc, "uint", 0, "uint", 256, "struct*", $tpeak)
		If @error OR NOT $aret[0] Then $ierror = @error + 10
		_winapi_selectobject($hdc, $hsv)
		_winapi_deletedc($hdc)
		If $ierror Then Return SetError($ierror, 0, 0)
		Local $tdata = DllStructCreate("dword[" & $aret[0] & "]")
		If @error Then Return SetError(@error + 20, @extended, 0)
		_winapi_movememory($tdata, $aret[4], 4 * $aret[0])
		Return SetExtended($aret[0], $tdata)
	EndFunc

	Func _winapi_getenhmetafile($sfilepath)
		Local $aret = DllCall("gdi32.dll", "handle", "GetEnhMetaFileW", "wstr", $sfilepath)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_getenhmetafilebits($hemf, ByRef $pbuffer)
		Local $aret = DllCall("gdi32.dll", "uint", "GetEnhMetaFileBits", "handle", $hemf, "uint", 0, "ptr", 0)
		If @error OR NOT $aret[0] Then Return SetError(@error + 50, @extended, 0)
		$pbuffer = __heaprealloc($pbuffer, $aret[0], 1)
		If @error Then Return SetError(@error, @extended, 0)
		$aret = DllCall("gdi32.dll", "uint", "GetEnhMetaFileBits", "handle", $hemf, "uint", $aret[0], "ptr", $pbuffer)
		If NOT $aret[0] Then Return SetError(60, 0, 0)
		Return $aret[2]
	EndFunc

	Func _winapi_getenhmetafiledescription($hemf)
		Local $tdata = DllStructCreate("wchar[4096]")
		Local $aret = DllCall("gdi32.dll", "uint", "GetEnhMetaFileDescriptionW", "handle", $hemf, "uint", 4096, "struct*", $tdata)
		If @error OR ($aret[0] = 4294967295) Then Return SetError(@error + 20, $aret[0], 0)
		If NOT $aret[0] Then Return 0
		Local $adata = _winapi_structtoarray($tdata)
		If @error Then Return SetError(@error, @extended, 0)
		Local $aresult[2]
		For $i = 0 To 1
			If $adata[0] > $i Then
				$aresult[$i] = $adata[$i + 1]
			Else
				$aresult[$i] = ""
			EndIf
		Next
		Return $aresult
	EndFunc

	Func _winapi_getenhmetafiledimension($hemf)
		Local $tenhmetaheader = _winapi_getenhmetafileheader($hemf)
		If @error Then Return SetError(@error, @extended, 0)
		Local $tsize = DllStructCreate($tagsize)
		DllStructSetData($tsize, 1, Round((DllStructGetData($tenhmetaheader, "rcFrame", 3) - DllStructGetData($tenhmetaheader, "rcFrame", 1)) * DllStructGetData($tenhmetaheader, "Device", 1) / DllStructGetData($tenhmetaheader, "Millimeters", 1) / 100))
		DllStructSetData($tsize, 2, Round((DllStructGetData($tenhmetaheader, "rcFrame", 4) - DllStructGetData($tenhmetaheader, "rcFrame", 2)) * DllStructGetData($tenhmetaheader, "Device", 2) / DllStructGetData($tenhmetaheader, "Millimeters", 2) / 100))
		Return $tsize
	EndFunc

	Func _winapi_getenhmetafileheader($hemf)
		Local $tenhmetaheader = DllStructCreate($tagenhmetaheader)
		Local $aret = DllCall("gdi32.dll", "uint", "GetEnhMetaFileHeader", "handle", $hemf, "uint", DllStructGetSize($tenhmetaheader), "struct*", $tenhmetaheader)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return SetExtended($aret[0], $tenhmetaheader)
	EndFunc

	Func _winapi_getfontname($sfacename, $istyle = 0, $icharset = 1)
		If NOT $sfacename Then Return SetError(1, 0, "")
		Local $iflags = 0
		If BitAND($istyle, 1) Then
			$iflags += 32
		EndIf
		If BitAND($istyle, 2) Then
			$iflags += 1
		EndIf
		If NOT $iflags Then
			$iflags = 64
		EndIf
		Local $tlogfont = DllStructCreate($taglogfont)
		DllStructSetData($tlogfont, 9, $icharset)
		DllStructSetData($tlogfont, 13, 0)
		DllStructSetData($tlogfont, 14, StringLeft($sfacename, 31))
		Local $tfn = DllStructCreate("dword;wchar[64]")
		DllStructSetData($tfn, 1, $iflags)
		DllStructSetData($tfn, 2, "")
		Local $hdc = _winapi_createcompatibledc(0)
		Local $henumproc = DllCallbackRegister("__EnumFontStylesProc", "int", "ptr;ptr;dword;lparam")
		Local $sret = ""
		Local $aret = DllCall("gdi32.dll", "int", "EnumFontFamiliesExW", "handle", $hdc, "struct*", $tlogfont, "ptr", DllCallbackGetPtr($henumproc), "struct*", $tfn, "dword", 0)
		If NOT @error AND NOT $aret[0] Then $sret = DllStructGetData($tfn, 2)
		DllCallbackFree($henumproc)
		_winapi_deletedc($hdc)
		If NOT $sret Then Return SetError(2, 0, "")
		Return $sret
	EndFunc

	Func _winapi_getfontresourceinfo($sfont, $bforce = False, $iflag = Default)
		If $iflag = Default Then
			If $bforce Then
				If NOT _winapi_addfontresourceex($sfont, $fr_not_enum) Then Return SetError(@error + 20, @extended, "")
			EndIf
			Local $ierror = 0
			Local $aret = DllCall("gdi32.dll", "bool", "GetFontResourceInfoW", "wstr", $sfont, "dword*", 4096, "wstr", "", "dword", 1)
			If @error OR NOT $aret[0] Then $ierror = @error + 10
			If $bforce Then
				_winapi_removefontresourceex($sfont, $fr_not_enum)
			EndIf
			If $ierror Then Return SetError($ierror, 0, "")
			Return $aret[3]
		Else
			If NOT FileExists($sfont) Then
				$sfont = RegRead("HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders", "Fonts") & "\" & $sfont
				If NOT FileExists($sfont) Then Return SetError(31, 0, "")
			EndIf
			Local Const $hfile = _winapi_createfile($sfont, 2, 2, 2)
			If NOT $hfile Then Return SetError(32, _winapi_getlasterror(), "")
			Local Const $ifile = FileGetSize($sfont)
			Local Const $tbuffer = DllStructCreate("byte[" & $ifile + 1 & "]")
			Local Const $pfile = DllStructGetPtr($tbuffer)
			Local $iread
			_winapi_readfile($hfile, $pfile, $ifile, $iread)
			_winapi_closehandle($hfile)
			Local $sttfname = _winapi_getfontmemoryresourceinfo($pfile, $iflag)
			If @error Then
				If @error = 1 AND $iflag = 4 Then
					$sttfname = _winapi_getfontresourceinfo($sfont, True)
					Return SetError(@error, @extended, $sttfname)
				EndIf
				Return SetError(33, @error, "")
			EndIf
			Return $sttfname
		EndIf
	EndFunc

	Func _winapi_getfontmemoryresourceinfo($pmemory, $iflag = 1)
		Local Const $tagtt_offset_table = "USHORT uMajorVersion;USHORT uMinorVersion;USHORT uNumOfTables;USHORT uSearchRange;USHORT uEntrySelector;USHORT uRangeShift"
		Local Const $tagtt_table_directory = "char szTag[4];ULONG uCheckSum;ULONG uOffset;ULONG uLength"
		Local Const $tagtt_name_table_header = "USHORT uFSelector;USHORT uNRCount;USHORT uStorageOffset"
		Local Const $tagtt_name_record = "USHORT uPlatformID;USHORT uEncodingID;USHORT uLanguageID;USHORT uNameID;USHORT uStringLength;USHORT uStringOffset"
		Local $tttoffsettable = DllStructCreate($tagtt_offset_table, $pmemory)
		Local $inumoftables = _winapi_swapword(DllStructGetData($tttoffsettable, "uNumOfTables"))
		If NOT (_winapi_swapword(DllStructGetData($tttoffsettable, "uMajorVersion")) = 1 AND _winapi_swapword(DllStructGetData($tttoffsettable, "uMinorVersion")) = 0) Then Return SetError(1, 0, "")
		Local $itbldirsize = DllStructGetSize(DllStructCreate($tagtt_table_directory))
		Local $bfound = False, $ioffset, $ttbldir
		For $i = 0 To $inumoftables - 1
			$ttbldir = DllStructCreate($tagtt_table_directory, $pmemory + DllStructGetSize($tttoffsettable) + $i * $itbldirsize)
			If StringLeft(DllStructGetData($ttbldir, "szTag"), 4) = "name" Then
				$bfound = True
				$ioffset = _winapi_swapdword(DllStructGetData($ttbldir, "uOffset"))
				ExitLoop
			EndIf
		Next
		If NOT $bfound Then Return SetError(2, 0, "")
		Local $tntheader = DllStructCreate($tagtt_name_table_header, $pmemory + $ioffset)
		Local $intheadersize = DllStructGetSize($tntheader)
		Local $inrcount = _winapi_swapword(DllStructGetData($tntheader, "uNRCount"))
		Local $istorageoffset = _winapi_swapword(DllStructGetData($tntheader, "uStorageOffset"))
		Local $ittrecordsize = DllStructGetSize(DllStructCreate($tagtt_name_record))
		Local $tresult, $sresult, $istringlength, $istringoffset, $iencodingid, $tttrecord
		For $i = 0 To $inrcount - 1
			$tttrecord = DllStructCreate($tagtt_name_record, $pmemory + $ioffset + $intheadersize + $i * $ittrecordsize)
			If _winapi_swapword($tttrecord.unameid) = $iflag Then
				$istringlength = _winapi_swapword(DllStructGetData($tttrecord, "uStringLength"))
				$istringoffset = _winapi_swapword(DllStructGetData($tttrecord, "uStringOffset"))
				$iencodingid = _winapi_swapword(DllStructGetData($tttrecord, "uEncodingID"))
				Local $swchar = "char"
				If $iencodingid = 1 Then
					$swchar = "word"
					$istringlength = $istringlength / 2
				EndIf
				$tresult = DllStructCreate($swchar & " szTTFName[" & $istringlength & "]", $pmemory + $ioffset + $istringoffset + $istorageoffset)
				If $iencodingid = 1 Then
					$sresult = ""
					For $j = 1 To $istringlength
						$sresult &= ChrW(_winapi_swapword(DllStructGetData($tresult, 1, $j)))
					Next
				Else
					$sresult = $tresult.szttfname
				EndIf
				If StringLen($sresult) > 0 Then ExitLoop
			EndIf
		Next
		Return $sresult
	EndFunc

	Func _winapi_getglyphoutline($hdc, $schar, $iformat, ByRef $pbuffer, $tmat2 = 0)
		Local $tgm = DllStructCreate($tagglyphmetrics)
		Local $aret, $ilength = 0
		If NOT IsDllStruct($tmat2) Then
			$tmat2 = DllStructCreate("short[8]")
			DllStructSetData($tmat2, 1, 1, 2)
			DllStructSetData($tmat2, 1, 1, 8)
		EndIf
		If $iformat Then
			$aret = DllCall("gdi32.dll", "dword", "GetGlyphOutlineW", "handle", $hdc, "uint", AscW($schar), "uint", $iformat, "struct*", $tgm, "dword", 0, "ptr", 0, "struct*", $tmat2)
			If @error OR ($aret[0] = 4294967295) Then Return SetError(@error + 10, @extended, 0)
			$ilength = $aret[0]
			$pbuffer = __heaprealloc($pbuffer, $ilength, 1)
			If @error Then Return SetError(@error + 20, @extended, 0)
		EndIf
		$aret = DllCall("gdi32.dll", "dword", "GetGlyphOutlineW", "handle", $hdc, "uint", AscW($schar), "uint", $iformat, "struct*", $tgm, "dword", $ilength, "ptr", $pbuffer, "struct*", $tmat2)
		If @error Then Return SetError(@error, @extended, 0)
		If $aret[0] = 4294967295 Then Return SetError(10, -1, 0)
		Return SetExtended($ilength, $tgm)
	EndFunc

	Func _winapi_getgraphicsmode($hdc)
		Local $aret = DllCall("gdi32.dll", "int", "GetGraphicsMode", "handle", $hdc)
		If @error OR NOT $aret[0] Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_getgvalue($irgb)
		Return BitShift(BitAND(__rgb($irgb), 65280), 8)
	EndFunc

	Func _winapi_geticondimension($hicon)
		Local $ticoninfo = DllStructCreate($tagiconinfo)
		Local $aret = DllCall("user32.dll", "bool", "GetIconInfo", "handle", $hicon, "struct*", $ticoninfo)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Local $tsize = _winapi_getbitmapdimension(DllStructGetData($ticoninfo, 5))
		For $i = 4 To 5
			_winapi_deleteobject(DllStructGetData($ticoninfo, $i))
		Next
		If NOT IsDllStruct($tsize) Then Return SetError(20, 0, 0)
		Return $tsize
	EndFunc

	Func _winapi_getmapmode($hdc)
		Local $aret = DllCall("gdi32.dll", "int", "GetMapMode", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_getobjecttype($hobject)
		Local $aret = DllCall("gdi32.dll", "dword", "GetObjectType", "handle", $hobject)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_getoutlinetextmetrics($hdc)
		Local $aret = DllCall("gdi32.dll", "uint", "GetOutlineTextMetricsW", "handle", $hdc, "uint", 0, "ptr", 0)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Local $tdata = DllStructCreate("byte[" & $aret[0] & "]")
		Local $toltm = DllStructCreate($tagoutlinetextmetric, DllStructGetPtr($tdata))
		$aret = DllCall("gdi32.dll", "uint", "GetOutlineTextMetricsW", "handle", $hdc, "uint", $aret[0], "struct*", $tdata)
		If NOT $aret[0] Then Return SetError(20, 0, 0)
		Return $toltm
	EndFunc

	Func _winapi_getpixel($hdc, $ix, $iy)
		Local $aret = DllCall("gdi32.dll", "dword", "GetPixel", "handle", $hdc, "int", $ix, "int", $iy)
		If @error OR ($aret[0] = 4294967295) Then Return SetError(@error, @extended, -1)
		Return __rgb($aret[0])
	EndFunc

	Func _winapi_getpolyfillmode($hdc)
		Local $aret = DllCall("gdi32.dll", "int", "GetPolyFillMode", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_getposfromrect($trect)
		Local $aresult[4]
		For $i = 0 To 3
			$aresult[$i] = DllStructGetData($trect, $i + 1)
			If @error Then Return SetError(@error, @extended, 0)
		Next
		For $i = 2 To 3
			$aresult[$i] -= $aresult[$i - 2]
		Next
		Return $aresult
	EndFunc

	Func _winapi_getregiondata($hrgn, ByRef $trgndata)
		Local $aret = DllCall("gdi32.dll", "dword", "GetRegionData", "handle", $hrgn, "dword", 0, "ptr", 0)
		If @error OR NOT $aret[0] Then
			$trgndata = 0
			Return SetError(@error, @extended, False)
		EndIf
		$trgndata = DllStructCreate($tagrgndataheader)
		Local $irectsize = $aret[0] - DllStructGetSize($trgndata)
		If $irectsize > 0 Then $trgndata = DllStructCreate($tagrgndataheader & ";byte[" & $irectsize & "]")
		$aret = DllCall("gdi32.dll", "dword", "GetRegionData", "handle", $hrgn, "dword", $aret[0], "struct*", $trgndata)
		If NOT $aret[0] Then $trgndata = 0
		Return $aret[0]
	EndFunc

	Func _winapi_getrgnbox($hrgn, ByRef $trect)
		$trect = DllStructCreate($tagrect)
		Local $aret = DllCall("gdi32.dll", "int", "GetRgnBox", "handle", $hrgn, "struct*", $trect)
		If @error OR NOT $aret[0] Then
			$trect = 0
			Return SetError(@error, @extended, 0)
		EndIf
		Return $aret[0]
	EndFunc

	Func _winapi_getrop2($hdc)
		Local $aret = DllCall("gdi32.dll", "int", "GetROP2", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_getrvalue($irgb)
		Return BitAND(__rgb($irgb), 255)
	EndFunc

	Func _winapi_getstretchbltmode($hdc)
		Local $aret = DllCall("gdi32.dll", "int", "GetStretchBltMode", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_gettabbedtextextent($hdc, $stext, $atab = 0, $istart = 0, $iend = -1)
		Local $itab, $icount
		If NOT IsArray($atab) Then
			If $atab Then
				$itab = $atab
				Dim $atab[1] = [$itab]
				$istart = 0
				$iend = 0
				$icount = 1
			Else
				$icount = 0
			EndIf
		Else
			$icount = 1
		EndIf
		Local $ttab = 0
		If $icount Then
			If __checkerrorarraybounds($atab, $istart, $iend) Then Return SetError(@error + 10, @extended, 0)
			$icount = $iend - $istart + 1
			$ttab = DllStructCreate("uint[" & $icount & "]")
			$itab = 1
			For $i = $istart To $iend
				DllStructSetData($ttab, 1, $atab[$i], $itab)
				$itab += 1
			Next
		EndIf
		Local $aret = DllCall("user32.dll", "dword", "GetTabbedTextExtentW", "handle", $hdc, "wstr", $stext, "int", StringLen($stext), "int", $icount, "struct*", $ttab)
		If @error OR NOT $aret[0] Then Return SetError(@error + 20, @extended, 0)
		Return _winapi_createsize(_winapi_loword($aret[0]), _winapi_hiword($aret[0]))
	EndFunc

	Func _winapi_gettextalign($hdc)
		Local $aret = DllCall("gdi32.dll", "uint", "GetTextAlign", "handle", $hdc)
		If @error OR ($aret[0] = 4294967295) Then Return SetError(@error, @extended, -1)
		Return $aret[0]
	EndFunc

	Func _winapi_gettextcharacterextra($hdc)
		Local $aret = DllCall("gdi32.dll", "int", "GetTextCharacterExtra", "handle", $hdc)
		If @error OR ($aret[0] = 134217728) Then Return SetError(@error, @extended, -1)
		Return $aret[0]
	EndFunc

	Func _winapi_gettextcolor($hdc)
		Local $aret = DllCall("gdi32.dll", "dword", "GetTextColor", "handle", $hdc)
		If @error OR ($aret[0] = 4294967295) Then Return SetError(@error, @extended, -1)
		Return __rgb($aret[0])
	EndFunc

	Func _winapi_gettextface($hdc)
		Local $aret = DllCall("gdi32.dll", "int", "GetTextFaceW", "handle", $hdc, "int", 2048, "wstr", "")
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, "")
		Return $aret[3]
	EndFunc

	Func _winapi_getudfcolormode()
		Return Number($__g_irgbmode)
	EndFunc

	Func _winapi_getupdaterect($hwnd, $berase = True)
		Local $trect = DllStructCreate($tagrect)
		Local $aret = DllCall("user32.dll", "bool", "GetUpdateRect", "hwnd", $hwnd, "struct*", $trect, "bool", $berase)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $trect
	EndFunc

	Func _winapi_getupdatergn($hwnd, $hrgn, $berase = True)
		Local $aret = DllCall("user32.dll", "int", "GetUpdateRgn", "hwnd", $hwnd, "handle", $hrgn, "bool", $berase)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_getwindowext($hdc)
		Local $tsize = DllStructCreate($tagsize)
		Local $aret = DllCall("gdi32.dll", "bool", "GetWindowExtEx", "handle", $hdc, "struct*", $tsize)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $tsize
	EndFunc

	Func _winapi_getwindoworg($hdc)
		Local $tpoint = DllStructCreate($tagpoint)
		Local $aret = DllCall("gdi32.dll", "bool", "GetWindowOrgEx", "handle", $hdc, "struct*", $tpoint)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $tpoint
	EndFunc

	Func _winapi_getwindowrgnbox($hwnd, ByRef $trect)
		$trect = DllStructCreate($tagrect)
		Local $aret = DllCall("gdi32.dll", "int", "GetWindowRgnBox", "hwnd", $hwnd, "struct*", $trect)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_getworldtransform($hdc)
		Local $txform = DllStructCreate($tagxform)
		Local $aret = DllCall("gdi32.dll", "bool", "GetWorldTransform", "handle", $hdc, "struct*", $txform)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $txform
	EndFunc

	Func _winapi_gradientfill($hdc, Const ByRef $avertex, $istart = 0, $iend = -1, $brotate = False)
		If __checkerrorarraybounds($avertex, $istart, $iend, 2) Then Return SetError(@error + 10, @extended, 0)
		If UBound($avertex, $ubound_columns) < 3 Then Return SetError(13, 0, 0)
		Local $ipoint = $iend - $istart + 1
		If $ipoint > 3 Then
			$iend = $istart + 2
			$ipoint = 3
		EndIf
		Local $imode
		Switch $ipoint
			Case 2
				$imode = Number(NOT $brotate)
			Case 3
				$imode = 2
			Case Else
				Return SetError(15, 0, 0)
		EndSwitch
		Local $tagstruct = ""
		For $i = $istart To $iend
			$tagstruct &= "ushort[8];"
		Next
		Local $tvertex = DllStructCreate($tagstruct)
		Local $icount = 1
		Local $tgradient = DllStructCreate("ulong[" & $ipoint & "]")
		For $i = $istart To $iend
			DllStructSetData($tgradient, 1, $icount - 1, $icount)
			DllStructSetData($tvertex, $icount, _winapi_loword($avertex[$i][0]), 1)
			DllStructSetData($tvertex, $icount, _winapi_hiword($avertex[$i][0]), 2)
			DllStructSetData($tvertex, $icount, _winapi_loword($avertex[$i][1]), 3)
			DllStructSetData($tvertex, $icount, _winapi_hiword($avertex[$i][1]), 4)
			DllStructSetData($tvertex, $icount, BitShift(_winapi_getrvalue($avertex[$i][2]), -8), 5)
			DllStructSetData($tvertex, $icount, BitShift(_winapi_getgvalue($avertex[$i][2]), -8), 6)
			DllStructSetData($tvertex, $icount, BitShift(_winapi_getbvalue($avertex[$i][2]), -8), 7)
			DllStructSetData($tvertex, $icount, 0, 8)
			$icount += 1
		Next
		Local $aret = DllCall("gdi32.dll", "bool", "GdiGradientFill", "handle", $hdc, "struct*", $tvertex, "ulong", $ipoint, "struct*", $tgradient, "ulong", 1, "ulong", $imode)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_inflaterect(ByRef $trect, $idx, $idy)
		Local $aret = DllCall("user32.dll", "bool", "InflateRect", "struct*", $trect, "int", $idx, "int", $idy)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_intersectcliprect($hdc, $trect)
		Local $aret = DllCall("gdi32.dll", "int", "IntersectClipRect", "handle", $hdc, "int", DllStructGetData($trect, 1), "int", DllStructGetData($trect, 2), "int", DllStructGetData($trect, 3), "int", DllStructGetData($trect, 4))
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_intersectrect($trect1, $trect2)
		Local $trect = DllStructCreate($tagrect)
		Local $aret = DllCall("user32.dll", "bool", "IntersectRect", "struct*", $trect, "struct*", $trect1, "struct*", $trect2)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $trect
	EndFunc

	Func _winapi_invalidatergn($hwnd, $hrgn = 0, $berase = True)
		Local $aret = DllCall("user32.dll", "bool", "InvalidateRgn", "hwnd", $hwnd, "handle", $hrgn, "bool", $berase)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_invertandbitmap($hbitmap, $bdelete = False)
		Local $tbitmap = DllStructCreate($tagbitmap)
		If NOT _winapi_getobject($hbitmap, DllStructGetSize($tbitmap), $tbitmap) OR (DllStructGetData($tbitmap, "bmBitsPixel") <> 1) Then
			Return SetError(@error + 10, @extended, 0)
		EndIf
		Local $hresult = _winapi_createdib(DllStructGetData($tbitmap, "bmWidth"), DllStructGetData($tbitmap, "bmHeight"), 1)
		If NOT $hresult Then Return SetError(@error, @extended, 0)
		Local $hsrcdc = _winapi_createcompatibledc(0)
		Local $hsrcsv = _winapi_selectobject($hsrcdc, $hbitmap)
		Local $hdstdc = _winapi_createcompatibledc(0)
		Local $hdstsv = _winapi_selectobject($hdstdc, $hresult)
		_winapi_bitblt($hdstdc, 0, 0, DllStructGetData($tbitmap, "bmWidth"), DllStructGetData($tbitmap, "bmHeight"), $hsrcdc, 0, 0, 3342344)
		_winapi_selectobject($hsrcdc, $hsrcsv)
		_winapi_deletedc($hsrcdc)
		_winapi_selectobject($hdstdc, $hdstsv)
		_winapi_deletedc($hdstdc)
		If $bdelete Then
			_winapi_deleteobject($hbitmap)
		EndIf
		Return $hresult
	EndFunc

	Func _winapi_invertcolor($icolor)
		If $icolor = -1 Then Return 0
		Return 16777215 - BitAND($icolor, 16777215)
	EndFunc

	Func _winapi_invertrect($hdc, ByRef $trect)
		Local $aret = DllCall("user32.dll", "bool", "InvertRect", "handle", $hdc, "struct*", $trect)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_invertrgn($hdc, $hrgn)
		Local $aret = DllCall("gdi32.dll", "bool", "InvertRgn", "handle", $hdc, "handle", $hrgn)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_isalphabitmap($hbitmap)
		$hbitmap = _winapi_copybitmap($hbitmap)
		If NOT $hbitmap Then Return SetError(@error + 20, @extended, 0)
		Local $aret, $ierror = 0
		Do
			Local $tdib = DllStructCreate($tagdibsection)
			If (NOT _winapi_getobject($hbitmap, DllStructGetSize($tdib), $tdib)) OR (DllStructGetData($tdib, "bmBitsPixel") <> 32) OR (DllStructGetData($tdib, "biCompression")) Then
				$ierror = 1
				ExitLoop
			EndIf
			$aret = DllCall("user32.dll", "int", "CallWindowProc", "ptr", __alphaproc(), "ptr", 0, "uint", 0, "struct*", $tdib, "ptr", 0)
			If @error OR ($aret[0] = -1) Then
				$ierror = @error + 10
				ExitLoop
			EndIf
		Until 1
		_winapi_deleteobject($hbitmap)
		If $ierror Then Return SetError($ierror, 0, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_isrectempty(ByRef $trect)
		Local $aret = DllCall("user32.dll", "bool", "IsRectEmpty", "struct*", $trect)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_linedda($ix1, $iy1, $ix2, $iy2, $plineproc, $pdata = 0)
		Local $aret = DllCall("gdi32.dll", "bool", "LineDDA", "int", $ix1, "int", $iy1, "int", $ix2, "int", $iy2, "ptr", $plineproc, "lparam", $pdata)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_lockwindowupdate($hwnd)
		Local $aret = DllCall("user32.dll", "bool", "LockWindowUpdate", "hwnd", $hwnd)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_lptodp($hdc, ByRef $tpoint, $icount = 1)
		Local $aret = DllCall("gdi32.dll", "bool", "LPtoDP", "handle", $hdc, "struct*", $tpoint, "int", $icount)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_maskblt($hdestdc, $ixdest, $iydest, $iwidth, $iheight, $hsrcdc, $ixsrc, $iysrc, $hmask, $ixmask, $iymask, $irop)
		Local $aret = DllCall("gdi32.dll", "bool", "MaskBlt", "handle", $hdestdc, "int", $ixdest, "int", $iydest, "int", $iwidth, "int", $iheight, "hwnd", $hsrcdc, "int", $ixsrc, "int", $iysrc, "handle", $hmask, "int", $ixmask, "int", $iymask, "dword", $irop)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_modifyworldtransform($hdc, ByRef $txform, $imode)
		Local $aret = DllCall("gdi32.dll", "bool", "ModifyWorldTransform", "handle", $hdc, "struct*", $txform, "dword", $imode)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_monitorfrompoint(ByRef $tpoint, $iflag = 1)
		If DllStructGetSize($tpoint) <> 8 Then Return SetError(@error + 10, @extended, 0)
		Local $aret = DllCall("user32.dll", "handle", "MonitorFromPoint", "struct", $tpoint, "dword", $iflag)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_monitorfromrect(ByRef $trect, $iflag = 1)
		Local $aret = DllCall("user32.dll", "ptr", "MonitorFromRect", "struct*", $trect, "dword", $iflag)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_monitorfromwindow($hwnd, $iflag = 1)
		Local $aret = DllCall("user32.dll", "handle", "MonitorFromWindow", "hwnd", $hwnd, "dword", $iflag)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_movetoex($hdc, $ix, $iy)
		Local $tpoint = DllStructCreate($tagpoint)
		Local $aret = DllCall("gdi32.dll", "bool", "MoveToEx", "handle", $hdc, "int", $ix, "int", $iy, "struct*", $tpoint)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $tpoint
	EndFunc

	Func _winapi_offsetcliprgn($hdc, $ixoffset, $iyoffset)
		Local $aret = DllCall("gdi32.dll", "int", "OffsetClipRgn", "handle", $hdc, "int", $ixoffset, "int", $iyoffset)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_offsetpoints(ByRef $apoint, $ixoffset, $iyoffset, $istart = 0, $iend = -1)
		If __checkerrorarraybounds($apoint, $istart, $iend, 2) Then Return SetError(@error + 10, @extended, 0)
		If UBound($apoint, $ubound_columns) < 2 Then Return SetError(13, 0, 0)
		For $i = $istart To $iend
			$apoint[$i][0] += $ixoffset
			$apoint[$i][1] += $iyoffset
		Next
		Return 1
	EndFunc

	Func _winapi_offsetrect(ByRef $trect, $idx, $idy)
		Local $aret = DllCall("user32.dll", "bool", "OffsetRect", "struct*", $trect, "int", $idx, "int", $idy)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_offsetrgn($hrgn, $ixoffset, $iyoffset)
		Local $aret = DllCall("gdi32.dll", "int", "OffsetRgn", "handle", $hrgn, "int", $ixoffset, "int", $iyoffset)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_offsetwindoworg($hdc, $ixoffset, $iyoffset)
		$__g_vext = DllStructCreate($tagpoint)
		Local $aret = DllCall("gdi32.dll", "bool", "OffsetWindowOrgEx", "handle", $hdc, "int", $ixoffset, "int", $iyoffset, "struct*", $__g_vext)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_paintdesktop($hdc)
		Local $aret = DllCall("user32.dll", "bool", "PaintDesktop", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_paintrgn($hdc, $hrgn)
		Local $aret = DllCall("gdi32.dll", "bool", "PaintRgn", "handle", $hdc, "handle", $hrgn)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_patblt($hdc, $ix, $iy, $iwidth, $iheight, $irop)
		Local $aret = DllCall("gdi32.dll", "bool", "PatBlt", "handle", $hdc, "int", $ix, "int", $iy, "int", $iwidth, "int", $iheight, "dword", $irop)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_pathtoregion($hdc)
		Local $aret = DllCall("gdi32.dll", "handle", "PathToRegion", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_playenhmetafile($hdc, $hemf, ByRef $trect)
		Local $aret = DllCall("gdi32.dll", "bool", "PlayEnhMetaFile", "handle", $hdc, "handle", $hemf, "struct*", $trect)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_plgblt($hdestdc, Const ByRef $apoint, $hsrcdc, $ixsrc, $iysrc, $iwidth, $iheight, $hmask = 0, $ixmask = 0, $iymask = 0)
		If (UBound($apoint) < 3) OR (UBound($apoint, $ubound_columns) < 2) Then Return SetError(12, 0, False)
		Local $tpoints = DllStructCreate("long[2];long[2];long[2]")
		For $i = 0 To 2
			For $j = 0 To 1
				DllStructSetData($tpoints, $i + 1, $apoint[$i][$j], $j + 1)
			Next
		Next
		Local $aret = DllCall("gdi32.dll", "bool", "PlgBlt", "handle", $hdestdc, "struct*", $tpoints, "handle", $hsrcdc, "int", $ixsrc, "int", $iysrc, "int", $iwidth, "int", $iheight, "handle", $hmask, "int", $ixmask, "int", $iymask)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_polybezier($hdc, Const ByRef $apoint, $istart = 0, $iend = -1)
		If __checkerrorarraybounds($apoint, $istart, $iend, 2, 2) Then Return SetError(@error + 10, @extended, False)
		Local $ipoint = 1 + 3 * Floor(($iend - $istart) / 3)
		If $ipoint < 1 Then Return SetError(15, 0, False)
		$iend = $istart + $ipoint - 1
		Local $tagstruct = ""
		For $i = $istart To $iend
			$tagstruct &= "long[2];"
		Next
		Local $tpoint = DllStructCreate($tagstruct)
		Local $icount = 0
		For $i = $istart To $iend
			$icount += 1
			For $j = 0 To 1
				DllStructSetData($tpoint, $icount, $apoint[$i][$j], $j + 1)
			Next
		Next
		Local $aret = DllCall("gdi32.dll", "bool", "PolyBezier", "handle", $hdc, "struct*", $tpoint, "dword", $ipoint)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_polybezierto($hdc, Const ByRef $apoint, $istart = 0, $iend = -1)
		If __checkerrorarraybounds($apoint, $istart, $iend, 2, 2) Then Return SetError(@error + 10, @extended, False)
		Local $ipoint = 3 * Floor(($iend - $istart + 1) / 3)
		If $ipoint < 3 Then Return SetError(15, 0, False)
		$iend = $istart + $ipoint - 1
		Local $tagstruct = ""
		For $i = $istart To $iend
			$tagstruct &= "long[2];"
		Next
		Local $tpoint = DllStructCreate($tagstruct)
		Local $icount = 0
		For $i = $istart To $iend
			$icount += 1
			For $j = 0 To 1
				DllStructSetData($tpoint, $icount, $apoint[$i][$j], $j + 1)
			Next
		Next
		Local $aret = DllCall("gdi32.dll", "bool", "PolyBezierTo", "handle", $hdc, "struct*", $tpoint, "dword", $ipoint)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_polydraw($hdc, Const ByRef $apoint, $istart = 0, $iend = -1)
		If __checkerrorarraybounds($apoint, $istart, $iend, 2) Then Return SetError(@error + 10, @extended, 0)
		If UBound($apoint, $ubound_columns) < 3 Then Return SetError(13, 0, False)
		Local $ipoint = $iend - $istart + 1
		Local $tagstruct = ""
		For $i = $istart To $iend
			$tagstruct &= "long[2];"
		Next
		Local $tpoint = DllStructCreate($tagstruct)
		Local $ttypes = DllStructCreate("byte[" & $ipoint & "]")
		Local $icount = 0
		For $i = $istart To $iend
			$icount += 1
			For $j = 0 To 1
				DllStructSetData($tpoint, $icount, $apoint[$i][$j], $j + 1)
			Next
			DllStructSetData($ttypes, 1, $apoint[$i][2], $icount)
		Next
		Local $aret = DllCall("gdi32.dll", "bool", "PolyDraw", "handle", $hdc, "struct*", $tpoint, "struct*", $ttypes, "dword", $ipoint)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_polygon($hdc, Const ByRef $apoint, $istart = 0, $iend = -1)
		If __checkerrorarraybounds($apoint, $istart, $iend, 2, 2) Then Return SetError(@error + 10, @extended, False)
		Local $tagstruct = ""
		For $i = $istart To $iend
			$tagstruct &= "int[2];"
		Next
		Local $tdata = DllStructCreate($tagstruct)
		Local $icount = 1
		For $i = $istart To $iend
			For $j = 0 To 1
				DllStructSetData($tdata, $icount, $apoint[$i][$j], $j + 1)
			Next
			$icount += 1
		Next
		Local $aret = DllCall("gdi32.dll", "bool", "Polygon", "handle", $hdc, "struct*", $tdata, "int", $icount - 1)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_printwindow($hwnd, $hdc, $bclient = False)
		Local $aret = DllCall("user32.dll", "bool", "PrintWindow", "hwnd", $hwnd, "handle", $hdc, "uint", $bclient)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_ptinrectex($ix, $iy, $ileft, $itop, $iright, $ibottom)
		Local $trect = _winapi_createrect($ileft, $itop, $iright, $ibottom)
		Local $tpoint = _winapi_createpoint($ix, $iy)
		Local $aret = DllCall("user32.dll", "bool", "PtInRect", "struct*", $trect, "struct", $tpoint)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_ptinregion($hrgn, $ix, $iy)
		Local $aret = DllCall("gdi32.dll", "bool", "PtInRegion", "handle", $hrgn, "int", $ix, "int", $iy)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_ptvisible($hdc, $ix, $iy)
		Local $aret = DllCall("gdi32.dll", "bool", "PtVisible", "handle", $hdc, "int", $ix, "int", $iy)
		If @error Then Return SetError(@error + 10, @extended, 0)
		If $aret[0] = -1 Then Return SetError(10, $aret[0], 0)
		Return $aret[0]
	EndFunc

	Func _winapi_radialgradientfill($hdc, $ix, $iy, $iradius, $irgb1, $irgb2, $fanglestart = 0, $fangleend = 360, $fstep = 5)
		If Abs($fanglestart) > 360 Then
			$fanglestart = Mod($fanglestart, 360)
		EndIf
		If Abs($fangleend) > 360 Then
			$fangleend = Mod($fangleend, 360)
		EndIf
		If ($fanglestart < 0) OR ($fangleend < 0) Then
			$fanglestart += 360
			$fangleend += 360
		EndIf
		If $fanglestart > $fangleend Then
			Local $fval = $fanglestart
			$fanglestart = $fangleend
			$fangleend = $fval
		EndIf
		If $fstep < 1 Then
			$fstep = 1
		EndIf
		Local $fki = ATan(1) / 45
		Local $ixp = Round($ix + $iradius * Cos($fki * $fanglestart))
		Local $iyp = Round($iy + $iradius * Sin($fki * $fanglestart))
		Local $ixn, $iyn, $fan = $fanglestart
		Local $avertex[3][3]
		While $fan < $fangleend
			$fan += $fstep
			If $fan > $fangleend Then
				$fan = $fangleend
			EndIf
			$ixn = Round($ix + $iradius * Cos($fki * $fan))
			$iyn = Round($iy + $iradius * Sin($fki * $fan))
			$avertex[0][0] = $ix
			$avertex[0][1] = $iy
			$avertex[0][2] = $irgb1
			$avertex[1][0] = $ixp
			$avertex[1][1] = $iyp
			$avertex[1][2] = $irgb2
			$avertex[2][0] = $ixn
			$avertex[2][1] = $iyn
			$avertex[2][2] = $irgb2
			If NOT _winapi_gradientfill($hdc, $avertex, 0, 2) Then
				Return SetError(@error, @extended, 0)
			EndIf
			$ixp = $ixn
			$iyp = $iyn
		WEnd
		Return 1
	EndFunc

	Func _winapi_rectangle($hdc, $trect)
		Local $aret = DllCall("gdi32.dll", "bool", "Rectangle", "handle", $hdc, "int", DllStructGetData($trect, 1), "int", DllStructGetData($trect, 2), "int", DllStructGetData($trect, 3), "int", DllStructGetData($trect, 4))
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_rectinregion($hrgn, $trect)
		Local $aret = DllCall("gdi32.dll", "bool", "RectInRegion", "handle", $hrgn, "struct*", $trect)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_rectvisible($hdc, $trect)
		Local $aret = DllCall("gdi32.dll", "bool", "RectVisible", "handle", $hdc, "struct*", $trect)
		If @error Then Return SetError(@error, @extended, 0)
		Switch $aret[0]
			Case 0, 1, 2
			Case Else
				Return SetError(10, $aret[0], 0)
		EndSwitch
		Return $aret[0]
	EndFunc

	Func _winapi_removefontmemresourceex($hfont)
		Local $aret = DllCall("gdi32.dll", "bool", "RemoveFontMemResourceEx", "handle", $hfont)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_removefontresourceex($sfont, $iflag = 0, $bnotify = False)
		Local $aret = DllCall("gdi32.dll", "bool", "RemoveFontResourceExW", "wstr", $sfont, "dword", $iflag, "ptr", 0)
		If @error OR NOT $aret[0] Then Return SetError(@error, @extended, False)
		If $bnotify Then
			Local Const $wm_fontchange = 29
			Local Const $hwnd_broadcast = 65535
			DllCall("user32.dll", "none", "SendMessage", "hwnd", $hwnd_broadcast, "uint", $wm_fontchange, "wparam", 0, "lparam", 0)
		EndIf
		Return $aret[0]
	EndFunc

	Func _winapi_restoredc($hdc, $iid)
		Local $aret = DllCall("gdi32.dll", "bool", "RestoreDC", "handle", $hdc, "int", $iid)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_rgb($ired, $igreen, $iblue)
		Return __rgb(BitOR(BitShift($iblue, -16), BitShift($igreen, -8), $ired))
	EndFunc

	Func _winapi_rotatepoints(ByRef $apoint, $ixc, $iyc, $fangle, $istart = 0, $iend = -1)
		If __checkerrorarraybounds($apoint, $istart, $iend, 2) Then Return SetError(@error + 10, @extended, 0)
		If UBound($apoint, $ubound_columns) < 2 Then Return SetError(13, 0, 0)
		Local $fcos = Cos(ATan(1) / 45 * $fangle)
		Local $fsin = Sin(ATan(1) / 45 * $fangle)
		Local $ixn, $iyn
		For $i = $istart To $iend
			$ixn = $apoint[$i][0] - $ixc
			$iyn = $apoint[$i][1] - $iyc
			$apoint[$i][0] = $ixc + Round($ixn * $fcos - $iyn * $fsin)
			$apoint[$i][1] = $iyc + Round($ixn * $fsin + $iyn * $fcos)
		Next
		Return 1
	EndFunc

	Func _winapi_roundrect($hdc, $trect, $iwidth, $iheight)
		Local $aret = DllCall("gdi32.dll", "bool", "RoundRect", "handle", $hdc, "int", DllStructGetData($trect, 1), "int", DllStructGetData($trect, 2), "int", DllStructGetData($trect, 3), "int", DllStructGetData($trect, 4), "int", $iwidth, "int", $iheight)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_savedc($hdc)
		Local $aret = DllCall("gdi32.dll", "int", "SaveDC", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_savehbitmaptofile($sfilepath, $hbitmap, $ixpelspermeter = Default, $iypelspermeter = Default)
		Local $tbmp = DllStructCreate("align 1;ushort bfType;dword bfSize;ushort bfReserved1;ushort bfReserved2;dword bfOffset")
		Local $tdib = DllStructCreate($tagdibsection)
		Local $hdc, $hsv, $hsource = 0
		While $hbitmap
			If (NOT _winapi_getobject($hbitmap, DllStructGetSize($tdib), $tdib)) OR (DllStructGetData($tdib, "biCompression")) Then
				$hbitmap = 0
			Else
				Switch DllStructGetData($tdib, "bmBitsPixel")
					Case 32
						If NOT _winapi_isalphabitmap($hbitmap) Then
							If NOT $hsource Then
								$hsource = _winapi_createdib(DllStructGetData($tdib, "bmWidth"), DllStructGetData($tdib, "bmHeight"), 24)
								If NOT $hsource Then
									$hbitmap = 0
								EndIf
								$hdc = _winapi_createcompatibledc(0)
								$hsv = _winapi_selectobject($hdc, $hsource)
								If _winapi_drawbitmap($hdc, 0, 0, $hbitmap) Then
									$hbitmap = $hsource
								Else
									$hbitmap = 0
								EndIf
								_winapi_selectobject($hdc, $hsv)
								_winapi_deletedc($hdc)
							Else
								$hbitmap = 0
							EndIf
							ContinueLoop
						EndIf
					Case Else
				EndSwitch
				If (NOT DllStructGetData($tdib, "bmBits")) OR (NOT DllStructGetData($tdib, "biSizeImage")) Then
					If NOT $hsource Then
						$hbitmap = _winapi_copybitmap($hbitmap)
						$hsource = $hbitmap
					Else
						$hbitmap = 0
					EndIf
				Else
					ExitLoop
				EndIf
			EndIf
		WEnd
		Local $hfile = 0, $ierror = 0, $iresult = 0
		Do
			If NOT $hbitmap Then
				$ierror = 1
				ExitLoop
			EndIf
			Local $adata[4][2]
			$adata[0][0] = DllStructGetPtr($tbmp)
			$adata[0][1] = DllStructGetSize($tbmp)
			$adata[1][0] = DllStructGetPtr($tdib, "biSize")
			$adata[1][1] = 40
			$adata[2][1] = DllStructGetData($tdib, "biClrUsed") * 4
			Local $ttable = 0
			If $adata[2][1] Then
				$ttable = _winapi_getdibcolortable($hbitmap)
				If @error OR (@extended <> $adata[2][1] / 4) Then
					$ierror = @error + 10
					ExitLoop
				EndIf
			EndIf
			$adata[2][0] = DllStructGetPtr($ttable)
			$adata[3][0] = DllStructGetData($tdib, "bmBits")
			$adata[3][1] = DllStructGetData($tdib, "biSizeImage")
			DllStructSetData($tbmp, "bfType", 19778)
			DllStructSetData($tbmp, "bfSize", $adata[0][1] + $adata[1][1] + $adata[2][1] + $adata[3][1])
			DllStructSetData($tbmp, "bfReserved1", 0)
			DllStructSetData($tbmp, "bfReserved2", 0)
			DllStructSetData($tbmp, "bfOffset", $adata[0][1] + $adata[1][1] + $adata[2][1])
			$hdc = _winapi_getdc(0)
			If $ixpelspermeter = Default Then
				If NOT DllStructGetData($tdib, "biXPelsPerMeter") Then
					DllStructSetData($tdib, "biXPelsPerMeter", _winapi_getdevicecaps($hdc, 8) / _winapi_getdevicecaps($hdc, 4) * 1000)
				EndIf
			Else
				DllStructSetData($tdib, "biXPelsPerMeter", $ixpelspermeter)
			EndIf
			If $iypelspermeter = Default Then
				If NOT DllStructGetData($tdib, "biYPelsPerMeter") Then
					DllStructSetData($tdib, "biYPelsPerMeter", _winapi_getdevicecaps($hdc, 10) / _winapi_getdevicecaps($hdc, 6) * 1000)
				EndIf
			Else
				DllStructSetData($tdib, "biYPelsPerMeter", $iypelspermeter)
			EndIf
			_winapi_releasedc(0, $hdc)
			$hfile = _winapi_createfile($sfilepath, 1, 4)
			If @error Then
				$ierror = @error + 20
				ExitLoop
			EndIf
			Local $ibytes
			For $i = 0 To 3
				If $adata[$i][1] Then
					If NOT _winapi_writefile($hfile, $adata[$i][0], $adata[$i][1], $ibytes) Then
						$ierror = @error + 30
						ExitLoop 2
					EndIf
				EndIf
			Next
			$iresult = 1
		Until 1
		If $hsource Then
			_winapi_deleteobject($hsource)
		EndIf
		_winapi_closehandle($hfile)
		If NOT $iresult Then
			FileDelete($sfilepath)
		EndIf
		Return SetError($ierror, 0, $iresult)
	EndFunc

	Func _winapi_savehicontofile($sfilepath, Const ByRef $vicon, $bcompress = 0, $istart = 0, $iend = -1)
		Local $aicon, $atemp, $icount = 1
		If NOT IsArray($vicon) Then
			Dim $aicon[1] = [$vicon]
			Dim $atemp[1] = [0]
		Else
			If __checkerrorarraybounds($vicon, $istart, $iend) Then Return SetError(@error + 10, @extended, 0)
			$icount = $iend - $istart + 1
			If $icount Then
				Dim $aicon[$icount]
				Dim $atemp[$icount]
				For $i = 0 To $icount - 1
					$aicon[$i] = $vicon[$istart + $i]
					$atemp[$i] = 0
				Next
			EndIf
		EndIf
		Local $hfile = _winapi_createfile($sfilepath, 1, 4)
		If @error Then Return SetError(@error + 20, @extended, 0)
		Local $tico = DllStructCreate("align 1;ushort Reserved;ushort Type;ushort Count;byte Data[" & (16 * $icount) & "]")
		Local $ilength = DllStructGetSize($tico)
		Local $tbi = DllStructCreate($tagbitmapinfoheader)
		Local $tii = DllStructCreate($tagiconinfo)
		Local $tdib = DllStructCreate($tagdibsection)
		Local $idib = DllStructGetSize($tdib)
		Local $pdib = DllStructGetPtr($tdib)
		Local $ioffset = $ilength
		DllStructSetData($tbi, "biSize", 40)
		DllStructSetData($tbi, "biPlanes", 1)
		DllStructSetData($tbi, "biXPelsPerMeter", 0)
		DllStructSetData($tbi, "biYPelsPerMeter", 0)
		DllStructSetData($tbi, "biClrUsed", 0)
		DllStructSetData($tbi, "biClrImportant", 0)
		DllStructSetData($tico, "Reserved", 0)
		DllStructSetData($tico, "Type", 1)
		DllStructSetData($tico, "Count", $icount)
		Local $iresult = 0, $ierror = 0
		Do
			Local $ibytes
			If NOT _winapi_writefile($hfile, $tico, $ilength, $ibytes) Then
				$ierror = @error + 30
				ExitLoop
			EndIf
			Local $ainfo[8], $aret, $pdata = 0, $iindex = 0
			While $icount > $iindex
				$aret = DllCall("user32.dll", "bool", "GetIconInfo", "handle", $aicon[$iindex], "struct*", $tii)
				If @error OR NOT $aret[0] Then
					$ierror = @error + 40
					ExitLoop 2
				EndIf
				For $i = 4 To 5
					$ainfo[$i] = _winapi_copyimage(DllStructGetData($tii, $i), 0, 0, 0, 8200)
					If _winapi_getobject($ainfo[$i], $idib, $pdib) Then
						$ainfo[$i - 4] = DllStructGetData($tdib, "biSizeImage")
						$ainfo[$i - 2] = DllStructGetData($tdib, "bmBits")
					Else
						$ierror = @error + 50
					EndIf
				Next
				$ainfo[6] = 40
				$ainfo[7] = DllStructGetData($tdib, "bmBitsPixel")
				Switch $ainfo[7]
					Case 16, 24
					Case 32
						If NOT _winapi_isalphabitmap($ainfo[5]) Then
							If NOT $atemp[$iindex] Then
								$aicon[$iindex] = _winapi_create32bithicon($aicon[$iindex])
								$atemp[$iindex] = $aicon[$iindex]
								If NOT @error Then
									ContinueLoop
								Else
									ContinueCase
								EndIf
							EndIf
						Else
							If ($ainfo[1] >= 256 * 256 * 4) AND ($bcompress) Then
								$ibytes = _winapi_compressbitmapbits($ainfo[5], $pdata)
								If NOT @error Then
									$ainfo[0] = 0
									$ainfo[1] = $ibytes
									$ainfo[2] = 0
									$ainfo[3] = $pdata
									$ainfo[6] = 0
								EndIf
							EndIf
						EndIf
					Case Else
						$ierror = 60
				EndSwitch
				If $ierror Then
				Else
					Local $asize[2]
					Local $tdata = DllStructCreate("byte Width;byte Height;byte ColorCount;byte Reserved;ushort Planes;ushort BitCount;long Size;long Offset", DllStructGetPtr($tico) + 6 + 16 * $iindex)
					DllStructSetData($tdata, "ColorCount", 0)
					DllStructSetData($tdata, "Reserved", 0)
					DllStructSetData($tdata, "Planes", 1)
					DllStructSetData($tdata, "BitCount", $ainfo[7])
					DllStructSetData($tdata, "Size", $ainfo[0] + $ainfo[1] + $ainfo[6])
					DllStructSetData($tdata, "Offset", $ioffset)
					For $i = 0 To 1
						$asize[$i] = DllStructGetData($tdib, $i + 2)
						If $asize[$i] < 256 Then
							DllStructSetData($tdata, $i + 1, $asize[$i])
						Else
							DllStructSetData($tdata, $i + 1, 0)
						EndIf
					Next
					DllStructSetData($tbi, "biWidth", $asize[0])
					DllStructSetData($tbi, "biHeight", 2 * $asize[1])
					DllStructSetData($tbi, "biBitCount", $ainfo[7])
					DllStructSetData($tbi, "biCompression", 0)
					DllStructSetData($tbi, "biSizeImage", $ainfo[0] + $ainfo[1])
					$ioffset += $ainfo[0] + $ainfo[1] + $ainfo[6]
					Do
						If $ainfo[6] Then
							If NOT _winapi_writefile($hfile, $tbi, $ainfo[6], $ibytes) Then
								$ierror = @error + 70
								ExitLoop
							EndIf
							For $i = 1 To 0 Step -1
								If NOT _winapi_writefile($hfile, $ainfo[$i + 2], $ainfo[$i], $ibytes) Then
									$ierror = @error + 80
									ExitLoop 2
								EndIf
							Next
						Else
							If NOT _winapi_writefile($hfile, $ainfo[3], $ainfo[1], $ibytes) Then
								$ierror = @error + 90
								ExitLoop
							EndIf
						EndIf
					Until 1
				EndIf
				For $i = 4 To 5
					_winapi_deleteobject($ainfo[$i])
				Next
				If $ierror Then
					ExitLoop 2
				EndIf
				$iindex += 1
			WEnd
			$aret = DllCall("kernel32.dll", "bool", "SetFilePointerEx", "handle", $hfile, "int64", 0, "int64*", 0, "dword", 0)
			If @error OR NOT $aret[0] Then
				$ierror = @error + 100
				ExitLoop
			EndIf
			If NOT _winapi_writefile($hfile, $tico, $ilength, $ibytes) Then
				$ierror = @error + 110
				ExitLoop
			EndIf
			$iresult = 1
		Until 1
		For $i = 0 To $icount - 1
			If $atemp[$i] Then
				_winapi_destroyicon($atemp[$i])
			EndIf
		Next
		If $pdata Then
			__heapfree($pdata)
		EndIf
		_winapi_closehandle($hfile)
		If NOT $iresult Then
			FileDelete($sfilepath)
		EndIf
		Return SetError($ierror, 0, $iresult)
	EndFunc

	Func _winapi_scalewindowext($hdc, $ixnum, $ixdenom, $iynum, $iydenom)
		$__g_vext = DllStructCreate($tagsize)
		Local $aret = DllCall("gdi32.dll", "bool", "ScaleWindowExtEx", "handle", $hdc, "int", $ixnum, "int", $ixdenom, "int", $iynum, "int", $iydenom, "struct*", $__g_vext)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_selectclippath($hdc, $imode = 5)
		Local $aret = DllCall("gdi32.dll", "bool", "SelectClipPath", "handle", $hdc, "int", $imode)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_selectcliprgn($hdc, $hrgn)
		Local $aret = DllCall("gdi32.dll", "int", "SelectClipRgn", "handle", $hdc, "handle", $hrgn)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_setarcdirection($hdc, $idirection)
		Local $aret = DllCall("gdi32.dll", "int", "SetArcDirection", "handle", $hdc, "int", $idirection)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_setbitmapbits($hbitmap, $isize, $pbits)
		Local $aret = DllCall("gdi32.dll", "long", "SetBitmapBits", "handle", $hbitmap, "dword", $isize, "struct*", $pbits)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_setbitmapdimensionex($hbitmap, $iwidth, $iheight)
		$__g_vext = DllStructCreate($tagsize)
		Local $aret = DllCall("gdi32.dll", "bool", "SetBitmapDimensionEx", "handle", $hbitmap, "int", $iwidth, "int", $iheight, "struct*", $__g_vext)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_setboundsrect($hdc, $iflags, $trect = 0)
		Local $aret = DllCall("gdi32.dll", "uint", "SetBoundsRect", "handle", $hdc, "struct*", $trect, "uint", $iflags)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_setbrushorg($hdc, $ix, $iy)
		$__g_vext = DllStructCreate($tagpoint)
		Local $aret = DllCall("gdi32.dll", "bool", "SetBrushOrgEx", "handle", $hdc, "int", $ix, "int", $iy, "struct*", $__g_vext)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_setcoloradjustment($hdc, $tadjustment)
		Local $aret = DllCall("gdi32.dll", "bool", "SetColorAdjustment", "handle", $hdc, "struct*", $tadjustment)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_setdcbrushcolor($hdc, $irgb)
		Local $aret = DllCall("gdi32.dll", "dword", "SetDCBrushColor", "handle", $hdc, "dword", __rgb($irgb))
		If @error OR ($aret[0] = 4294967295) Then Return SetError(@error, @extended, -1)
		Return __rgb($aret[0])
	EndFunc

	Func _winapi_setdcpencolor($hdc, $irgb)
		Local $aret = DllCall("gdi32.dll", "dword", "SetDCPenColor", "handle", $hdc, "dword", __rgb($irgb))
		If @error OR ($aret[0] = 4294967295) Then Return SetError(@error, @extended, -1)
		Return __rgb($aret[0])
	EndFunc

	Func _winapi_setdevicegammaramp($hdc, Const ByRef $aramp)
		If (UBound($aramp, $ubound_dimensions) <> 2) OR (UBound($aramp, $ubound_rows) <> 256) OR (UBound($aramp, $ubound_columns) <> 3) Then
			Return SetError(12, 0, 0)
		EndIf
		Local $tdata = DllStructCreate("ushort[256];ushort[256];ushort[256]")
		For $i = 0 To 2
			For $j = 0 To 255
				DllStructSetData($tdata, $i + 1, $aramp[$j][$i], $j + 1)
			Next
		Next
		Local $aret = DllCall("gdi32.dll", "bool", "SetDeviceGammaRamp", "handle", $hdc, "struct*", $tdata)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_setdibcolortable($hbitmap, $tcolortable, $icolorcount)
		If $icolorcount > DllStructGetSize($tcolortable) / 4 Then Return SetError(1, 0, 0)
		Local $hdc = _winapi_createcompatibledc(0)
		Local $hsv = _winapi_selectobject($hdc, $hbitmap)
		Local $ierror = 0
		Local $aret = DllCall("gdi32.dll", "uint", "SetDIBColorTable", "handle", $hdc, "uint", 0, "uint", $icolorcount, "struct*", $tcolortable)
		If @error Then $ierror = @error
		_winapi_selectobject($hdc, $hsv)
		_winapi_deletedc($hdc)
		If $ierror Then Return SetError($ierror, 0, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_setdibitstodevice($hdc, $ixdest, $iydest, $iwidth, $iheight, $ixsrc, $iysrc, $istartscan, $iscanlines, $tbitmapinfo, $iusage, $pbits)
		Local $aret = DllCall("gdi32.dll", "int", "SetDIBitsToDevice", "handle", $hdc, "int", $ixdest, "int", $iydest, "dword", $iwidth, "dword", $iheight, "int", $ixsrc, "int", $iysrc, "uint", $istartscan, "uint", $iscanlines, "struct*", $pbits, "struct*", $tbitmapinfo, "uint", $iusage)
		If @error OR ($aret[0] = -1) Then Return SetError(@error + 10, $aret[0], 0)
		Return $aret[0]
	EndFunc

	Func _winapi_setenhmetafilebits($pdata, $ilength)
		Local $aret = DllCall("gdi32.dll", "handle", "SetEnhMetaFileBits", "uint", $ilength, "struct*", $pdata)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_setgraphicsmode($hdc, $imode)
		Local $aret = DllCall("gdi32.dll", "int", "SetGraphicsMode", "handle", $hdc, "int", $imode)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_setmapmode($hdc, $imode)
		Local $aret = DllCall("gdi32.dll", "int", "SetMapMode", "handle", $hdc, "int", $imode)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_setpixel($hdc, $ix, $iy, $irgb)
		Local $aret = DllCall("gdi32.dll", "bool", "SetPixelV", "handle", $hdc, "int", $ix, "int", $iy, "dword", __rgb($irgb))
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_setpolyfillmode($hdc, $imode = 1)
		Local $aret = DllCall("gdi32.dll", "int", "SetPolyFillMode", "handle", $hdc, "int", $imode)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_setrectrgn($hrgn, $trect)
		Local $aret = DllCall("gdi32.dll", "bool", "SetRectRgn", "handle", $hrgn, "int", DllStructGetData($trect, 1), "int", DllStructGetData($trect, 2), "int", DllStructGetData($trect, 3), "int", DllStructGetData($trect, 4))
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_setrop2($hdc, $imode)
		Local $aret = DllCall("gdi32.dll", "int", "SetROP2", "handle", $hdc, "int", $imode)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_setstretchbltmode($hdc, $imode)
		Local $aret = DllCall("gdi32.dll", "int", "SetStretchBltMode", "handle", $hdc, "int", $imode)
		If @error OR NOT $aret[0] OR ($aret[0] = 87) Then Return SetError(@error + 10, $aret[0], 0)
		Return $aret[0]
	EndFunc

	Func _winapi_settextalign($hdc, $imode = 0)
		Local $aret = DllCall("gdi32.dll", "uint", "SetTextAlign", "handle", $hdc, "uint", $imode)
		If @error OR ($aret[0] = 4294967295) Then Return SetError(@error, @extended, -1)
		Return $aret[0]
	EndFunc

	Func _winapi_settextcharacterextra($hdc, $icharextra)
		Local $aret = DllCall("gdi32.dll", "int", "SetTextCharacterExtra", "handle", $hdc, "int", $icharextra)
		If @error OR ($aret[0] = -2147483648) Then Return SetError(@error, @extended, -1)
		Return $aret[0]
	EndFunc

	Func _winapi_settextjustification($hdc, $ibreakextra, $ibreakcount)
		Local $aret = DllCall("gdi32.dll", "bool", "SetTextJustification", "handle", $hdc, "int", $ibreakextra, "int", $ibreakcount)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_setudfcolormode($imode)
		$__g_irgbmode = NOT ($imode = 0)
	EndFunc

	Func _winapi_setwindowext($hdc, $ixextent, $iyextent)
		$__g_vext = DllStructCreate($tagsize)
		Local $aret = DllCall("gdi32.dll", "bool", "SetWindowExtEx", "handle", $hdc, "int", $ixextent, "int", $iyextent, "struct*", $__g_vext)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_setwindoworg($hdc, $ix, $iy)
		$__g_vext = DllStructCreate($tagpoint)
		Local $aret = DllCall("gdi32.dll", "bool", "SetWindowOrgEx", "handle", $hdc, "int", $ix, "int", $iy, "struct*", $__g_vext)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_setworldtransform($hdc, ByRef $txform)
		Local $aret = DllCall("gdi32.dll", "bool", "SetWorldTransform", "handle", $hdc, "struct*", $txform)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_stretchblt($hdestdc, $ixdest, $iydest, $iwidthdest, $iheightdest, $hsrcdc, $ixsrc, $iysrc, $iwidthsrc, $iheightsrc, $irop)
		Local $aret = DllCall("gdi32.dll", "bool", "StretchBlt", "handle", $hdestdc, "int", $ixdest, "int", $iydest, "int", $iwidthdest, "int", $iheightdest, "hwnd", $hsrcdc, "int", $ixsrc, "int", $iysrc, "int", $iwidthsrc, "int", $iheightsrc, "dword", $irop)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_stretchdibits($hdestdc, $ixdest, $iydest, $iwidthdest, $iheightdest, $ixsrc, $iysrc, $iwidthsrc, $iheightsrc, $tbitmapinfo, $iusage, $pbits, $irop)
		Local $aret = DllCall("gdi32.dll", "int", "StretchDIBits", "handle", $hdestdc, "int", $ixdest, "int", $iydest, "int", $iwidthdest, "int", $iheightdest, "int", $ixsrc, "int", $iysrc, "int", $iwidthsrc, "int", $iheightsrc, "struct*", $pbits, "struct*", $tbitmapinfo, "uint", $iusage, "dword", $irop)
		If @error OR ($aret[0] = -1) Then Return SetError(@error + 10, $aret[0], 0)
		Return $aret[0]
	EndFunc

	Func _winapi_strokeandfillpath($hdc)
		Local $aret = DllCall("gdi32.dll", "bool", "StrokeAndFillPath", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_strokepath($hdc)
		Local $aret = DllCall("gdi32.dll", "bool", "StrokePath", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_subtractrect(ByRef $trect1, ByRef $trect2)
		Local $trect = DllStructCreate($tagrect)
		Local $aret = DllCall("user32.dll", "bool", "SubtractRect", "struct*", $trect, "struct*", $trect1, "struct*", $trect2)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, @extended, 0)
		Return $trect
	EndFunc

	Func _winapi_tabbedtextout($hdc, $ix, $iy, $stext, $atab = 0, $istart = 0, $iend = -1, $iorigin = 0)
		Local $itab, $icount
		If NOT IsArray($atab) Then
			If $atab Then
				$itab = $atab
				Dim $atab[1] = [$itab]
				$istart = 0
				$iend = 0
				$icount = 1
			Else
				$icount = 0
			EndIf
		Else
			$icount = 1
		EndIf
		Local $ttab = 0
		If $icount Then
			If __checkerrorarraybounds($atab, $istart, $iend) Then Return SetError(@error + 10, @extended, 0)
			$icount = $iend - $istart + 1
			$ttab = DllStructCreate("uint[" & $icount & "]")
			$itab = 1
			For $i = $istart To $iend
				DllStructSetData($ttab, 1, $atab[$i], $itab)
				$itab += 1
			Next
		EndIf
		Local $aret = DllCall("user32.dll", "long", "TabbedTextOutW", "handle", $hdc, "int", $ix, "int", $iy, "wstr", $stext, "int", StringLen($stext), "int", $icount, "struct*", $ttab, "int", $iorigin)
		If @error OR NOT $aret[0] Then Return SetError(@error, @extended, 0)
		$__g_vext = _winapi_createsize(_winapi_loword($aret[0]), _winapi_hiword($aret[0]))
		Return 1
	EndFunc

	Func _winapi_textout($hdc, $ix, $iy, $stext)
		Local $aret = DllCall("gdi32.dll", "bool", "TextOutW", "handle", $hdc, "int", $ix, "int", $iy, "wstr", $stext, "int", StringLen($stext))
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_transparentblt($hdestdc, $ixdest, $iydest, $iwidthdest, $iheightdest, $hsrcdc, $ixsrc, $iysrc, $iwidthsrc, $iheightsrc, $irgb)
		Local $aret = DllCall("gdi32.dll", "bool", "GdiTransparentBlt", "handle", $hdestdc, "int", $ixdest, "int", $iydest, "int", $iwidthdest, "int", $iheightdest, "hwnd", $hsrcdc, "int", $ixsrc, "int", $iysrc, "int", $iwidthsrc, "int", $iheightsrc, "dword", __rgb($irgb))
		If @error Then Return SetError(@error, @extended, False)
		Return $aret[0]
	EndFunc

	Func _winapi_unionrect(ByRef $trect1, ByRef $trect2)
		Local $trect = DllStructCreate($tagrect)
		Local $aret = DllCall("user32.dll", "bool", "UnionRect", "struct*", $trect, "struct*", $trect1, "struct*", $trect2)
		If @error OR NOT $aret[0] Then Return SetError(@error + 10, 0, 0)
		Return $trect
	EndFunc

	Func _winapi_validaterect($hwnd, $trect = 0)
		Local $aret = DllCall("user32.dll", "bool", "ValidateRect", "hwnd", $hwnd, "struct*", $trect)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_validatergn($hwnd, $hrgn = 0)
		Local $aret = DllCall("user32.dll", "bool", "ValidateRgn", "hwnd", $hwnd, "handle", $hrgn)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_widenpath($hdc)
		Local $aret = DllCall("gdi32.dll", "bool", "WidenPath", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

	Func _winapi_windowfromdc($hdc)
		Local $aret = DllCall("user32.dll", "hwnd", "WindowFromDC", "handle", $hdc)
		If @error Then Return SetError(@error, @extended, 0)
		Return $aret[0]
	EndFunc

#EndRegion Public Functions
#Region Embedded DLL Functions

	Func __alphaproc()
		Static $pproc = 0
		If NOT $pproc Then
			If @AutoItX64 Then
				$pproc = __init(Binary("0x48894C240848895424104C894424184C894C24205541574831C050504883EC28" & "48837C24600074054831C0EB0748C7C0010000004821C0751F488B6C24604883" & "7D180074054831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB" & "034831C04821C0740C48C7C0FFFFFFFF4863C0EB6F48C744242800000000488B" & "6C24604C637D04488B6C2460486345084C0FAFF849C1E7024983C7FC4C3B7C24" & "287C36488B6C24604C8B7D184C037C24284983C7034C897C2430488B6C243080" & "7D0000740C48C7C0010000004863C0EB1348834424280471A54831C04863C0EB" & "034831C04883C438415F5DC3"))
			Else
				$pproc = __init(Binary("0x555331C05050837C241C00740431C0EB05B80100000021C075198B6C241C837D" & "1400740431C0EB05B80100000021C07502EB07B801000000EB0231C021C07407" & "B8FFFFFFFFEB4FC70424000000008B6C241C8B5D048B6C241C0FAF5D08C1E302" & "83C3FC3B1C247C288B6C241C8B5D14031C2483C303895C24048B6C2404807D00" & "007407B801000000EB0C8304240471BE31C0EB0231C083C4085B5DC21000"))
			EndIf
		EndIf
		Return $pproc
	EndFunc

	Func __andproc()
		Static $pproc = 0
		If NOT $pproc Then
			If @AutoItX64 Then
				$pproc = __init(Binary("0x48894C240848895424104C894424184C894C2420554157415648C7C009000000" & "4883EC0848C704240000000048FFC875EF4883EC284883BC24A0000000007405" & "4831C0EB0748C7C0010000004821C00F85840000004883BC24A8000000007405" & "4831C0EB0748C7C0010000004821C07555488BAC24A000000048837D18007405" & "4831C0EB0748C7C0010000004821C07522488BAC24A800000048837D18007405" & "4831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB034831C048" & "21C07502EB0948C7C001000000EB034831C04821C07502EB0948C7C001000000" & "EB034831C04821C0740B4831C04863C0E9D701000048C74424280000000048C7" & "44243000000000488BAC24A00000004C637D0849FFCF4C3B7C24300F8C9C0100" & "0048C74424380000000048C74424400000000048C744244800000000488BAC24" & "A00000004C637D0449FFCF4C3B7C24480F8CDB000000488BAC24A00000004C8B" & "7D184C037C24284983C7034C897C2450488B6C2450807D000074264C8B7C2440" & "4C8B74243849F7DE4983C61F4C89F148C7C00100000048D3E04909C74C897C24" & "4048FF4424384C8B7C24384983FF1F7E6F4C8B7C244049F7D74C897C244048C7" & "442458180000004831C0483B4424587F3D488BAC24A80000004C8B7D184C037C" & "24604C897C24504C8B7C2440488B4C245849D3FF4C89F850488B6C2458588845" & "0048FF4424604883442458F871B948C74424380000000048C744244000000000" & "48834424280448FF4424480F810BFFFFFF48837C24380074794C8B7C244049F7" & "D74C8B74243849F7DE4983C6204C89F148C7C0FFFFFFFF48D3E04921C74C897C" & "244048C7442458180000004831C0483B4424587F3D488BAC24A80000004C8B7D" & "184C037C24604C897C24504C8B7C2440488B4C245849D3FF4C89F850488B6C24" & "585888450048FF4424604883442458F871B948FF4424300F814AFEFFFF48C7C0" & "010000004863C0EB034831C04883C470415E415F5DC3"))
			Else
				$pproc = __init(Binary("0x555357BA0800000083EC04C70424000000004A75F3837C243800740431C0EB05" & "B80100000021C07562837C243C00740431C0EB05B80100000021C0753F8B6C24" & "38837D1400740431C0EB05B80100000021C075198B6C243C837D1400740431C0" & "EB05B80100000021C07502EB07B801000000EB0231C021C07502EB07B8010000" & "00EB0231C021C07502EB07B801000000EB0231C021C0740731C0E969010000C7" & "042400000000C7442404000000008B6C24388B5D084B3B5C24040F8C3F010000" & "C744240800000000C744240C00000000C7442410000000008B6C24388B5D044B" & "3B5C24100F8CA90000008B6C24388B5D14031C2483C303895C24148B6C241480" & "7D0000741C8B5C240C8B7C2408F7DF83C71F89F9B801000000D3E009C3895C24" & "0CFF4424088B5C240883FB1F7E578B5C240CF7D3895C240CC744241818000000" & "31C03B4424187F2D8B6C243C8B5D14035C241C895C24148B5C240C8B4C2418D3" & "FB538B6C241858884500FF44241C83442418F871CBC744240800000000C74424" & "0C0000000083042404FF4424100F8145FFFFFF837C240800745B8B5C240CF7D3" & "8B7C2408F7DF83C72089F9B8FFFFFFFFD3E021C3895C240CC744241818000000" & "31C03B4424187F2D8B6C243C8B5D14035C241C895C24148B5C240C8B4C2418D3" & "FB538B6C241858884500FF44241C83442418F871CBFF4424040F81AFFEFFFFB8" & "01000000EB0231C083C4205F5B5DC21000"))
			EndIf
		EndIf
		Return $pproc
	EndFunc

	Func __xorproc()
		Static $pproc = 0
		If NOT $pproc Then
			If @AutoItX64 Then
				$pproc = __init(Binary("0x48894C240848895424104C894424184C894C24205541574831C050504883EC28" & "48837C24600074054831C0EB0748C7C0010000004821C0751B48837C24680074" & "054831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB034831C0" & "4821C074084831C04863C0EB7748C7442428000000004C637C24584983C7FC4C" & "3B7C24287C4F4C8B7C24604C037C24284C897C2430488B6C2430807D00007405" & "4831C0EB0748C7C0010000004821C0741C4C8B7C24684C037C24284983C7034C" & "897C2430488B6C2430C64500FF48834424280471A148C7C0010000004863C0EB" & "034831C04883C438415F5DC3"))
			Else
				$pproc = __init(Binary("0x555331C05050837C241C00740431C0EB05B80100000021C07516837C24200074" & "0431C0EB05B80100000021C07502EB07B801000000EB0231C021C0740431C0EB" & "5AC70424000000008B5C241883C3FC3B1C247C3E8B5C241C031C24895C24048B" & "6C2404807D0000740431C0EB05B80100000021C074168B5C2420031C2483C303" & "895C24048B6C2404C64500FF8304240471B6B801000000EB0231C083C4085B5D" & "C21000"))
			EndIf
		EndIf
		Return $pproc
	EndFunc

#EndRegion Embedded DLL Functions
#Region Internal Functions

	Func __enumdisplaymonitorsproc($hmonitor, $hdc, $prect, $lparam)
		#forceref $hDC, $lParam
		__inc($__g_venum)
		$__g_venum[$__g_venum[0][0]][0] = $hmonitor
		If NOT $prect Then
			$__g_venum[$__g_venum[0][0]][1] = 0
		Else
			$__g_venum[$__g_venum[0][0]][1] = DllStructCreate($tagrect)
			If NOT _winapi_movememory(DllStructGetPtr($__g_venum[$__g_venum[0][0]][1]), $prect, 16) Then Return 0
		EndIf
		Return 1
	EndFunc

	Func __enumfontfamiliesproc($pelfex, $pntmex, $ifonttype, $ppattern)
		Local $telfex = DllStructCreate($taglogfont & ";wchar FullName[64];wchar Style[32];wchar Script[32]", $pelfex)
		Local $tntmex = DllStructCreate($tagnewtextmetricex, $pntmex)
		Local $tpattern = DllStructCreate("uint;uint;ptr", $ppattern)
		If $ifonttype AND NOT BitAND($ifonttype, DllStructGetData($tpattern, 1)) Then
			Return 1
		EndIf
		If DllStructGetData($tpattern, 3) Then
			Local $aret = DllCall("shlwapi.dll", "bool", "PathMatchSpecW", "ptr", DllStructGetPtr($telfex, 14), "ptr", DllStructGetData($tpattern, 3))
			If NOT @error Then
				If DllStructGetData($tpattern, 2) Then
					If $aret[0] Then
						Return 1
					Else
					EndIf
				Else
					If $aret[0] Then
					Else
						Return 1
					EndIf
				EndIf
			EndIf
		EndIf
		__inc($__g_venum)
		$__g_venum[$__g_venum[0][0]][0] = DllStructGetData($telfex, 14)
		$__g_venum[$__g_venum[0][0]][1] = DllStructGetData($telfex, 16)
		$__g_venum[$__g_venum[0][0]][2] = DllStructGetData($telfex, 15)
		$__g_venum[$__g_venum[0][0]][3] = DllStructGetData($telfex, 17)
		$__g_venum[$__g_venum[0][0]][4] = $ifonttype
		$__g_venum[$__g_venum[0][0]][5] = DllStructGetData($tntmex, 19)
		$__g_venum[$__g_venum[0][0]][6] = DllStructGetData($tntmex, 20)
		$__g_venum[$__g_venum[0][0]][7] = DllStructGetData($tntmex, 21)
		Return 1
	EndFunc

	Func __enumfontstylesproc($pelfex, $pntmex, $ifonttype, $pfn)
		#forceref $iFontType
		Local $telfex = DllStructCreate($taglogfont & ";wchar FullName[64];wchar Style[32];wchar Script[32]", $pelfex)
		Local $tntmex = DllStructCreate($tagnewtextmetricex, $pntmex)
		Local $tfn = DllStructCreate("dword;wchar[64]", $pfn)
		If BitAND(DllStructGetData($tntmex, "ntmFlags"), 97) = DllStructGetData($tfn, 1) Then
			DllStructSetData($tfn, 2, DllStructGetData($telfex, "FullName"))
			Return 0
		Else
			Return 1
		EndIf
	EndFunc

#EndRegion Internal Functions
Global $__g_hgdipbrush = 0
Global $__g_hgdipdll = 0
Global $__g_hgdippen = 0
Global $__g_igdipref = 0
Global $__g_igdiptoken = 0
Global $__g_bgdip_v1_0 = True

Func _gdiplus_arrowcapcreate($fheight, $fwidth, $bfilled = True)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateAdjustableArrowCap", "float", $fheight, "float", $fwidth, "bool", $bfilled, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[4]
EndFunc

Func _gdiplus_arrowcapdispose($hcap)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDeleteCustomLineCap", "handle", $hcap)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_arrowcapgetfillstate($harrowcap)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetAdjustableArrowCapFillState", "handle", $harrowcap, "bool*", 0)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_arrowcapgetheight($harrowcap)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetAdjustableArrowCapHeight", "handle", $harrowcap, "float*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_arrowcapgetmiddleinset($harrowcap)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetAdjustableArrowCapMiddleInset", "handle", $harrowcap, "float*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_arrowcapgetwidth($harrowcap)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetAdjustableArrowCapWidth", "handle", $harrowcap, "float*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_arrowcapsetfillstate($harrowcap, $bfilled = True)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetAdjustableArrowCapFillState", "handle", $harrowcap, "bool", $bfilled)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_arrowcapsetheight($harrowcap, $fheight)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetAdjustableArrowCapHeight", "handle", $harrowcap, "float", $fheight)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_arrowcapsetmiddleinset($harrowcap, $finset)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetAdjustableArrowCapMiddleInset", "handle", $harrowcap, "float", $finset)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_arrowcapsetwidth($harrowcap, $fwidth)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetAdjustableArrowCapWidth", "handle", $harrowcap, "float", $fwidth)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_bitmapclonearea($hbitmap, $nleft, $ntop, $nwidth, $nheight, $iformat = 137224)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCloneBitmapArea", "float", $nleft, "float", $ntop, "float", $nwidth, "float", $nheight, "int", $iformat, "handle", $hbitmap, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[7]
EndFunc

Func _gdiplus_bitmapcreatedibfrombitmap($hbitmap)
	Local $aret = DllCall($__g_hgdipdll, "uint", "GdipGetImageDimension", "handle", $hbitmap, "float*", 0, "float*", 0)
	If @error OR $aret[0] Then Return SetError(@error + 10, $aret[0], 0)
	Local $tdata = _gdiplus_bitmaplockbits($hbitmap, 0, 0, $aret[2], $aret[3], $gdip_ilmread, $gdip_pxf32argb)
	Local $pbits = DllStructGetData($tdata, "Scan0")
	If NOT $pbits Then Return 0
	Local $tbihdr = DllStructCreate($tagbitmapv5header)
	DllStructSetData($tbihdr, "bV5Size", DllStructGetSize($tbihdr))
	DllStructSetData($tbihdr, "bV5Width", $aret[2])
	DllStructSetData($tbihdr, "bV5Height", $aret[3])
	DllStructSetData($tbihdr, "bV5Planes", 1)
	DllStructSetData($tbihdr, "bV5BitCount", 32)
	DllStructSetData($tbihdr, "bV5Compression", 0)
	DllStructSetData($tbihdr, "bV5SizeImage", $aret[3] * DllStructGetData($tdata, "Stride"))
	DllStructSetData($tbihdr, "bV5AlphaMask", -16777216)
	DllStructSetData($tbihdr, "bV5RedMask", 16711680)
	DllStructSetData($tbihdr, "bV5GreenMask", 65280)
	DllStructSetData($tbihdr, "bV5BlueMask", 255)
	DllStructSetData($tbihdr, "bV5CSType", 2)
	DllStructSetData($tbihdr, "bV5Intent", 4)
	Local $hhbitmapv5 = DllCall("gdi32.dll", "ptr", "CreateDIBSection", "hwnd", 0, "struct*", $tbihdr, "uint", 0, "ptr*", 0, "ptr", 0, "dword", 0)
	If NOT @error AND $hhbitmapv5[0] Then
		DllCall("gdi32.dll", "dword", "SetBitmapBits", "ptr", $hhbitmapv5[0], "dword", $aret[2] * $aret[3] * 4, "ptr", DllStructGetData($tdata, "Scan0"))
		$hhbitmapv5 = $hhbitmapv5[0]
	Else
		$hhbitmapv5 = 0
	EndIf
	_gdiplus_bitmapunlockbits($hbitmap, $tdata)
	$tdata = 0
	$tbihdr = 0
	Return $hhbitmapv5
EndFunc

Func _gdiplus_bitmapcreatefromfile($sfilename)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateBitmapFromFile", "wstr", $sfilename, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_bitmapcreatefromgraphics($iwidth, $iheight, $hgraphics)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateBitmapFromGraphics", "int", $iwidth, "int", $iheight, "handle", $hgraphics, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[4]
EndFunc

Func _gdiplus_bitmapcreatefromhbitmap($hbitmap, $hpal = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateBitmapFromHBITMAP", "handle", $hbitmap, "handle", $hpal, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[3]
EndFunc

Func _gdiplus_bitmapcreatefrommemory($dimage, $bhbitmap = False)
	If NOT IsBinary($dimage) Then Return SetError(1, 0, 0)
	Local $aresult = 0
	Local Const $dmembitmap = Binary($dimage)
	Local Const $ilen = BinaryLen($dmembitmap)
	Local Const $gmem_moveable = 2
	$aresult = DllCall("kernel32.dll", "handle", "GlobalAlloc", "uint", $gmem_moveable, "ulong_ptr", $ilen)
	If @error Then Return SetError(4, 0, 0)
	Local Const $hdata = $aresult[0]
	$aresult = DllCall("kernel32.dll", "ptr", "GlobalLock", "handle", $hdata)
	If @error Then Return SetError(5, 0, 0)
	Local $tmem = DllStructCreate("byte[" & $ilen & "]", $aresult[0])
	DllStructSetData($tmem, 1, $dmembitmap)
	DllCall("kernel32.dll", "bool", "GlobalUnlock", "handle", $hdata)
	If @error Then Return SetError(6, 0, 0)
	Local Const $hstream = _winapi_createstreamonhglobal($hdata)
	If @error Then Return SetError(2, 0, 0)
	Local Const $hbitmap = _gdiplus_bitmapcreatefromstream($hstream)
	If @error Then Return SetError(3, 0, 0)
	DllCall("oleaut32.dll", "long", "DispCallFunc", "ptr", $hstream, "ulong_ptr", 8 * (1 + @AutoItX64), "uint", 4, "ushort", 23, "uint", 0, "ptr", 0, "ptr", 0, "str", "")
	If $bhbitmap Then
		Local Const $hhbmp = _gdiplus_bitmapcreatedibfrombitmap($hbitmap)
		_gdiplus_bitmapdispose($hbitmap)
		Return $hhbmp
	EndIf
	Return $hbitmap
EndFunc

Func _gdiplus_bitmapcreatefromresource($hinst, $vresourcename)
	Local $stype = "int"
	If IsString($vresourcename) Then $stype = "wstr"
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateBitmapFromResource", "handle", $hinst, $stype, $vresourcename, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[3]
EndFunc

Func _gdiplus_bitmapcreatefromscan0($iwidth, $iheight, $ipixelformat = $gdip_pxf32argb, $istride = 0, $pscan0 = 0)
	Local $aresult = DllCall($__g_hgdipdll, "uint", "GdipCreateBitmapFromScan0", "int", $iwidth, "int", $iheight, "int", $istride, "int", $ipixelformat, "struct*", $pscan0, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[6]
EndFunc

Func _gdiplus_bitmapcreatefromstream($pstream)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateBitmapFromStream", "ptr", $pstream, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_bitmapcreatehbitmapfrombitmap($hbitmap, $iargb = -16777216)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateHBITMAPFromBitmap", "handle", $hbitmap, "handle*", 0, "dword", $iargb)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_bitmapdispose($hbitmap)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDisposeImage", "handle", $hbitmap)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_bitmapcreatefromhicon($hicon)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateBitmapFromHICON", "handle", $hicon, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_bitmapcreatefromhicon32($hicon)
	Local $tsize = _winapi_geticondimension($hicon)
	Local $iwidth = DllStructGetData($tsize, "X")
	Local $iheight = DllStructGetData($tsize, "Y")
	If $iwidth <= 0 OR $iheight <= 0 Then Return SetError(10, -1, 0)
	Local $tbitmapinfo = DllStructCreate("dword Size;long Width;long Height;word Planes;word BitCount;dword Compression;dword SizeImage;long XPelsPerMeter;long YPelsPerMeter;dword ClrUsed;dword ClrImportant;dword RGBQuad")
	DllStructSetData($tbitmapinfo, "Size", DllStructGetSize($tbitmapinfo) - 4)
	DllStructSetData($tbitmapinfo, "Width", $iwidth)
	DllStructSetData($tbitmapinfo, "Height", -$iheight)
	DllStructSetData($tbitmapinfo, "Planes", 1)
	DllStructSetData($tbitmapinfo, "BitCount", 32)
	DllStructSetData($tbitmapinfo, "Compression", 0)
	DllStructSetData($tbitmapinfo, "SizeImage", 0)
	Local $hdc = _winapi_createcompatibledc(0)
	Local $pbits
	Local $hbmp = _winapi_createdibsection(0, $tbitmapinfo, 0, $pbits)
	Local $horig = _winapi_selectobject($hdc, $hbmp)
	_winapi_drawiconex($hdc, 0, 0, $hicon, $iwidth, $iheight)
	Local $hbitmapicon = _gdiplus_bitmapcreatefromscan0($iwidth, $iheight, $gdip_pxf32argb, $iwidth * 4, $pbits)
	Local $hbitmap = _gdiplus_bitmapcreatefromscan0($iwidth, $iheight)
	Local $hcontext = _gdiplus_imagegetgraphicscontext($hbitmap)
	_gdiplus_graphicsdrawimage($hcontext, $hbitmapicon, 0, 0)
	_gdiplus_graphicsdispose($hcontext)
	_gdiplus_bitmapdispose($hbitmapicon)
	_winapi_selectobject($hdc, $horig)
	_winapi_deletedc($hdc)
	_winapi_deleteobject($hbmp)
	Return $hbitmap
EndFunc

Func _gdiplus_bitmapgetpixel($hbitmap, $ix, $iy)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipBitmapGetPixel", "handle", $hbitmap, "int", $ix, "int", $iy, "uint*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[4]
EndFunc

Func _gdiplus_bitmaplockbits($hbitmap, $ileft, $itop, $iwidth, $iheight, $iflags = $gdip_ilmread, $iformat = $gdip_pxf32rgb)
	Local $tdata = DllStructCreate($taggdipbitmapdata)
	Local $trect = DllStructCreate($tagrect)
	DllStructSetData($trect, "Left", $ileft)
	DllStructSetData($trect, "Top", $itop)
	DllStructSetData($trect, "Right", $iwidth)
	DllStructSetData($trect, "Bottom", $iheight)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipBitmapLockBits", "handle", $hbitmap, "struct*", $trect, "uint", $iflags, "int", $iformat, "struct*", $tdata)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $tdata
EndFunc

Func _gdiplus_bitmapsetpixel($hbitmap, $ix, $iy, $iargb)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipBitmapSetPixel", "handle", $hbitmap, "int", $ix, "int", $iy, "uint", $iargb)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_bitmapunlockbits($hbitmap, $tbitmapdata)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipBitmapUnlockBits", "handle", $hbitmap, "struct*", $tbitmapdata)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_brushclone($hbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCloneBrush", "handle", $hbrush, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_brushcreatesolid($iargb = -16777216)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateSolidFill", "int", $iargb, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_brushdispose($hbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDeleteBrush", "handle", $hbrush)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_brushgetsolidcolor($hbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetSolidFillColor", "handle", $hbrush, "dword*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_brushgettype($hbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetBrushType", "handle", $hbrush, "int*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_brushsetsolidcolor($hbrush, $iargb = -16777216)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetSolidFillColor", "handle", $hbrush, "dword", $iargb)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_colormatrixcreate()
	Return _gdiplus_colormatrixcreatescale(1, 1, 1, 1)
EndFunc

Func _gdiplus_colormatrixcreategrayscale()
	Local $ii, $ij, $tcm, $alums[4] = [$gdip_rlum, $gdip_glum, $gdip_blum, 0]
	$tcm = DllStructCreate($taggdipcolormatrix)
	For $ii = 0 To 3
		For $ij = 1 To 3
			DllStructSetData($tcm, "m", $alums[$ii], $ii * 5 + $ij)
		Next
	Next
	DllStructSetData($tcm, "m", 1, 19)
	DllStructSetData($tcm, "m", 1, 25)
	Return $tcm
EndFunc

Func _gdiplus_colormatrixcreatenegative()
	Local $ii, $tcm
	$tcm = _gdiplus_colormatrixcreatescale(-1, -1, -1, 1)
	For $ii = 1 To 4
		DllStructSetData($tcm, "m", 1, 20 + $ii)
	Next
	Return $tcm
EndFunc

Func _gdiplus_colormatrixcreatesaturation($fsat)
	Local $fsatcomp, $tcm
	$tcm = DllStructCreate($taggdipcolormatrix)
	$fsatcomp = (1 - $fsat)
	DllStructSetData($tcm, "m", $fsatcomp * $gdip_rlum + $fsat, 1)
	DllStructSetData($tcm, "m", $fsatcomp * $gdip_rlum, 2)
	DllStructSetData($tcm, "m", $fsatcomp * $gdip_rlum, 3)
	DllStructSetData($tcm, "m", $fsatcomp * $gdip_glum, 6)
	DllStructSetData($tcm, "m", $fsatcomp * $gdip_glum + $fsat, 7)
	DllStructSetData($tcm, "m", $fsatcomp * $gdip_glum, 8)
	DllStructSetData($tcm, "m", $fsatcomp * $gdip_blum, 11)
	DllStructSetData($tcm, "m", $fsatcomp * $gdip_blum, 12)
	DllStructSetData($tcm, "m", $fsatcomp * $gdip_blum + $fsat, 13)
	DllStructSetData($tcm, "m", 1, 19)
	DllStructSetData($tcm, "m", 1, 25)
	Return $tcm
EndFunc

Func _gdiplus_colormatrixcreatescale($fred, $fgreen, $fblue, $falpha = 1)
	Local $tcm
	$tcm = DllStructCreate($taggdipcolormatrix)
	DllStructSetData($tcm, "m", $fred, 1)
	DllStructSetData($tcm, "m", $fgreen, 7)
	DllStructSetData($tcm, "m", $fblue, 13)
	DllStructSetData($tcm, "m", $falpha, 19)
	DllStructSetData($tcm, "m", 1, 25)
	Return $tcm
EndFunc

Func _gdiplus_colormatrixcreatetranslate($fred, $fgreen, $fblue, $falpha = 0)
	Local $ii, $tcm, $afactors[4] = [$fred, $fgreen, $fblue, $falpha]
	$tcm = _gdiplus_colormatrixcreate()
	For $ii = 0 To 3
		DllStructSetData($tcm, "m", $afactors[$ii], 21 + $ii)
	Next
	Return $tcm
EndFunc

Func _gdiplus_customlinecapclone($hcustomlinecap)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCloneCustomLineCap", "handle", $hcustomlinecap, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_customlinecapcreate($hpathfill, $hpathstroke, $ilinecap = 0, $nbaseinset = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateCustomLineCap", "handle", $hpathfill, "handle", $hpathstroke, "int", $ilinecap, "float", $nbaseinset, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[5]
EndFunc

Func _gdiplus_customlinecapdispose($hcap)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDeleteCustomLineCap", "handle", $hcap)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_customlinecapgetstrokecaps($hcustomlinecap)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetCustomLineCapStrokeCaps", "hwnd", $hcustomlinecap, "ptr*", 0, "ptr*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then SetError(10, $aresult[0], 0)
	Local $acaps[2]
	$acaps[0] = $aresult[2]
	$acaps[1] = $aresult[3]
	Return $acaps
EndFunc

Func _gdiplus_customlinecapsetstrokecaps($hcustomlinecap, $istartcap, $iendcap)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetCustomLineCapStrokeCaps", "handle", $hcustomlinecap, "int", $istartcap, "int", $iendcap)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_decoders()
	Local $icount = _gdiplus_decodersgetcount()
	Local $isize = _gdiplus_decodersgetsize()
	Local $tbuffer = DllStructCreate("byte[" & $isize & "]")
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImageDecoders", "uint", $icount, "uint", $isize, "struct*", $tbuffer)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Local $pbuffer = DllStructGetPtr($tbuffer)
	Local $tcodec, $ainfo[$icount + 1][14]
	$ainfo[0][0] = $icount
	For $ii = 1 To $icount
		$tcodec = DllStructCreate($taggdipimagecodecinfo, $pbuffer)
		$ainfo[$ii][1] = _winapi_stringfromguid(DllStructGetPtr($tcodec, "CLSID"))
		$ainfo[$ii][2] = _winapi_stringfromguid(DllStructGetPtr($tcodec, "FormatID"))
		$ainfo[$ii][3] = _winapi_widechartomultibyte(DllStructGetData($tcodec, "CodecName"))
		$ainfo[$ii][4] = _winapi_widechartomultibyte(DllStructGetData($tcodec, "DllName"))
		$ainfo[$ii][5] = _winapi_widechartomultibyte(DllStructGetData($tcodec, "FormatDesc"))
		$ainfo[$ii][6] = _winapi_widechartomultibyte(DllStructGetData($tcodec, "FileExt"))
		$ainfo[$ii][7] = _winapi_widechartomultibyte(DllStructGetData($tcodec, "MimeType"))
		$ainfo[$ii][8] = DllStructGetData($tcodec, "Flags")
		$ainfo[$ii][9] = DllStructGetData($tcodec, "Version")
		$ainfo[$ii][10] = DllStructGetData($tcodec, "SigCount")
		$ainfo[$ii][11] = DllStructGetData($tcodec, "SigSize")
		$ainfo[$ii][12] = DllStructGetData($tcodec, "SigPattern")
		$ainfo[$ii][13] = DllStructGetData($tcodec, "SigMask")
		$pbuffer += DllStructGetSize($tcodec)
	Next
	Return $ainfo
EndFunc

Func _gdiplus_decodersgetcount()
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImageDecodersSize", "uint*", 0, "uint*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[1]
EndFunc

Func _gdiplus_decodersgetsize()
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImageDecodersSize", "uint*", 0, "uint*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_drawimagepoints($hgraphic, $himage, $nulx, $nuly, $nurx, $nury, $nllx, $nlly, $icount = 3)
	Local $tpoint = DllStructCreate("float X;float Y;float X2;float Y2;float X3;float Y3")
	DllStructSetData($tpoint, "X", $nulx)
	DllStructSetData($tpoint, "Y", $nuly)
	DllStructSetData($tpoint, "X2", $nurx)
	DllStructSetData($tpoint, "Y2", $nury)
	DllStructSetData($tpoint, "X3", $nllx)
	DllStructSetData($tpoint, "Y3", $nlly)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawImagePoints", "handle", $hgraphic, "handle", $himage, "struct*", $tpoint, "int", $icount)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_encoders()
	Local $icount = _gdiplus_encodersgetcount()
	Local $isize = _gdiplus_encodersgetsize()
	Local $tbuffer = DllStructCreate("byte[" & $isize & "]")
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImageEncoders", "uint", $icount, "uint", $isize, "struct*", $tbuffer)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Local $pbuffer = DllStructGetPtr($tbuffer)
	Local $tcodec, $ainfo[$icount + 1][14]
	$ainfo[0][0] = $icount
	For $ii = 1 To $icount
		$tcodec = DllStructCreate($taggdipimagecodecinfo, $pbuffer)
		$ainfo[$ii][1] = _winapi_stringfromguid(DllStructGetPtr($tcodec, "CLSID"))
		$ainfo[$ii][2] = _winapi_stringfromguid(DllStructGetPtr($tcodec, "FormatID"))
		$ainfo[$ii][3] = _winapi_widechartomultibyte(DllStructGetData($tcodec, "CodecName"))
		$ainfo[$ii][4] = _winapi_widechartomultibyte(DllStructGetData($tcodec, "DllName"))
		$ainfo[$ii][5] = _winapi_widechartomultibyte(DllStructGetData($tcodec, "FormatDesc"))
		$ainfo[$ii][6] = _winapi_widechartomultibyte(DllStructGetData($tcodec, "FileExt"))
		$ainfo[$ii][7] = _winapi_widechartomultibyte(DllStructGetData($tcodec, "MimeType"))
		$ainfo[$ii][8] = DllStructGetData($tcodec, "Flags")
		$ainfo[$ii][9] = DllStructGetData($tcodec, "Version")
		$ainfo[$ii][10] = DllStructGetData($tcodec, "SigCount")
		$ainfo[$ii][11] = DllStructGetData($tcodec, "SigSize")
		$ainfo[$ii][12] = DllStructGetData($tcodec, "SigPattern")
		$ainfo[$ii][13] = DllStructGetData($tcodec, "SigMask")
		$pbuffer += DllStructGetSize($tcodec)
	Next
	Return $ainfo
EndFunc

Func _gdiplus_encodersgetclsid($sfileextension)
	Local $aencoders = _gdiplus_encoders()
	If @error Then Return SetError(@error, 0, "")
	For $ii = 1 To $aencoders[0][0]
		If StringInStr($aencoders[$ii][6], "*." & $sfileextension) > 0 Then Return $aencoders[$ii][1]
	Next
	Return SetError(-1, -1, "")
EndFunc

Func _gdiplus_encodersgetcount()
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImageEncodersSize", "uint*", 0, "uint*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[1]
EndFunc

Func _gdiplus_encodersgetparamlist($himage, $sencoder)
	Local $isize = _gdiplus_encodersgetparamlistsize($himage, $sencoder)
	If @error Then Return SetError(@error + 10, @extended, 0)
	Local $tguid = _winapi_guidfromstring($sencoder)
	Local $iremainingsize = $isize - 4 - _gdiplus_paramsize()
	Local $tbuffer
	If $iremainingsize Then
		$tbuffer = DllStructCreate("dword Count;" & $taggdipencoderparam & ";byte [" & $iremainingsize & "]")
	Else
		$tbuffer = DllStructCreate("dword Count;" & $taggdipencoderparam)
	EndIf
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetEncoderParameterList", "handle", $himage, "struct*", $tguid, "uint", $isize, "struct*", $tbuffer)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $tbuffer
EndFunc

Func _gdiplus_encodersgetparamlistsize($himage, $sencoder)
	Local $tguid = _winapi_guidfromstring($sencoder)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetEncoderParameterListSize", "handle", $himage, "struct*", $tguid, "uint*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[3]
EndFunc

Func _gdiplus_encodersgetsize()
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImageEncodersSize", "uint*", 0, "uint*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_fontcreate($hfamily, $fsize, $istyle = 0, $iunit = 3)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateFont", "handle", $hfamily, "float", $fsize, "int", $istyle, "int", $iunit, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[5]
EndFunc

Func _gdiplus_fontdispose($hfont)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDeleteFont", "handle", $hfont)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_fontfamilycreate($sfamily, $pcollection = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateFontFamilyFromName", "wstr", $sfamily, "ptr", $pcollection, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[3]
EndFunc

Func _gdiplus_fontfamilycreatefromcollection($sfontname, $hfontcollection)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateFontFamilyFromName", "wstr", $sfontname, "ptr", $hfontcollection, "ptr*", 0)
	If @error Then Return SetError(@error, @extended, "")
	If $aresult[0] Then Return SetError(10, $aresult[0], "")
	Return $aresult[3]
EndFunc

Func _gdiplus_fontfamilydispose($hfamily)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDeleteFontFamily", "handle", $hfamily)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_fontfamilygetcellascent($hfontfamily, $istyle = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetCellAscent", "handle", $hfontfamily, "int", $istyle, "ushort*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[3]
EndFunc

Func _gdiplus_fontfamilygetcelldescent($hfontfamily, $istyle = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetCellDescent", "handle", $hfontfamily, "int", $istyle, "ushort*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[3]
EndFunc

Func _gdiplus_fontfamilygetemheight($hfontfamily, $istyle = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetEmHeight", "handle", $hfontfamily, "int", $istyle, "ushort*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[3]
EndFunc

Func _gdiplus_fontfamilygetlinespacing($hfontfamily, $istyle = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetLineSpacing", "handle", $hfontfamily, "int", $istyle, "ushort*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[3]
EndFunc

Func _gdiplus_fontgetheight($hfont, $hgraphics)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetFontHeight", "handle", $hfont, "handle", $hgraphics, "float*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[3]
EndFunc

Func _gdiplus_fontprivateaddfont($hfontcollection, $sfontfile)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipPrivateAddFontFile", "ptr", $hfontcollection, "wstr", $sfontfile)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_fontprivateaddmemoryfont($hfontcollection, $tfont)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipPrivateAddMemoryFont", "handle", $hfontcollection, "struct*", $tfont, "int", DllStructGetSize($tfont))
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_fontprivatecollectiondispose($hfontcollection)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDeletePrivateFontCollection", "handle*", $hfontcollection)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_fontprivatecreatecollection()
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipNewPrivateFontCollection", "ptr*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[1]
EndFunc

Func _gdiplus_graphicsclear($hgraphics, $iargb = -16777216)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGraphicsClear", "handle", $hgraphics, "dword", $iargb)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicscreatefromhdc($hdc)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateFromHDC", "handle", $hdc, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_graphicscreatefromhwnd($hwnd)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateFromHWND", "hwnd", $hwnd, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_graphicsdispose($hgraphics)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDeleteGraphics", "handle", $hgraphics)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawarc($hgraphics, $nx, $ny, $nwidth, $nheight, $fstartangle, $fsweepangle, $hpen = 0)
	__gdiplus_pendefcreate($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawArc", "handle", $hgraphics, "handle", $hpen, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight, "float", $fstartangle, "float", $fsweepangle)
	__gdiplus_pendefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawbezier($hgraphics, $nx1, $ny1, $nx2, $ny2, $nx3, $ny3, $nx4, $ny4, $hpen = 0)
	__gdiplus_pendefcreate($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawBezier", "handle", $hgraphics, "handle", $hpen, "float", $nx1, "float", $ny1, "float", $nx2, "float", $ny2, "float", $nx3, "float", $ny3, "float", $nx4, "float", $ny4)
	__gdiplus_pendefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawclosedcurve($hgraphics, $apoints, $hpen = 0)
	Local $icount = $apoints[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	__gdiplus_pendefcreate($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawClosedCurve", "handle", $hgraphics, "handle", $hpen, "struct*", $tpoints, "int", $icount)
	__gdiplus_pendefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawclosedcurve2($hgraphics, $apoints, $ntension, $hpen = 0)
	Local $ii, $icount, $tpoints, $aresult
	__gdiplus_pendefcreate($hpen)
	$icount = $apoints[0][0]
	$tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	$aresult = DllCall($__g_hgdipdll, "int", "GdipDrawClosedCurve2", "handle", $hgraphics, "handle", $hpen, "struct*", $tpoints, "int", $icount, "float", $ntension)
	__gdiplus_pendefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawcurve($hgraphics, $apoints, $hpen = 0)
	Local $icount = $apoints[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	__gdiplus_pendefcreate($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawCurve", "handle", $hgraphics, "handle", $hpen, "struct*", $tpoints, "int", $icount)
	__gdiplus_pendefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawcurve2($hgraphics, $apoints, $ntension, $hpen = 0)
	Local $ii, $icount, $tpoints, $aresult
	__gdiplus_pendefcreate($hpen)
	$icount = $apoints[0][0]
	$tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	$aresult = DllCall($__g_hgdipdll, "int", "GdipDrawCurve2", "handle", $hgraphics, "handle", $hpen, "struct*", $tpoints, "int", $icount, "float", $ntension)
	__gdiplus_pendefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawellipse($hgraphics, $nx, $ny, $nwidth, $nheight, $hpen = 0)
	__gdiplus_pendefcreate($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawEllipse", "handle", $hgraphics, "handle", $hpen, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight)
	__gdiplus_pendefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawimage($hgraphics, $himage, $nx, $ny)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawImage", "handle", $hgraphics, "handle", $himage, "float", $nx, "float", $ny)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawimagepointsrect($hgraphics, $himage, $nulx, $nuly, $nurx, $nury, $nllx, $nlly, $nsrcx, $nsrcy, $nsrcwidth, $nsrcheight, $himageattributes = 0, $iunit = 2)
	Local $tpoints = DllStructCreate("float X; float Y; float X2; float Y2; float X3; float Y3;")
	DllStructSetData($tpoints, "X", $nulx)
	DllStructSetData($tpoints, "Y", $nuly)
	DllStructSetData($tpoints, "X2", $nurx)
	DllStructSetData($tpoints, "Y2", $nury)
	DllStructSetData($tpoints, "X3", $nllx)
	DllStructSetData($tpoints, "Y3", $nlly)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawImagePointsRect", "handle", $hgraphics, "handle", $himage, "struct*", $tpoints, "int", 3, "float", $nsrcx, "float", $nsrcy, "float", $nsrcwidth, "float", $nsrcheight, "int", $iunit, "handle", $himageattributes, "ptr", 0, "ptr", 0)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawimagerect($hgraphics, $himage, $nx, $ny, $nw, $nh)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawImageRect", "handle", $hgraphics, "handle", $himage, "float", $nx, "float", $ny, "float", $nw, "float", $nh)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawimagerectrect($hgraphics, $himage, $nsrcx, $nsrcy, $nsrcwidth, $nsrcheight, $ndstx, $ndsty, $ndstwidth, $ndstheight, $pattributes = 0, $iunit = 2)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawImageRectRect", "handle", $hgraphics, "handle", $himage, "float", $ndstx, "float", $ndsty, "float", $ndstwidth, "float", $ndstheight, "float", $nsrcx, "float", $nsrcy, "float", $nsrcwidth, "float", $nsrcheight, "int", $iunit, "handle", $pattributes, "ptr", 0, "ptr", 0)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawline($hgraphics, $nx1, $ny1, $nx2, $ny2, $hpen = 0)
	__gdiplus_pendefcreate($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawLine", "handle", $hgraphics, "handle", $hpen, "float", $nx1, "float", $ny1, "float", $nx2, "float", $ny2)
	__gdiplus_pendefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawpath($hgraphics, $hpath, $hpen = 0)
	__gdiplus_pendefcreate($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawPath", "handle", $hgraphics, "handle", $hpen, "handle", $hpath)
	__gdiplus_pendefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawpie($hgraphics, $nx, $ny, $nwidth, $nheight, $fstartangle, $fsweepangle, $hpen = 0)
	__gdiplus_pendefcreate($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawPie", "handle", $hgraphics, "handle", $hpen, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight, "float", $fstartangle, "float", $fsweepangle)
	__gdiplus_pendefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawpolygon($hgraphics, $apoints, $hpen = 0)
	Local $icount = $apoints[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	__gdiplus_pendefcreate($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawPolygon", "handle", $hgraphics, "handle", $hpen, "struct*", $tpoints, "int", $icount)
	__gdiplus_pendefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawrect($hgraphics, $nx, $ny, $nwidth, $nheight, $hpen = 0)
	__gdiplus_pendefcreate($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawRectangle", "handle", $hgraphics, "handle", $hpen, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight)
	__gdiplus_pendefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsdrawstring($hgraphics, $sstring, $nx, $ny, $sfont = "Arial", $fsize = 10, $iformat = 0)
	Local $hbrush = _gdiplus_brushcreatesolid()
	Local $hformat = _gdiplus_stringformatcreate($iformat)
	Local $hfamily = _gdiplus_fontfamilycreate($sfont)
	Local $hfont = _gdiplus_fontcreate($hfamily, $fsize)
	Local $tlayout = _gdiplus_rectfcreate($nx, $ny, 0, 0)
	Local $ainfo = _gdiplus_graphicsmeasurestring($hgraphics, $sstring, $hfont, $tlayout, $hformat)
	If @error Then Return SetError(@error, @extended, 0)
	Local $aresult = _gdiplus_graphicsdrawstringex($hgraphics, $sstring, $hfont, $ainfo[0], $hformat, $hbrush)
	Local $ierror = @error, $iextended = @extended
	_gdiplus_fontdispose($hfont)
	_gdiplus_fontfamilydispose($hfamily)
	_gdiplus_stringformatdispose($hformat)
	_gdiplus_brushdispose($hbrush)
	Return SetError($ierror, $iextended, $aresult)
EndFunc

Func _gdiplus_graphicsdrawstringex($hgraphics, $sstring, $hfont, $tlayout, $hformat, $hbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawString", "handle", $hgraphics, "wstr", $sstring, "int", -1, "handle", $hfont, "struct*", $tlayout, "handle", $hformat, "handle", $hbrush)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsfillclosedcurve($hgraphics, $apoints, $hbrush = 0)
	Local $icount = $apoints[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	__gdiplus_brushdefcreate($hbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipFillClosedCurve", "handle", $hgraphics, "handle", $hbrush, "struct*", $tpoints, "int", $icount)
	__gdiplus_brushdefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsfillclosedcurve2($hgraphics, $apoints, $ntension, $hbrush = 0, $ifillmode = 0)
	Local $ii, $icount, $tpoints, $aresult
	__gdiplus_brushdefcreate($hbrush)
	$icount = $apoints[0][0]
	$tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	$aresult = DllCall($__g_hgdipdll, "int", "GdipFillClosedCurve2", "handle", $hgraphics, "handle", $hbrush, "struct*", $tpoints, "int", $icount, "float", $ntension, "int", $ifillmode)
	__gdiplus_brushdefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsfillellipse($hgraphics, $nx, $ny, $nwidth, $nheight, $hbrush = 0)
	__gdiplus_brushdefcreate($hbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipFillEllipse", "handle", $hgraphics, "handle", $hbrush, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight)
	__gdiplus_brushdefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsfillpath($hgraphics, $hpath, $hbrush = 0)
	__gdiplus_brushdefcreate($hbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipFillPath", "handle", $hgraphics, "handle", $hbrush, "handle", $hpath)
	__gdiplus_brushdefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsfillpie($hgraphics, $nx, $ny, $nwidth, $nheight, $fstartangle, $fsweepangle, $hbrush = 0)
	__gdiplus_brushdefcreate($hbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipFillPie", "handle", $hgraphics, "handle", $hbrush, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight, "float", $fstartangle, "float", $fsweepangle)
	__gdiplus_brushdefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsfillpolygon($hgraphics, $apoints, $hbrush = 0)
	Local $icount = $apoints[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	__gdiplus_brushdefcreate($hbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipFillPolygon", "handle", $hgraphics, "handle", $hbrush, "struct*", $tpoints, "int", $icount, "int", "FillModeAlternate")
	__gdiplus_brushdefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsfillrect($hgraphics, $nx, $ny, $nwidth, $nheight, $hbrush = 0)
	__gdiplus_brushdefcreate($hbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipFillRectangle", "handle", $hgraphics, "handle", $hbrush, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight)
	__gdiplus_brushdefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsfillregion($hgraphics, $hregion, $hbrush = 0)
	__gdiplus_brushdefcreate($hbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipFillRegion", "handle", $hgraphics, "handle", $hbrush, "handle", $hregion)
	__gdiplus_brushdefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsgetcompositingmode($hgraphics)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetCompositingMode", "handle", $hgraphics, "int*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_graphicsgetcompositingquality($hgraphics)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetCompositingQuality", "handle", $hgraphics, "int*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_graphicsgetdc($hgraphics)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetDC", "handle", $hgraphics, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_graphicsgetinterpolationmode($hgraphics)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetInterpolationMode", "handle", $hgraphics, "int*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_graphicsgetsmoothingmode($hgraphics)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetSmoothingMode", "handle", $hgraphics, "int*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Switch $aresult[2]
		Case $gdip_smoothingmode_none
			Return 0
		Case $gdip_smoothingmode_highquality, $gdip_smoothingmode_antialias8x4
			Return 1
		Case $gdip_smoothingmode_antialias8x8
			Return 2
		Case Else
			Return 0
	EndSwitch
EndFunc

Func _gdiplus_graphicsgettransform($hgraphics, $hmatrix)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetWorldTransform", "handle", $hgraphics, "handle", $hmatrix)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsmeasurecharacterranges($hgraphics, $sstring, $hfont, $tlayout, $hstringformat)
	Local $icount = _gdiplus_stringformatgetmeasurablecharacterrangecount($hstringformat)
	If @error Then Return SetError(@error, @extended, 0)
	Local $tregions = DllStructCreate("handle[" & $icount & "]")
	Local $aregions[$icount + 1] = [$icount]
	For $ii = 1 To $icount
		$aregions[$ii] = _gdiplus_regioncreate()
		DllStructSetData($tregions, 1, $aregions[$ii], $ii)
	Next
	DllCall($__g_hgdipdll, "int", "GdipMeasureCharacterRanges", "handle", $hgraphics, "wstr", $sstring, "int", -1, "hwnd", $hfont, "struct*", $tlayout, "handle", $hstringformat, "int", $icount, "struct*", $tregions)
	Local $ierror = @error, $iextended = @extended
	If $ierror Then
		For $ii = 1 To $icount
			_gdiplus_regiondispose($aregions[$ii])
		Next
		Return SetError($ierror + 10, $iextended, 0)
	EndIf
	Return $aregions
EndFunc

Func _gdiplus_graphicsmeasurestring($hgraphics, $sstring, $hfont, $tlayout, $hformat)
	Local $trectf = DllStructCreate($taggdiprectf)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipMeasureString", "handle", $hgraphics, "wstr", $sstring, "int", -1, "handle", $hfont, "struct*", $tlayout, "handle", $hformat, "struct*", $trectf, "int*", 0, "int*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Local $ainfo[3]
	$ainfo[0] = $trectf
	$ainfo[1] = $aresult[8]
	$ainfo[2] = $aresult[9]
	Return $ainfo
EndFunc

Func _gdiplus_graphicsreleasedc($hgraphics, $hdc)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipReleaseDC", "handle", $hgraphics, "handle", $hdc)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_graphicsresetclip($hgraphics)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipResetClip", "handle", $hgraphics)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsresettransform($hgraphics)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipResetWorldTransform", "handle", $hgraphics)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsrestore($hgraphics, $istate)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipRestoreGraphics", "handle", $hgraphics, "uint", $istate)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicsrotatetransform($hgraphics, $fangle, $iorder = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipRotateWorldTransform", "handle", $hgraphics, "float", $fangle, "int", $iorder)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicssave($hgraphics)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSaveGraphics", "handle", $hgraphics, "uint*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_graphicsscaletransform($hgraphics, $fscalex, $fscaley, $iorder = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipScaleWorldTransform", "handle", $hgraphics, "float", $fscalex, "float", $fscaley, "int", $iorder)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicssetclippath($hgraphics, $hpath, $icombinemode = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetClipPath", "handle", $hgraphics, "handle", $hpath, "int", $icombinemode)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicssetcliprect($hgraphics, $nx, $ny, $nwidth, $nheight, $icombinemode = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetClipRect", "handle", $hgraphics, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight, "int", $icombinemode)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicssetclipregion($hgraphics, $hregion, $icombinemode = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetClipRegion", "handle", $hgraphics, "handle", $hregion, "int", $icombinemode)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicssetcompositingmode($hgraphics, $icompositionmode)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetCompositingMode", "handle", $hgraphics, "int", $icompositionmode)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicssetcompositingquality($hgraphics, $icompositionquality)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetCompositingQuality", "handle", $hgraphics, "int", $icompositionquality)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicssetinterpolationmode($hgraphics, $iinterpolationmode)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetInterpolationMode", "handle", $hgraphics, "int", $iinterpolationmode)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicssetpixeloffsetmode($hgraphics, $ipixeloffsetmode)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPixelOffsetMode", "handle", $hgraphics, "int", $ipixeloffsetmode)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicssetsmoothingmode($hgraphics, $ismooth)
	If $ismooth < $gdip_smoothingmode_default OR $ismooth > $gdip_smoothingmode_antialias8x8 Then $ismooth = $gdip_smoothingmode_default
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetSmoothingMode", "handle", $hgraphics, "int", $ismooth)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicssettextrenderinghint($hgraphics, $itextrenderinghint)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetTextRenderingHint", "handle", $hgraphics, "int", $itextrenderinghint)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicssettransform($hgraphics, $hmatrix)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetWorldTransform", "handle", $hgraphics, "handle", $hmatrix)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_graphicstransformpoints($hgraphics, ByRef $apoints, $icoordspaceto = 0, $icoordspacefrom = 1)
	Local $icount = $apoints[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], ($ii - 1) * 2 + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], ($ii - 1) * 2 + 2)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipTransformPoints", "handle", $hgraphics, "int", $icoordspaceto, "int", $icoordspacefrom, "struct*", $tpoints, "int", $icount)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	For $ii = 1 To $icount
		$apoints[$ii][0] = DllStructGetData($tpoints, 1, ($ii - 1) * 2 + 1)
		$apoints[$ii][1] = DllStructGetData($tpoints, 1, ($ii - 1) * 2 + 2)
	Next
	Return True
EndFunc

Func _gdiplus_graphicstranslatetransform($hgraphics, $ndx, $ndy, $iorder = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipTranslateWorldTransform", "handle", $hgraphics, "float", $ndx, "float", $ndy, "int", $iorder)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_hatchbrushcreate($ihatchstyle = 0, $iargbforeground = -1, $iargbbackground = -1)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateHatchBrush", "int", $ihatchstyle, "uint", $iargbforeground, "uint", $iargbbackground, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[4]
EndFunc

Func _gdiplus_hiconcreatefrombitmap($hbitmap)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateHICONFromBitmap", "handle", $hbitmap, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_imageattributescreate()
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateImageAttributes", "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[1]
EndFunc

Func _gdiplus_imageattributesdispose($himageattributes)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDisposeImageAttributes", "handle", $himageattributes)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_imageattributessetcolorkeys($himageattributes, $icoloradjusttype = 0, $benable = False, $iargblow = 0, $iargbhigh = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetImageAttributesColorKeys", "handle", $himageattributes, "int", $icoloradjusttype, "int", $benable, "uint", $iargblow, "uint", $iargbhigh)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_imageattributessetcolormatrix($himageattributes, $icoloradjusttype = 0, $benable = False, $tclrmatrix = 0, $tgraymatrix = 0, $icolormatrixflags = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetImageAttributesColorMatrix", "handle", $himageattributes, "int", $icoloradjusttype, "int", $benable, "struct*", $tclrmatrix, "struct*", $tgraymatrix, "int", $icolormatrixflags)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_imagedispose($himage)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDisposeImage", "handle", $himage)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_imagegetdimension($himage)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImageDimension", "handle", $himage, "float*", 0, "float*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Local $aimgdim[2] = [$aresult[2], $aresult[3]]
	Return $aimgdim
EndFunc

Func _gdiplus_imagegetflags($himage)
	Local $aflag[2] = [0, ""]
	If ($himage = -1) OR (NOT $himage) Then Return SetError(11, 0, $aflag)
	Local $aimageflags[13][2] = [["Pixel data Cacheable", $gdip_imageflags_caching], ["Pixel data read-only", $gdip_imageflags_readonly], ["Pixel size in image", $gdip_imageflags_hasrealpixelsize], ["DPI info in image", $gdip_imageflags_hasrealdpi], ["YCCK color space", $gdip_imageflags_colorspace_ycck], ["YCBCR color space", $gdip_imageflags_colorspace_ycbcr], ["Grayscale image", $gdip_imageflags_colorspace_gray], ["CMYK color space", $gdip_imageflags_colorspace_cmyk], ["RGB color space", $gdip_imageflags_colorspace_rgb], ["Partially scalable", $gdip_imageflags_partiallyscalable], ["Alpha values other than 0 (transparent) and 255 (opaque)", $gdip_imageflags_hastranslucent], ["Alpha values", $gdip_imageflags_hasalpha], ["Scalable", $gdip_imageflags_scalable]]
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImageFlags", "handle", $himage, "long*", 0)
	If @error Then Return SetError(@error, @extended, $aflag)
	If $aresult[0] Then Return SetError(10, $aresult[0], $aflag)
	If $aresult[2] = $gdip_imageflags_none Then
		$aflag[1] = "No pixel data"
		Return SetError(12, $aresult[2], $aflag)
	EndIf
	$aflag[0] = $aresult[2]
	For $i = 0 To 12
		If BitAND($aresult[2], $aimageflags[$i][1]) = $aimageflags[$i][1] Then
			If StringLen($aflag[1]) Then $aflag[1] &= "|"
			$aresult[2] -= $aimageflags[$i][1]
			$aflag[1] &= $aimageflags[$i][0]
		EndIf
	Next
	Return $aflag
EndFunc

Func _gdiplus_imagegetgraphicscontext($himage)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImageGraphicsContext", "handle", $himage, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_imagegetheight($himage)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImageHeight", "handle", $himage, "uint*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_imagegethorizontalresolution($himage)
	If ($himage = -1) OR (NOT $himage) Then Return SetError(11, 0, 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImageHorizontalResolution", "handle", $himage, "float*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return Round($aresult[2])
EndFunc

Func _gdiplus_imagegetpixelformat($himage)
	Local $aformat[2] = [0, ""]
	If ($himage = -1) OR (NOT $himage) Then Return SetError(11, 0, $aformat)
	Local $apixelformat[14][2] = [["1 Bpp Indexed", $gdip_pxf01indexed], ["4 Bpp Indexed", $gdip_pxf04indexed], ["8 Bpp Indexed", $gdip_pxf08indexed], ["16 Bpp Grayscale", $gdip_pxf16grayscale], ["16 Bpp RGB 555", $gdip_pxf16rgb555], ["16 Bpp RGB 565", $gdip_pxf16rgb565], ["16 Bpp ARGB 1555", $gdip_pxf16argb1555], ["24 Bpp RGB", $gdip_pxf24rgb], ["32 Bpp RGB", $gdip_pxf32rgb], ["32 Bpp ARGB", $gdip_pxf32argb], ["32 Bpp PARGB", $gdip_pxf32pargb], ["48 Bpp RGB", $gdip_pxf48rgb], ["64 Bpp ARGB", $gdip_pxf64argb], ["64 Bpp PARGB", $gdip_pxf64pargb]]
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImagePixelFormat", "handle", $himage, "int*", 0)
	If @error Then Return SetError(@error, @extended, $aformat)
	If $aresult[0] Then Return SetError(10, $aresult[0], $aformat)
	For $i = 0 To 13
		If $apixelformat[$i][1] = $aresult[2] Then
			$aformat[0] = $apixelformat[$i][1]
			$aformat[1] = $apixelformat[$i][0]
			Return $aformat
		EndIf
	Next
	Return SetError(12, 0, $aformat)
EndFunc

Func _gdiplus_imagegetrawformat($himage)
	Local $aguid[2]
	If ($himage = -1) OR (NOT $himage) Then Return SetError(11, 0, $aguid)
	Local $aimagetype[11][2] = [["UNDEFINED", $gdip_imageformat_undefined], ["MEMORYBMP", $gdip_imageformat_memorybmp], ["BMP", $gdip_imageformat_bmp], ["EMF", $gdip_imageformat_emf], ["WMF", $gdip_imageformat_wmf], ["JPEG", $gdip_imageformat_jpeg], ["PNG", $gdip_imageformat_png], ["GIF", $gdip_imageformat_gif], ["TIFF", $gdip_imageformat_tiff], ["EXIF", $gdip_imageformat_exif], ["ICON", $gdip_imageformat_icon]]
	Local $tstruct = DllStructCreate("byte[16]")
	Local $aresult1 = DllCall($__g_hgdipdll, "int", "GdipGetImageRawFormat", "handle", $himage, "struct*", $tstruct)
	If @error Then Return SetError(@error, @extended, $aguid)
	If $aresult1[0] Then Return SetError(10, $aresult1[0], $aguid)
	Local $sresult2 = _winapi_stringfromguid($aresult1[2])
	If @error Then Return SetError(@error + 20, @extended, $aguid)
	If $sresult2 = "" Then Return SetError(12, 0, $aguid)
	For $i = 0 To 10
		If $aimagetype[$i][1] == $sresult2 Then
			$aguid[0] = $aimagetype[$i][1]
			$aguid[1] = $aimagetype[$i][0]
			Return $aguid
		EndIf
	Next
	Return SetError(13, 0, $aguid)
EndFunc

Func _gdiplus_imagegetthumbnail($himage, $iwidth = 0, $iheight = 0, $bkeepratio = True, $hcallback = NULL , $hcallbackdata = NULL )
	If $bkeepratio Then
		Local $aimgdim = _gdiplus_imagegetdimension($himage)
		If @error Then Return SetError(@error + 20, @extended, False)
		Local $f
		If $iwidth < 1 OR $iheight < 1 Then
			$iwidth = 0
			$iheight = 0
		Else
			If ($aimgdim[0] / $aimgdim[1]) > 1 Then
				$f = $aimgdim[0] / $iwidth
			Else
				$f = $aimgdim[1] / $iheight
			EndIf
			$iwidth = Int($aimgdim[0] / $f)
			$iheight = Int($aimgdim[1] / $f)
		EndIf
	EndIf
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImageThumbnail", "handle", $himage, "uint", $iwidth, "uint", $iheight, "ptr*", 0, "ptr", $hcallback, "ptr", $hcallbackdata)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return $aresult[4]
EndFunc

Func _gdiplus_imagegettype($himage)
	If ($himage = -1) OR (NOT $himage) Then Return SetError(11, 0, -1)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImageType", "handle", $himage, "int*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_imagegetverticalresolution($himage)
	If ($himage = -1) OR (NOT $himage) Then Return SetError(11, 0, 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImageVerticalResolution", "handle", $himage, "float*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return Round($aresult[2])
EndFunc

Func _gdiplus_imagegetwidth($himage)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetImageWidth", "handle", $himage, "uint*", -1)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_imageloadfromfile($sfilename)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipLoadImageFromFile", "wstr", $sfilename, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_imageloadfromstream($pstream)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipLoadImageFromStream", "ptr", $pstream, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_imagerotateflip($himage, $irotatefliptype)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipImageRotateFlip", "handle", $himage, "int", $irotatefliptype)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_imagesavetofile($himage, $sfilename)
	Local $sext = __gdiplus_extractfileext($sfilename)
	Local $sclsid = _gdiplus_encodersgetclsid($sext)
	If $sclsid = "" Then Return SetError(-1, 0, False)
	Local $bret = _gdiplus_imagesavetofileex($himage, $sfilename, $sclsid, 0)
	Return SetError(@error, @extended, $bret)
EndFunc

Func _gdiplus_imagesavetofileex($himage, $sfilename, $sencoder, $tparams = 0)
	Local $tguid = _winapi_guidfromstring($sencoder)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSaveImageToFile", "handle", $himage, "wstr", $sfilename, "struct*", $tguid, "struct*", $tparams)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_imagesavetostream($himage, $pstream, $tencoder, $tparams = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSaveImageToStream", "handle", $himage, "ptr", $pstream, "struct*", $tencoder, "struct*", $tparams)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_imagescale($himage, $iscalew, $iscaleh, $iinterpolationmode = $gdip_interpolationmode_highqualitybicubic)
	Local $iwidth = _gdiplus_imagegetwidth($himage) * $iscalew
	If @error Then Return SetError(1, 0, 0)
	Local $iheight = _gdiplus_imagegetheight($himage) * $iscaleh
	If @error Then Return SetError(2, 0, 0)
	Local $hbitmap = _gdiplus_bitmapcreatefromscan0($iwidth, $iheight)
	If @error Then Return SetError(3, 0, 0)
	Local $hbmpctxt = _gdiplus_imagegetgraphicscontext($hbitmap)
	If @error Then
		_gdiplus_bitmapdispose($hbitmap)
		Return SetError(4, 0, 0)
	EndIf
	_gdiplus_graphicssetinterpolationmode($hbmpctxt, $iinterpolationmode)
	If @error Then
		_gdiplus_graphicsdispose($hbmpctxt)
		_gdiplus_bitmapdispose($hbitmap)
		Return SetError(5, 0, 0)
	EndIf
	_gdiplus_graphicsdrawimagerect($hbmpctxt, $himage, 0, 0, $iwidth, $iheight)
	If @error Then
		_gdiplus_graphicsdispose($hbmpctxt)
		_gdiplus_bitmapdispose($hbitmap)
		Return SetError(6, 0, 0)
	EndIf
	_gdiplus_graphicsdispose($hbmpctxt)
	Return $hbitmap
EndFunc

Func _gdiplus_imageresize($himage, $inewwidth, $inewheight, $iinterpolationmode = $gdip_interpolationmode_highqualitybicubic)
	Local $hbitmap = _gdiplus_bitmapcreatefromscan0($inewwidth, $inewheight)
	If @error Then Return SetError(1, 0, 0)
	Local $hbmpctxt = _gdiplus_imagegetgraphicscontext($hbitmap)
	If @error Then
		_gdiplus_bitmapdispose($hbitmap)
		Return SetError(2, @extended, 0)
	EndIf
	_gdiplus_graphicssetinterpolationmode($hbmpctxt, $iinterpolationmode)
	If @error Then
		_gdiplus_graphicsdispose($hbmpctxt)
		_gdiplus_bitmapdispose($hbitmap)
		Return SetError(3, @extended, 0)
	EndIf
	_gdiplus_graphicsdrawimagerect($hbmpctxt, $himage, 0, 0, $inewwidth, $inewheight)
	If @error Then
		_gdiplus_graphicsdispose($hbmpctxt)
		_gdiplus_bitmapdispose($hbitmap)
		Return SetError(4, @extended, 0)
	EndIf
	_gdiplus_graphicsdispose($hbmpctxt)
	Return $hbitmap
EndFunc

Func _gdiplus_linebrushcreate($nx1, $ny1, $nx2, $ny2, $iargbclr1, $iargbclr2, $iwrapmode = 0)
	Local $tpointf1, $tpointf2, $aresult
	$tpointf1 = DllStructCreate("float;float")
	$tpointf2 = DllStructCreate("float;float")
	DllStructSetData($tpointf1, 1, $nx1)
	DllStructSetData($tpointf1, 2, $ny1)
	DllStructSetData($tpointf2, 1, $nx2)
	DllStructSetData($tpointf2, 2, $ny2)
	$aresult = DllCall($__g_hgdipdll, "int", "GdipCreateLineBrush", "struct*", $tpointf1, "struct*", $tpointf2, "uint", $iargbclr1, "uint", $iargbclr2, "int", $iwrapmode, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[6]
EndFunc

Func _gdiplus_linebrushcreatefromrect($trectf, $iargbclr1, $iargbclr2, $igradientmode = 0, $iwrapmode = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateLineBrushFromRect", "struct*", $trectf, "uint", $iargbclr1, "uint", $iargbclr2, "int", $igradientmode, "int", $iwrapmode, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[6]
EndFunc

Func _gdiplus_linebrushcreatefromrectwithangle($trectf, $iargbclr1, $iargbclr2, $fangle, $bisanglescalable = True, $iwrapmode = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateLineBrushFromRectWithAngle", "struct*", $trectf, "uint", $iargbclr1, "uint", $iargbclr2, "float", $fangle, "int", $bisanglescalable, "int", $iwrapmode, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[7]
EndFunc

Func _gdiplus_linebrushgetcolors($hlinegradientbrush)
	Local $targbs, $aargbs[2], $aresult
	$targbs = DllStructCreate("uint;uint")
	$aresult = DllCall($__g_hgdipdll, "uint", "GdipGetLineColors", "handle", $hlinegradientbrush, "struct*", $targbs)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	$aargbs[0] = DllStructGetData($targbs, 1)
	$aargbs[1] = DllStructGetData($targbs, 2)
	Return $aargbs
EndFunc

Func _gdiplus_linebrushgetrect($hlinegradientbrush)
	Local $trectf = DllStructCreate($taggdiprectf)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetLineRect", "handle", $hlinegradientbrush, "struct*", $trectf)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Local $arectf[4]
	For $ii = 1 To 4
		$arectf[$ii - 1] = DllStructGetData($trectf, $ii)
	Next
	Return $arectf
EndFunc

Func _gdiplus_linebrushmultiplytransform($hlinegradientbrush, $hmatrix, $iorder = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipMultiplyLineTransform", "handle", $hlinegradientbrush, "handle", $hmatrix, "int", $iorder)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_linebrushresettransform($hlinegradientbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipResetLineTransform", "handle", $hlinegradientbrush)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_linebrushsetblend($hlinegradientbrush, $ablends)
	Local $ii, $icount, $tfactors, $tpositions, $aresult
	$icount = $ablends[0][0]
	$tfactors = DllStructCreate("float[" & $icount & "]")
	$tpositions = DllStructCreate("float[" & $icount & "]")
	For $ii = 1 To $icount
		DllStructSetData($tfactors, 1, $ablends[$ii][0], $ii)
		DllStructSetData($tpositions, 1, $ablends[$ii][1], $ii)
	Next
	$aresult = DllCall($__g_hgdipdll, "int", "GdipSetLineBlend", "handle", $hlinegradientbrush, "struct*", $tfactors, "struct*", $tpositions, "int", $icount)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_linebrushsetcolors($hlinegradientbrush, $iargbstart, $iargbend)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetLineColors", "handle", $hlinegradientbrush, "uint", $iargbstart, "uint", $iargbend)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_linebrushsetgammacorrection($hlinegradientbrush, $busegammacorrection = True)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetLineGammaCorrection", "handle", $hlinegradientbrush, "int", $busegammacorrection)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_linebrushsetlinearblend($hlinegradientbrush, $ffocus, $fscale = 1)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetLineLinearBlend", "handle", $hlinegradientbrush, "float", $ffocus, "float", $fscale)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_linebrushsetpresetblend($hlinegradientbrush, $ainterpolations)
	Local $ii, $icount, $tcolors, $tpositions, $aresult
	$icount = $ainterpolations[0][0]
	$tcolors = DllStructCreate("uint[" & $icount & "]")
	$tpositions = DllStructCreate("float[" & $icount & "]")
	For $ii = 1 To $icount
		DllStructSetData($tcolors, 1, $ainterpolations[$ii][0], $ii)
		DllStructSetData($tpositions, 1, $ainterpolations[$ii][1], $ii)
	Next
	$aresult = DllCall($__g_hgdipdll, "int", "GdipSetLinePresetBlend", "handle", $hlinegradientbrush, "struct*", $tcolors, "struct*", $tpositions, "int", $icount)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_linebrushsetsigmablend($hlinegradientbrush, $ffocus, $fscale = 1)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetLineSigmaBlend", "handle", $hlinegradientbrush, "float", $ffocus, "float", $fscale)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_linebrushsettransform($hlinegradientbrush, $hmatrix)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetLineTransform", "handle", $hlinegradientbrush, "handle", $hmatrix)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_matrixcreate()
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateMatrix", "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[1]
EndFunc

Func _gdiplus_matrixclone($hmatrix)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCloneMatrix", "handle", $hmatrix, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_matrixdispose($hmatrix)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDeleteMatrix", "handle", $hmatrix)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_matrixgetelements($hmatrix)
	Local $telements = DllStructCreate("float[6]")
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetMatrixElements", "handle", $hmatrix, "struct*", $telements)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Local $aelements[6]
	For $ii = 1 To 6
		$aelements[$ii - 1] = DllStructGetData($telements, 1, $ii)
	Next
	Return $aelements
EndFunc

Func _gdiplus_matrixinvert($hmatrix)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipInvertMatrix", "handle", $hmatrix)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_matrixmultiply($hmatrix1, $hmatrix2, $iorder = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipMultiplyMatrix", "handle", $hmatrix1, "handle", $hmatrix2, "int", $iorder)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_matrixrotate($hmatrix, $fangle, $bappend = False)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipRotateMatrix", "handle", $hmatrix, "float", $fangle, "int", $bappend)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_matrixscale($hmatrix, $fscalex, $fscaley, $border = False)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipScaleMatrix", "handle", $hmatrix, "float", $fscalex, "float", $fscaley, "int", $border)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_matrixsetelements($hmatrix, $nm11 = 1, $nm12 = 0, $nm21 = 0, $nm22 = 1, $ndx = 0, $ndy = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetMatrixElements", "handle", $hmatrix, "float", $nm11, "float", $nm12, "float", $nm21, "float", $nm22, "float", $ndx, "float", $ndy)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_matrixshear($hmatrix, $fshearx, $fsheary, $iorder = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipShearMatrix", "handle", $hmatrix, "float", $fshearx, "float", $fsheary, "int", $iorder)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_matrixtransformpoints($hmatrix, ByRef $apoints)
	Local $icount = $apoints[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], ($ii - 1) * 2 + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], ($ii - 1) * 2 + 2)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipTransformMatrixPoints", "handle", $hmatrix, "struct*", $tpoints, "int", $icount)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	For $ii = 1 To $icount
		$apoints[$ii][0] = DllStructGetData($tpoints, 1, ($ii - 1) * 2 + 1)
		$apoints[$ii][1] = DllStructGetData($tpoints, 1, ($ii - 1) * 2 + 2)
	Next
	Return True
EndFunc

Func _gdiplus_matrixtranslate($hmatrix, $foffsetx, $foffsety, $bappend = False)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipTranslateMatrix", "handle", $hmatrix, "float", $foffsetx, "float", $foffsety, "int", $bappend)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_paramadd(ByRef $tparams, $sguid, $inbofvalues, $itype, $pvalues)
	Local $icount = DllStructGetData($tparams, "Count")
	Local $pguid = DllStructGetPtr($tparams, "GUID") + ($icount * _gdiplus_paramsize())
	Local $tparam = DllStructCreate($taggdipencoderparam, $pguid)
	_winapi_guidfromstringex($sguid, $pguid)
	DllStructSetData($tparam, "Type", $itype)
	DllStructSetData($tparam, "NumberOfValues", $inbofvalues)
	DllStructSetData($tparam, "Values", $pvalues)
	DllStructSetData($tparams, "Count", $icount + 1)
EndFunc

Func _gdiplus_paraminit($icount)
	Local $sstruct = $taggdipencoderparams
	For $i = 2 To $icount
		$sstruct &= ";struct;byte[16];ulong;ulong;ptr;endstruct"
	Next
	Return DllStructCreate($sstruct)
EndFunc

Func _gdiplus_paramsize()
	Local $tparam = DllStructCreate($taggdipencoderparam)
	Return DllStructGetSize($tparam)
EndFunc

Func _gdiplus_pathaddarc($hpath, $nx, $ny, $nwidth, $nheight, $fstartangle, $fsweepangle)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipAddPathArc", "handle", $hpath, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight, "float", $fstartangle, "float", $fsweepangle)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathaddbezier($hpath, $nx1, $ny1, $nx2, $ny2, $nx3, $ny3, $nx4, $ny4)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipAddPathBezier", "handle", $hpath, "float", $nx1, "float", $ny1, "float", $nx2, "float", $ny2, "float", $nx3, "float", $ny3, "float", $nx4, "float", $ny4)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathaddclosedcurve($hpath, $apoints)
	Local $icount = $apoints[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipAddPathClosedCurve", "handle", $hpath, "struct*", $tpoints, "int", $icount)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathaddclosedcurve2($hpath, $apoints, $ntension = 0.5)
	Local $icount = $apoints[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipAddPathClosedCurve2", "handle", $hpath, "struct*", $tpoints, "int", $icount, "float", $ntension)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathaddcurve($hpath, $apoints)
	Local $icount = $apoints[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipAddPathCurve", "handle", $hpath, "struct*", $tpoints, "int", $icount)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathaddcurve2($hpath, $apoints, $ntension = 0.5)
	Local $icount = $apoints[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipAddPathCurve2", "handle", $hpath, "struct*", $tpoints, "int", $icount, "float", $ntension)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathaddcurve3($hpath, $apoints, $ioffset, $inumofsegments, $ntension = 0.5)
	Local $icount = $apoints[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipAddPathCurve3", "handle", $hpath, "struct*", $tpoints, "int", $icount, "int", $ioffset, "int", $inumofsegments, "float", $ntension)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathaddellipse($hpath, $nx, $ny, $nwidth, $nheight)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipAddPathEllipse", "handle", $hpath, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathaddline($hpath, $nx1, $ny1, $nx2, $ny2)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipAddPathLine", "handle", $hpath, "float", $nx1, "float", $ny1, "float", $nx2, "float", $ny2)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathaddline2($hpath, $apoints)
	Local $icount = $apoints[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipAddPathLine2", "handle", $hpath, "struct*", $tpoints, "int", $icount)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathaddpath($hpath1, $hpath2, $bconnect = True)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipAddPathPath", "handle", $hpath1, "handle", $hpath2, "int", $bconnect)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathaddpie($hpath, $nx, $ny, $nwidth, $nheight, $fstartangle, $fsweepangle)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipAddPathPie", "handle", $hpath, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight, "float", $fstartangle, "float", $fsweepangle)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathaddpolygon($hpath, $apoints)
	Local $icount = $apoints[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipAddPathPolygon", "handle", $hpath, "struct*", $tpoints, "int", $icount)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathaddrectangle($hpath, $nx, $ny, $nwidth, $nheight)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipAddPathRectangle", "handle", $hpath, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathaddstring($hpath, $sstring, $tlayout, $hfamily, $istyle = 0, $fsize = 8.5, $hformat = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipAddPathString", "handle", $hpath, "wstr", $sstring, "int", -1, "handle", $hfamily, "int", $istyle, "float", $fsize, "struct*", $tlayout, "handle", $hformat)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathbrushcreate($apoints, $iwrapmode = 0)
	Local $icount = $apoints[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], (($ii - 1) * 2) + 2)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreatePathGradient", "struct*", $tpoints, "int", $icount, "int", $iwrapmode, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[4]
EndFunc

Func _gdiplus_pathbrushcreatefrompath($hpath)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreatePathGradientFromPath", "handle", $hpath, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_pathbrushgetcenterpoint($hpathgradientbrush)
	Local $tpointf = DllStructCreate("float;float")
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPathGradientCenterPoint", "handle", $hpathgradientbrush, "struct*", $tpointf)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Local $apointf[2]
	$apointf[0] = DllStructGetData($tpointf, 1)
	$apointf[1] = DllStructGetData($tpointf, 2)
	Return $apointf
EndFunc

Func _gdiplus_pathbrushgetfocusscales($hpathgradientbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPathGradientFocusScales", "handle", $hpathgradientbrush, "float*", 0, "float*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Local $ascales[2]
	$ascales[0] = $aresult[2]
	$ascales[1] = $aresult[3]
	Return $ascales
EndFunc

Func _gdiplus_pathbrushgetpointcount($hpathgradientbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPathGradientPointCount", "handle", $hpathgradientbrush, "int*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_pathbrushgetrect($hpathgradientbrush)
	Local $trectf = DllStructCreate($taggdiprectf)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPathGradientRect", "handle", $hpathgradientbrush, "struct*", $trectf)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Local $arectf[4]
	For $ii = 1 To 4
		$arectf[$ii - 1] = DllStructGetData($trectf, $ii)
	Next
	Return $arectf
EndFunc

Func _gdiplus_pathbrushgetwrapmode($hpathgradientbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPathGradientWrapMode", "handle", $hpathgradientbrush, "int*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_pathbrushmultiplytransform($hpathgradientbrush, $hmatrix, $iorder = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipMultiplyPathGradientTransform", "handle", $hpathgradientbrush, "handle", $hmatrix, "int", $iorder)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathbrushresettransform($hpathgradientbrush)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipResetPathGradientTransform", "handle", $hpathgradientbrush)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathbrushsetblend($hpathgradientbrush, $ablends)
	Local $icount = $ablends[0][0]
	Local $tfactors = DllStructCreate("float[" & $icount & "]")
	Local $tpositions = DllStructCreate("float[" & $icount & "]")
	For $ii = 1 To $icount
		DllStructSetData($tfactors, 1, $ablends[$ii][0], $ii)
		DllStructSetData($tpositions, 1, $ablends[$ii][1], $ii)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientBlend", "handle", $hpathgradientbrush, "struct*", $tfactors, "struct*", $tpositions, "int", $icount)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathbrushsetcentercolor($hpathgradientbrush, $iargb)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientCenterColor", "handle", $hpathgradientbrush, "uint", $iargb)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathbrushsetcenterpoint($hpathgradientbrush, $nx, $ny)
	Local $tpointf = DllStructCreate("float;float")
	DllStructSetData($tpointf, 1, $nx)
	DllStructSetData($tpointf, 2, $ny)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientCenterPoint", "handle", $hpathgradientbrush, "struct*", $tpointf)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathbrushsetfocusscales($hpathgradientbrush, $fscalex, $fscaley)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientFocusScales", "handle", $hpathgradientbrush, "float", $fscalex, "float", $fscaley)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathbrushsetgammacorrection($hpathgradientbrush, $busegammacorrection)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientGammaCorrection", "handle", $hpathgradientbrush, "int", $busegammacorrection)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathbrushsetlinearblend($hpathgradientbrush, $ffocus, $fscale = 1)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientLinearBlend", "handle", $hpathgradientbrush, "float", $ffocus, "float", $fscale)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathbrushsetpresetblend($hpathgradientbrush, $ainterpolations)
	Local $icount = $ainterpolations[0][0]
	Local $tcolors = DllStructCreate("uint[" & $icount & "]")
	Local $tpositions = DllStructCreate("float[" & $icount & "]")
	For $ii = 1 To $icount
		DllStructSetData($tcolors, 1, $ainterpolations[$ii][0], $ii)
		DllStructSetData($tpositions, 1, $ainterpolations[$ii][1], $ii)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientPresetBlend", "handle", $hpathgradientbrush, "struct*", $tcolors, "struct*", $tpositions, "int", $icount)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathbrushsetsigmablend($hpathgradientbrush, $ffocus, $fscale = 1)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientSigmaBlend", "handle", $hpathgradientbrush, "float", $ffocus, "float", $fscale)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathbrushsetsurroundcolor($hpathgradientbrush, $iargb)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientSurroundColorsWithCount", "handle", $hpathgradientbrush, "uint*", $iargb, "int*", 1)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathbrushsetsurroundcolorswithcount($hpathgradientbrush, $acolors)
	Local $icount = $acolors[0]
	Local $icolors = _gdiplus_pathbrushgetpointcount($hpathgradientbrush)
	If $icolors < $icount Then $icount = $icolors
	Local $tcolors = DllStructCreate("uint[" & $icount & "]")
	For $ii = 1 To $icount
		DllStructSetData($tcolors, 1, $acolors[$ii], $ii)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientSurroundColorsWithCount", "handle", $hpathgradientbrush, "struct*", $tcolors, "int*", $icount)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[3]
EndFunc

Func _gdiplus_pathbrushsettransform($hpathgradientbrush, $hmatrix)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientTransform", "handle", $hpathgradientbrush, "handle", $hmatrix)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathbrushsetwrapmode($hpathgradientbrush, $iwrapmode)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPathGradientWrapMode", "handle", $hpathgradientbrush, "int", $iwrapmode)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathclone($hpath)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipClonePath", "handle", $hpath, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_pathclosefigure($hpath)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipClosePathFigure", "handle", $hpath)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathcreate($ifillmode = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreatePath", "int", $ifillmode, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_pathcreate2($apathdata, $ifillmode = 0)
	Local $icount = $apathdata[0][0]
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	Local $ttypes = DllStructCreate("byte[" & $icount & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apathdata[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tpoints, 1, $apathdata[$ii][1], (($ii - 1) * 2) + 2)
		DllStructSetData($ttypes, 1, $apathdata[$ii][2], $ii)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreatePath2", "struct*", $tpoints, "struct*", $ttypes, "int", $icount, "int", $ifillmode, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[5]
EndFunc

Func _gdiplus_pathdispose($hpath)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDeletePath", "handle", $hpath)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathflatten($hpath, $fflatness = 0.25, $hmatrix = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipFlattenPath", "handle", $hpath, "handle", $hmatrix, "float", $fflatness)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathgetdata($hpath)
	Local $icount = _gdiplus_pathgetpointcount($hpath)
	Local $tpathdata = DllStructCreate("int Count; ptr Points; ptr Types;")
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	Local $ttypes = DllStructCreate("byte[" & $icount & "]")
	DllStructSetData($tpathdata, "Count", $icount)
	DllStructSetData($tpathdata, "Points", DllStructGetPtr($tpoints))
	DllStructSetData($tpathdata, "Types", DllStructGetPtr($ttypes))
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPathData", "handle", $hpath, "struct*", $tpathdata)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError($aresult[0], $aresult[0], -1)
	Local $adata[$icount + 1][3]
	$adata[0][0] = $icount
	For $ii = 1 To $icount
		$adata[$ii][0] = DllStructGetData($tpoints, 1, (($ii - 1) * 2) + 1)
		$adata[$ii][1] = DllStructGetData($tpoints, 1, (($ii - 1) * 2) + 2)
		$adata[$ii][2] = DllStructGetData($ttypes, 1, $ii)
	Next
	Return $adata
EndFunc

Func _gdiplus_pathgetfillmode($hpath)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPathFillMode", "handle", $hpath, "int*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_pathgetlastpoint($hpath)
	Local $tpointf = DllStructCreate("float;float")
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPathLastPoint", "handle", $hpath, "struct*", $tpointf)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Local $apointf[2]
	$apointf[0] = DllStructGetData($tpointf, 1)
	$apointf[1] = DllStructGetData($tpointf, 2)
	Return $apointf
EndFunc

Func _gdiplus_pathgetpointcount($hpath)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPointCount", "handle", $hpath, "int*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_pathgetpoints($hpath)
	Local $ii, $icount, $tpoints, $apoints[1][1], $aresult
	$icount = _gdiplus_pathgetpointcount($hpath)
	If @error Then Return SetError(@error + 10, @extended, -1)
	$tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	$aresult = DllCall($__g_hgdipdll, "int", "GdipGetPathPoints", "handle", $hpath, "struct*", $tpoints, "int", $icount)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Local $apoints[$icount + 1][2]
	$apoints[0][0] = $icount
	For $ii = 1 To $icount
		$apoints[$ii][0] = DllStructGetData($tpoints, 1, (($ii - 1) * 2) + 1)
		$apoints[$ii][1] = DllStructGetData($tpoints, 1, (($ii - 1) * 2) + 2)
	Next
	Return $apoints
EndFunc

Func _gdiplus_pathgetworldbounds($hpath, $hmatrix = 0, $hpen = 0)
	Local $trectf = DllStructCreate($taggdiprectf)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPathWorldBounds", "handle", $hpath, "struct*", $trectf, "handle", $hmatrix, "handle", $hpen)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Local $arectf[4]
	For $ii = 1 To 4
		$arectf[$ii - 1] = DllStructGetData($trectf, $ii)
	Next
	Return $arectf
EndFunc

Func _gdiplus_pathisoutlinevisiblepoint($hpath, $nx, $ny, $hpen = 0, $hgraphics = 0)
	__gdiplus_pendefcreate($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipIsOutlineVisiblePathPoint", "handle", $hpath, "float", $nx, "float", $ny, "handle", $hpen, "handle", $hgraphics, "int*", 0)
	__gdiplus_pendefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return $aresult[6] <> 0
EndFunc

Func _gdiplus_pathisvisiblepoint($hpath, $nx, $ny, $hgraphics = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipIsVisiblePathPoint", "handle", $hpath, "float", $nx, "float", $ny, "handle", $hgraphics, "int*", 0)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return $aresult[5] <> 0
EndFunc

Func _gdiplus_pathitercreate($hpath)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreatePathIter", "handle*", 0, "handle", $hpath)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[1]
EndFunc

Func _gdiplus_pathiterdispose($hpathiter)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDeletePathIter", "handle", $hpathiter)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathitergetsubpathcount($hpathiter)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipPathIterGetSubpathCount", "handle", $hpathiter, "int*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_pathiternextmarkerpath($hpathiter, $hpath)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipPathIterNextMarkerPath", "handle", $hpathiter, "int*", 0, "handle", $hpath)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_pathiternextsubpathpath($hpathiter, $hpath)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipPathIterNextSubpathPath", "handle", $hpathiter, "int*", 0, "handle", $hpath, "bool*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Local $areturn[2]
	$areturn[0] = $aresult[2]
	$areturn[1] = $aresult[4]
	Return $areturn
EndFunc

Func _gdiplus_pathiterrewind($hpathiter)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipPathIterRewind", "handle", $hpathiter)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathreset($hpath)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipResetPath", "handle", $hpath)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathreverse($hpath)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipReversePath", "handle", $hpath)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathsetfillmode($hpath, $ifillmode)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPathFillMode", "handle", $hpath, "int", $ifillmode)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathsetmarker($hpath)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPathMarker", "handle", $hpath)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathstartfigure($hpath)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipStartPathFigure", "handle", $hpath)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathtransform($hpath, $hmatrix)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipTransformPath", "handle", $hpath, "handle", $hmatrix)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathwarp($hpath, $hmatrix, $apoints, $nx, $ny, $nwidth, $nheight, $iwarpmode = 0, $fflatness = 0.25)
	Local $icount = $apoints[0][0]
	If $icount <> 3 AND $icount <> 4 Then Return SetError(11, 0, False)
	Local $tpoints = DllStructCreate("float[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tpoints, 1, $apoints[$ii][0], ($ii - 1) * 2 + 1)
		DllStructSetData($tpoints, 1, $apoints[$ii][1], ($ii - 1) * 2 + 2)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipWarpPath", "handle", $hpath, "handle", $hmatrix, "struct*", $tpoints, "int", $icount, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight, "int", $iwarpmode, "float", $fflatness)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathwiden($hpath, $hpen, $hmatrix = 0, $fflatness = 0.25)
	__gdiplus_pendefcreate($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipWidenPath", "handle", $hpath, "handle", $hpen, "handle", $hmatrix, "float", $fflatness)
	__gdiplus_pendefdispose()
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pathwindingmodeoutline($hpath, $hmatrix = 0, $fflatness = 0.25)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipWindingModeOutline", "handle", $hpath, "handle", $hmatrix, "float", $fflatness)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pencreate($iargb = -16777216, $nwidth = 1, $iunit = 2)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreatePen1", "dword", $iargb, "float", $nwidth, "int", $iunit, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[4]
EndFunc

Func _gdiplus_pencreate2($hbrush, $nwidth = 1, $iunit = 2)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreatePen2", "handle", $hbrush, "float", $nwidth, "int", $iunit, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[4]
EndFunc

Func _gdiplus_pendispose($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDeletePen", "handle", $hpen)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pengetalignment($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPenMode", "handle", $hpen, "int*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_pengetcolor($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPenColor", "handle", $hpen, "dword*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_pengetcustomendcap($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPenCustomEndCap", "handle", $hpen, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_pengetdashcap($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPenDashCap197819", "handle", $hpen, "int*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_pengetdashstyle($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPenDashStyle", "handle", $hpen, "int*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_pengetendcap($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPenEndCap", "handle", $hpen, "int*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_pengetmiterlimit($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPenMiterLimit", "handle", $hpen, "float*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_pengetwidth($hpen)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetPenWidth", "handle", $hpen, "float*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_pensetalignment($hpen, $ialignment = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPenMode", "handle", $hpen, "int", $ialignment)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pensetcolor($hpen, $iargb)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPenColor", "handle", $hpen, "dword", $iargb)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pensetcustomendcap($hpen, $hendcap)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPenCustomEndCap", "handle", $hpen, "handle", $hendcap)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pensetdashcap($hpen, $idash = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPenDashCap197819", "handle", $hpen, "int", $idash)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pensetdashstyle($hpen, $istyle = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPenDashStyle", "handle", $hpen, "int", $istyle)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pensetendcap($hpen, $iendcap)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPenEndCap", "handle", $hpen, "int", $iendcap)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pensetlinecap($hpen, $istartcap, $iendcap, $idashcap)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPenLineCap197819", "handle", $hpen, "int", $istartcap, "int", $iendcap, "int", $idashcap)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pensetlinejoin($hpen, $ilinejoin)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPenLineJoin", "handle", $hpen, "int", $ilinejoin)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pensetmiterlimit($hpen, $fmiterlimit)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPenMiterLimit", "handle", $hpen, "float", $fmiterlimit)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pensetstartcap($hpen, $ilinecap)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPenStartCap", "handle", $hpen, "int", $ilinecap)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_pensetwidth($hpen, $fwidth)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetPenWidth", "handle", $hpen, "float", $fwidth)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_rectfcreate($nx = 0, $ny = 0, $nwidth = 0, $nheight = 0)
	Local $trectf = DllStructCreate($taggdiprectf)
	DllStructSetData($trectf, "X", $nx)
	DllStructSetData($trectf, "Y", $ny)
	DllStructSetData($trectf, "Width", $nwidth)
	DllStructSetData($trectf, "Height", $nheight)
	Return $trectf
EndFunc

Func _gdiplus_regionclone($hregion)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCloneRegion", "handle", $hregion, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_regioncombinepath($hregion, $hpath, $icombinemode = 2)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCombineRegionPath", "handle", $hregion, "handle", $hpath, "int", $icombinemode)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_regioncombinerect($hregion, $nx, $ny, $nwidth, $nheight, $icombinemode = 2)
	Local $trectf = _gdiplus_rectfcreate($nx, $ny, $nwidth, $nheight)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCombineRegionRect", "handle", $hregion, "struct*", $trectf, "int", $icombinemode)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_regioncombineregion($hregiondst, $hregionsrc, $icombinemode = 2)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCombineRegionRegion", "handle", $hregiondst, "handle", $hregionsrc, "int", $icombinemode)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_regioncreate()
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateRegion", "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[1]
EndFunc

Func _gdiplus_regioncreatefrompath($hpath)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateRegionPath", "handle", $hpath, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_regioncreatefromrect($nx, $ny, $nwidth, $nheight)
	Local $trectf = _gdiplus_rectfcreate($nx, $ny, $nwidth, $nheight)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateRegionRect", "struct*", $trectf, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_regiondispose($hregion)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDeleteRegion", "handle", $hregion)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_regiongetbounds($hregion, $hgraphics)
	Local $trectf = DllStructCreate($taggdiprectf)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetRegionBounds", "handle", $hregion, "handle", $hgraphics, "struct*", $trectf)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Local $abounds[4]
	For $ii = 1 To 4
		$abounds[$ii - 1] = DllStructGetData($trectf, $ii)
	Next
	Return $abounds
EndFunc

Func _gdiplus_regiongethrgn($hregion, $hgraphics = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetRegionHRgn", "handle", $hregion, "handle", $hgraphics, "handle*", 0)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return $aresult[3]
EndFunc

Func _gdiplus_regiontransform($hregion, $hmatrix)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipTransformRegion", "handle", $hregion, "handle", $hmatrix)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_regiontranslate($hregion, $ndx, $ndy)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipTranslateRegion", "handle", $hregion, "float", $ndx, "float", $ndy)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_shutdown()
	If $__g_hgdipdll = 0 Then Return SetError(-1, -1, False)
	$__g_igdipref -= 1
	If $__g_igdipref = 0 Then
		DllCall($__g_hgdipdll, "none", "GdiplusShutdown", "ulong_ptr", $__g_igdiptoken)
		DllClose($__g_hgdipdll)
		$__g_hgdipdll = 0
	EndIf
	Return True
EndFunc

Func _gdiplus_startup($sgdipdll = Default, $bretdllhandle = False)
	$__g_igdipref += 1
	If $__g_igdipref > 1 Then Return True
	If $sgdipdll = Default Then $sgdipdll = "gdiplus.dll"
	$__g_hgdipdll = DllOpen($sgdipdll)
	If $__g_hgdipdll = -1 Then
		$__g_igdipref = 0
		Return SetError(1, 2, False)
	EndIf
	Local $sver = FileGetVersion($sgdipdll)
	$sver = StringSplit($sver, ".")
	If $sver[1] > 5 Then $__g_bgdip_v1_0 = False
	Local $tinput = DllStructCreate($taggdipstartupinput)
	Local $ttoken = DllStructCreate("ulong_ptr Data")
	DllStructSetData($tinput, "Version", 1)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdiplusStartup", "struct*", $ttoken, "struct*", $tinput, "ptr", 0)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	$__g_igdiptoken = DllStructGetData($ttoken, "Data")
	If $bretdllhandle Then Return $__g_hgdipdll
	Return SetExtended($sver[1], True)
EndFunc

Func _gdiplus_stringformatcreate($iformat = 0, $ilangid = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateStringFormat", "int", $iformat, "word", $ilangid, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[3]
EndFunc

Func _gdiplus_stringformatdispose($hformat)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDeleteStringFormat", "handle", $hformat)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_stringformatgetmeasurablecharacterrangecount($hstringformat)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetStringFormatMeasurableCharacterRangeCount", "handle", $hstringformat, "int*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_stringformatsetalign($hstringformat, $iflag)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetStringFormatAlign", "handle", $hstringformat, "int", $iflag)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_stringformatsetlinealign($hstringformat, $istringalign)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetStringFormatLineAlign", "handle", $hstringformat, "int", $istringalign)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_stringformatsetmeasurablecharacterranges($hstringformat, $aranges)
	Local $icount = $aranges[0][0]
	Local $tcharacterranges = DllStructCreate("int[" & $icount * 2 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tcharacterranges, 1, $aranges[$ii][0], (($ii - 1) * 2) + 1)
		DllStructSetData($tcharacterranges, 1, $aranges[$ii][1], (($ii - 1) * 2) + 2)
	Next
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetStringFormatMeasurableCharacterRanges", "handle", $hstringformat, "int", $icount, "struct*", $tcharacterranges)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_texturecreate($himage, $iwrapmode = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateTexture", "handle", $himage, "int", $iwrapmode, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[3]
EndFunc

Func _gdiplus_texturecreate2($himage, $nx, $ny, $nwidth, $nheight, $iwrapmode = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateTexture2", "handle", $himage, "int", $iwrapmode, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight, "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[7]
EndFunc

Func _gdiplus_texturecreateia($himage, $nx, $ny, $nwidth, $nheight, $pimageattributes = 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateTextureIA", "handle", $himage, "handle", $pimageattributes, "float", $nx, "float", $ny, "float", $nwidth, "float", $nheight, "ptr*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[7]
EndFunc

Func __gdiplus_brushdefcreate(ByRef $hbrush)
	If $hbrush = 0 Then
		$__g_hgdipbrush = _gdiplus_brushcreatesolid()
		$hbrush = $__g_hgdipbrush
	EndIf
EndFunc

Func __gdiplus_brushdefdispose($icurerror = @error, $icurextended = @extended)
	If $__g_hgdipbrush <> 0 Then
		_gdiplus_brushdispose($__g_hgdipbrush)
		$__g_hgdipbrush = 0
	EndIf
	Return SetError($icurerror, $icurextended)
EndFunc

Func __gdiplus_extractfileext($sfilename, $bnodot = True)
	Local $iindex = __gdiplus_lastdelimiter(".\:", $sfilename)
	If ($iindex > 0) AND (StringMid($sfilename, $iindex, 1) = ".") Then
		If $bnodot Then
			Return StringMid($sfilename, $iindex + 1)
		Else
			Return StringMid($sfilename, $iindex)
		EndIf
	Else
		Return ""
	EndIf
EndFunc

Func __gdiplus_lastdelimiter($sdelimiters, $sstring)
	Local $sdelimiter, $in
	For $ii = 1 To StringLen($sdelimiters)
		$sdelimiter = StringMid($sdelimiters, $ii, 1)
		$in = StringInStr($sstring, $sdelimiter, 0, -1)
		If $in > 0 Then Return $in
	Next
EndFunc

Func __gdiplus_pendefcreate(ByRef $hpen)
	If $hpen = 0 Then
		$__g_hgdippen = _gdiplus_pencreate()
		$hpen = $__g_hgdippen
	EndIf
EndFunc

Func __gdiplus_pendefdispose($icurerror = @error, $icurextended = @extended)
	If $__g_hgdippen <> 0 Then
		_gdiplus_pendispose($__g_hgdippen)
		$__g_hgdippen = 0
	EndIf
	Return SetError($icurerror, $icurextended)
EndFunc

Func _gdiplus_bitmapapplyeffect($hbitmap, $heffect, $trect = NULL )
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, False)
	If NOT IsPtr($heffect) Then Return SetError(10, 0, False)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipBitmapApplyEffect", "handle", $hbitmap, "handle", $heffect, "struct*", $trect, "int", 0, "ptr*", 0, "int*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_bitmapapplyeffectex($hbitmap, $heffect, $ix = 0, $iy = 0, $iw = 0, $ih = 0)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, False)
	Local $trect = 0
	If BitOR($ix, $iy, $iw, $ih) Then
		$trect = DllStructCreate("int Left; int Top; int Right; int Bottom;")
		DllStructSetData($trect, "Right", $iw + DllStructSetData($trect, "Left", $ix))
		DllStructSetData($trect, "Bottom", $ih + DllStructSetData($trect, "Top", $iy))
	EndIf
	Local $istatus = _gdiplus_bitmapapplyeffect($hbitmap, $heffect, $trect)
	If NOT $istatus Then Return SetError(@error, @extended, False)
	Return True
EndFunc

Func _gdiplus_bitmapconvertformat($hbitmap, $ipixelformat, $idithertype, $ipalettetype, $tpalette, $falphathresholdpercent = 0)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, False)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipBitmapConvertFormat", "handle", $hbitmap, "uint", $ipixelformat, "uint", $idithertype, "uint", $ipalettetype, "struct*", $tpalette, "float", $falphathresholdpercent)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_bitmapcreateapplyeffect($hbitmap, $heffect, $trect = NULL , $toutrect = NULL )
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipBitmapCreateApplyEffect", "handle*", $hbitmap, "int", 1, "handle", $heffect, "struct*", $trect, "struct*", $toutrect, "handle*", 0, "int", 0, "ptr*", 0, "int*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[6]
EndFunc

Func _gdiplus_bitmapcreateapplyeffectex($hbitmap, $heffect, $ix = 0, $iy = 0, $iw = 0, $ih = 0)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $trect = 0
	If BitOR($ix, $iy, $iw, $ih) Then
		$trect = DllStructCreate("int Left; int Top; int Right; int Bottom;")
		DllStructSetData($trect, "Right", $iw + DllStructSetData($trect, "Left", $ix))
		DllStructSetData($trect, "Bottom", $ih + DllStructSetData($trect, "Top", $iy))
	EndIf
	Local $hbitmap_fx = _gdiplus_bitmapcreateapplyeffect($hbitmap, $heffect, $trect, NULL )
	Return SetError(@error, @extended, $hbitmap_fx)
EndFunc

Func _gdiplus_bitmapgethistogram($hbitmap, $ihistogramformat, $ihistogramsize, $tchannel_0, $tchannel_1 = 0, $tchannel_2 = 0, $tchannel_3 = 0)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, False)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipBitmapGetHistogram", "handle", $hbitmap, "uint", $ihistogramformat, "uint", $ihistogramsize, "struct*", $tchannel_0, "struct*", $tchannel_1, "struct*", $tchannel_2, "struct*", $tchannel_3)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_bitmapgethistogramex($hbitmap)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $isize = _gdiplus_bitmapgethistogramsize($gdip_histogramformatargb)
	Local $thistogram = DllStructCreate("int Size; uint Red[" & $isize & "]; uint MaxRed; uint Green[" & $isize & "]; uint MaxGreen; uint Blue[" & $isize & "]; uint MaxBlue; uint Alpha[" & $isize & "]; uint MaxAlpha; uint Grey[" & $isize & "]; uint MaxGrey;")
	DllStructSetData($thistogram, "Size", $isize)
	Local $istatus = _gdiplus_bitmapgethistogram($hbitmap, $gdip_histogramformatargb, $isize, DllStructGetPtr($thistogram, "Alpha"), DllStructGetPtr($thistogram, "Red"), DllStructGetPtr($thistogram, "Green"), DllStructGetPtr($thistogram, "Blue"))
	If NOT $istatus Then Return SetError(@error, @extended, 0)
	$istatus = _gdiplus_bitmapgethistogram($hbitmap, $gdip_histogramformatgray, $isize, DllStructGetPtr($thistogram, "Grey"))
	If NOT $istatus Then Return SetError(@error + 10, @extended, 0)
	Local $imaxred = 0, $imaxgreen = 0, $imaxblue = 0, $imaxalpha = 0, $imaxgrey = 0
	For $i = 1 To $isize
		If DllStructGetData($thistogram, "Red", $i) > $imaxred Then $imaxred = DllStructGetData($thistogram, "Red", $i)
		If DllStructGetData($thistogram, "Green", $i) > $imaxgreen Then $imaxgreen = DllStructGetData($thistogram, "Green", $i)
		If DllStructGetData($thistogram, "Blue", $i) > $imaxblue Then $imaxblue = DllStructGetData($thistogram, "Blue", $i)
		If DllStructGetData($thistogram, "Alpha", $i) > $imaxalpha Then $imaxalpha = DllStructGetData($thistogram, "Alpha", $i)
		If DllStructGetData($thistogram, "Grey", $i) > $imaxgrey Then $imaxgrey = DllStructGetData($thistogram, "Grey", $i)
	Next
	DllStructSetData($thistogram, "MaxRed", $imaxred)
	DllStructSetData($thistogram, "MaxGreen", $imaxgreen)
	DllStructSetData($thistogram, "MaxBlue", $imaxblue)
	DllStructSetData($thistogram, "MaxAlpha", $imaxalpha)
	DllStructSetData($thistogram, "MaxGrey", $imaxgrey)
	Return $thistogram
EndFunc

Func _gdiplus_bitmapgethistogramsize($iformat)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipBitmapGetHistogramSize", "uint", $iformat, "uint*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[2]
EndFunc

Func _gdiplus_drawimagefx($hgraphics, $himage, $heffect, $trectf = 0, $hmatrix = 0, $himgattributes = 0, $iunit = 2)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, False)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDrawImageFX", "handle", $hgraphics, "handle", $himage, "struct*", $trectf, "handle", $hmatrix, "handle", $heffect, "handle", $himgattributes, "uint", $iunit)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_drawimagefxex($hgraphics, $himage, $heffect, $nx = 0, $ny = 0, $nw = 0, $nh = 0, $hmatrix = 0, $himgattributes = 0, $iunit = 2)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, False)
	Local $trectf = 0
	If BitOR($nx, $ny, $nw, $nh) Then $trectf = _gdiplus_rectfcreate($nx, $ny, $nw, $nh)
	Local $istatus = _gdiplus_drawimagefx($hgraphics, $himage, $heffect, $trectf, $hmatrix, $himgattributes, $iunit)
	Return SetError(@error, @extended, $istatus)
EndFunc

Func _gdiplus_effectcreate($seffectguid)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $tguid = _winapi_guidfromstring($seffectguid)
	Local $telem = DllStructCreate("uint64[2];", DllStructGetPtr($tguid))
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipCreateEffect", "uint64", DllStructGetData($telem, 1, 1), "uint64", DllStructGetData($telem, 1, 2), "handle*", 0)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $aresult[3]
EndFunc

Func _gdiplus_effectcreateblur($fradius = 10, $bexpandedge = False)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $teffectparameters = DllStructCreate($taggdip_effectparams_blur)
	DllStructSetData($teffectparameters, "Radius", $fradius)
	DllStructSetData($teffectparameters, "ExpandEdge", $bexpandedge)
	Local $heffect = _gdiplus_effectcreate($gdip_blureffectguid)
	If @error Then Return SetError(@error, @extended, 0)
	_gdiplus_effectsetparameters($heffect, $teffectparameters)
	If @error Then Return SetError(@error + 10, @extended, 0)
	Return $heffect
EndFunc

Func _gdiplus_effectcreatebrightnesscontrast($ibrightnesslevel = 0, $icontrastlevel = 0)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $teffectparameters = DllStructCreate($taggdip_effectparams_brightnesscontrast)
	DllStructSetData($teffectparameters, "BrightnessLevel", $ibrightnesslevel)
	DllStructSetData($teffectparameters, "ContrastLevel", $icontrastlevel)
	Local $heffect = _gdiplus_effectcreate($gdip_brightnesscontrasteffectguid)
	If @error Then Return SetError(@error, @extended, 0)
	_gdiplus_effectsetparameters($heffect, $teffectparameters)
	If @error Then Return SetError(@error + 10, @extended, 0)
	Return $heffect
EndFunc

Func _gdiplus_effectcreatecolorbalance($icyanred = 0, $imagentagreen = 0, $iyellowblue = 0)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $teffectparameters = DllStructCreate($taggdip_effectparams_colorbalance)
	DllStructSetData($teffectparameters, "CyanRed", $icyanred)
	DllStructSetData($teffectparameters, "MagentaGreen", $imagentagreen)
	DllStructSetData($teffectparameters, "YellowBlue", $iyellowblue)
	Local $heffect = _gdiplus_effectcreate($gdip_colorbalanceeffectguid)
	If @error Then Return SetError(@error, @extended, 0)
	_gdiplus_effectsetparameters($heffect, $teffectparameters)
	If @error Then Return SetError(@error + 10, @extended, 0)
	Return $heffect
EndFunc

Func _gdiplus_effectcreatecolorcurve($iadjustment, $ichannel, $iadjustvalue)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $teffectparameters = DllStructCreate($taggdip_effectparams_colorcurve)
	DllStructSetData($teffectparameters, "Adjustment", $iadjustment)
	DllStructSetData($teffectparameters, "Channel", $ichannel)
	DllStructSetData($teffectparameters, "AdjustValue", $iadjustvalue)
	Local $heffect = _gdiplus_effectcreate($gdip_colorcurveeffectguid)
	If @error Then Return SetError(@error, @extended, 0)
	_gdiplus_effectsetparameters($heffect, $teffectparameters)
	If @error Then Return SetError(@error + 10, @extended, 0)
	Return $heffect
EndFunc

Func _gdiplus_effectcreatecolorlut($acolorlut)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $teffectparameters = DllStructCreate($taggdip_effectparams_colorlut)
	For $ii = 0 To 255
		DllStructSetData($teffectparameters, "LutA", $acolorlut[$ii][0], $ii + 1)
		DllStructSetData($teffectparameters, "LutR", $acolorlut[$ii][1], $ii + 1)
		DllStructSetData($teffectparameters, "LutG", $acolorlut[$ii][2], $ii + 1)
		DllStructSetData($teffectparameters, "LutB", $acolorlut[$ii][3], $ii + 1)
	Next
	Local $heffect = _gdiplus_effectcreate($gdip_colorluteffectguid)
	If @error Then Return SetError(@error, @extended, 0)
	_gdiplus_effectsetparameters($heffect, $teffectparameters)
	If @error Then Return SetError(@error + 10, @extended, 0)
	Return $heffect
EndFunc

Func _gdiplus_effectcreatecolormatrix($tcolormatrix)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $heffect = _gdiplus_effectcreate($gdip_colormatrixeffectguid)
	If @error Then Return SetError(@error, @extended, 0)
	_gdiplus_effectsetparameters($heffect, $tcolormatrix)
	If @error Then Return SetError(@error + 10, @extended, 0)
	Return $heffect
EndFunc

Func _gdiplus_effectcreatehuesaturationlightness($ihuelevel = 0, $isaturationlevel = 0, $ilightnesslevel = 0)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $teffectparameters = DllStructCreate($taggdip_effectparams_huesaturationlightness)
	DllStructSetData($teffectparameters, "HueLevel", $ihuelevel)
	DllStructSetData($teffectparameters, "SaturationLevel", $isaturationlevel)
	DllStructSetData($teffectparameters, "LightnessLevel", $ilightnesslevel)
	Local $heffect = _gdiplus_effectcreate($gdip_huesaturationlightnesseffectguid)
	If @error Then Return SetError(@error, @extended, 0)
	_gdiplus_effectsetparameters($heffect, $teffectparameters)
	If @error Then Return SetError(@error + 10, @extended, 0)
	Return $heffect
EndFunc

Func _gdiplus_effectcreatelevels($ihighlight = 100, $imidtone = 0, $ishadow = 0)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $teffectparameters = DllStructCreate($taggdip_effectparams_levels)
	DllStructSetData($teffectparameters, "Highlight", $ihighlight)
	DllStructSetData($teffectparameters, "Midtone", $imidtone)
	DllStructSetData($teffectparameters, "Shadow", $ishadow)
	Local $heffect = _gdiplus_effectcreate($gdip_levelseffectguid)
	If @error Then Return SetError(@error, @extended, 0)
	_gdiplus_effectsetparameters($heffect, $teffectparameters)
	If @error Then Return SetError(@error + 10, @extended, 0)
	Return $heffect
EndFunc

Func _gdiplus_effectcreateredeyecorrection($aareas)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $icount = $aareas[0][0]
	Local $tareas = DllStructCreate("long[" & $icount * 4 & "]")
	For $ii = 1 To $icount
		DllStructSetData($tareas, 1, DllStructSetData($tareas, 1, $aareas[$ii][0], (($ii - 1) * 4) + 1) + $aareas[$ii][2], (($ii - 1) * 4) + 3)
		DllStructSetData($tareas, 1, DllStructSetData($tareas, 1, $aareas[$ii][1], (($ii - 1) * 4) + 2) + $aareas[$ii][3], (($ii - 1) * 4) + 4)
	Next
	Local $teffectparameters = DllStructCreate($taggdip_effectparams_redeyecorrection)
	DllStructSetData($teffectparameters, "NumberOfAreas", $icount)
	DllStructSetData($teffectparameters, "Areas", DllStructGetPtr($tareas))
	Local $heffect = _gdiplus_effectcreate($gdip_redeyecorrectioneffectguid)
	If @error Then Return SetError(@error, @extended, 0)
	_gdiplus_effectsetparameters($heffect, $teffectparameters, (DllStructGetSize($tareas) + DllStructGetSize($teffectparameters)) / DllStructGetSize($teffectparameters))
	If @error Then Return SetError(@error + 10, @extended, 0)
	Return $heffect
EndFunc

Func _gdiplus_effectcreatesharpen($fradius = 10, $famount = 50)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $teffectparameters = DllStructCreate($taggdip_effectparams_sharpen)
	DllStructSetData($teffectparameters, "Radius", $fradius)
	DllStructSetData($teffectparameters, "Amount", $famount)
	Local $heffect = _gdiplus_effectcreate($gdip_sharpeneffectguid)
	If @error Then Return SetError(@error, @extended, 0)
	_gdiplus_effectsetparameters($heffect, $teffectparameters)
	If @error Then Return SetError(@error + 10, @extended, 0)
	Return $heffect
EndFunc

Func _gdiplus_effectcreatetint($ihue = 0, $iamount = 0)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	Local $teffectparameters = DllStructCreate($taggdip_effectparams_tint)
	DllStructSetData($teffectparameters, "Hue", $ihue)
	DllStructSetData($teffectparameters, "Amount", $iamount)
	Local $heffect = _gdiplus_effectcreate($gdip_tinteffectguid)
	If @error Then Return SetError(@error, @extended, 0)
	_gdiplus_effectsetparameters($heffect, $teffectparameters)
	If @error Then Return SetError(@error + 10, @extended, 0)
	Return $heffect
EndFunc

Func _gdiplus_effectdispose($heffect)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, False)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipDeleteEffect", "handle", $heffect)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_effectgetparameters($heffect, $teffectparameters)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, False)
	If DllStructGetSize($teffectparameters) < __gdiplus_effectgetparametersize($heffect) Then Return SetError(2, 5, False)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetEffectParameters", "handle", $heffect, "uint*", DllStructGetSize($teffectparameters), "struct*", $teffectparameters)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func __gdiplus_effectgetparametersize($heffect)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, -1)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipGetEffectParameterSize", "handle", $heffect, "uint*", 0)
	If @error Then Return SetError(@error, @extended, -1)
	If $aresult[0] Then Return SetError(10, $aresult[0], -1)
	Return $aresult[2]
EndFunc

Func _gdiplus_effectsetparameters($heffect, $teffectparameters, $isizeadjust = 1)
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, False)
	Local $isize = __gdiplus_effectgetparametersize($heffect)
	If @error Then Return SetError(@error, @extended, False)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipSetEffectParameters", "handle", $heffect, "struct*", $teffectparameters, "uint", $isize * $isizeadjust)
	If @error Then Return SetError(@error, @extended, False)
	If $aresult[0] Then Return SetError(10, $aresult[0], False)
	Return True
EndFunc

Func _gdiplus_paletteinitialize($ientries, $ipalettetype = $gdip_palettetypeoptimal, $ioptimalcolors = 0, $busetransparentcolor = True, $hbitmap = NULL )
	If $__g_bgdip_v1_0 Then Return SetError(-1, 0, 0)
	If $ioptimalcolors > 0 Then $ipalettetype = $gdip_palettetypeoptimal
	Local $tpalette = DllStructCreate("uint Flags; uint Count; uint ARGB[" & $ientries & "];")
	DllStructSetData($tpalette, "Flags", $ipalettetype)
	DllStructSetData($tpalette, "Count", $ientries)
	Local $aresult = DllCall($__g_hgdipdll, "int", "GdipInitializePalette", "struct*", $tpalette, "uint", $ipalettetype, "uint", $ioptimalcolors, "bool", $busetransparentcolor, "handle", $hbitmap)
	If @error Then Return SetError(@error, @extended, 0)
	If $aresult[0] Then Return SetError(10, $aresult[0], 0)
	Return $tpalette
EndFunc

Global $__g_ibmpformat = $gdip_pxf24rgb
Global $__g_ijpgquality = 100
Global $__g_itifcolordepth = 24
Global $__g_itifcompression = $gdip_evtcompressionlzw
Global Const $__screencaptureconstant_sm_cxscreen = 0
Global Const $__screencaptureconstant_sm_cyscreen = 1
Global Const $__screencaptureconstant_srccopy = 13369376

Func _screencapture_capture($sfilename = "", $ileft = 0, $itop = 0, $iright = -1, $ibottom = -1, $bcursor = True)
	Local $bret = False
	If $iright = -1 Then $iright = _winapi_getsystemmetrics($__screencaptureconstant_sm_cxscreen) - 1
	If $ibottom = -1 Then $ibottom = _winapi_getsystemmetrics($__screencaptureconstant_sm_cyscreen) - 1
	If $iright < $ileft Then Return SetError(-1, 0, $bret)
	If $ibottom < $itop Then Return SetError(-2, 0, $bret)
	Local $iw = ($iright - $ileft) + 1
	Local $ih = ($ibottom - $itop) + 1
	Local $hwnd = _winapi_getdesktopwindow()
	Local $hddc = _winapi_getdc($hwnd)
	Local $hcdc = _winapi_createcompatibledc($hddc)
	Local $hbmp = _winapi_createcompatiblebitmap($hddc, $iw, $ih)
	_winapi_selectobject($hcdc, $hbmp)
	_winapi_bitblt($hcdc, 0, 0, $iw, $ih, $hddc, $ileft, $itop, $__screencaptureconstant_srccopy)
	If $bcursor Then
		Local $acursor = _winapi_getcursorinfo()
		If NOT @error AND $acursor[1] Then
			$bcursor = True
			Local $hicon = _winapi_copyicon($acursor[2])
			Local $aicon = _winapi_geticoninfo($hicon)
			If NOT @error Then
				_winapi_deleteobject($aicon[4])
				If $aicon[5] <> 0 Then _winapi_deleteobject($aicon[5])
				_winapi_drawicon($hcdc, $acursor[3] - $aicon[2] - $ileft, $acursor[4] - $aicon[3] - $itop, $hicon)
			EndIf
			_winapi_destroyicon($hicon)
		EndIf
	EndIf
	_winapi_releasedc($hwnd, $hddc)
	_winapi_deletedc($hcdc)
	If $sfilename = "" Then Return $hbmp
	$bret = _screencapture_saveimage($sfilename, $hbmp, True)
	Return SetError(@error, @extended, $bret)
EndFunc

Func _screencapture_capturewnd($sfilename, $hwnd, $ileft = 0, $itop = 0, $iright = -1, $ibottom = -1, $bcursor = True)
	If NOT IsHWnd($hwnd) Then $hwnd = WinGetHandle($hwnd)
	Local $trect = DllStructCreate($tagrect)
	Local Const $dwmwa_extended_frame_bounds = 9
	Local $bret = DllCall("dwmapi.dll", "long", "DwmGetWindowAttribute", "hwnd", $hwnd, "dword", $dwmwa_extended_frame_bounds, "struct*", $trect, "dword", DllStructGetSize($trect))
	If (@error OR $bret[0] OR (Abs(DllStructGetData($trect, "Left")) + Abs(DllStructGetData($trect, "Top")) + Abs(DllStructGetData($trect, "Right")) + Abs(DllStructGetData($trect, "Bottom"))) = 0) Then
		$trect = _winapi_getwindowrect($hwnd)
		If @error Then Return SetError(@error + 10, @extended, False)
	EndIf
	$ileft += DllStructGetData($trect, "Left")
	$itop += DllStructGetData($trect, "Top")
	If $iright = -1 Then $iright = DllStructGetData($trect, "Right") - DllStructGetData($trect, "Left") - 1
	If $ibottom = -1 Then $ibottom = DllStructGetData($trect, "Bottom") - DllStructGetData($trect, "Top") - 1
	$iright += DllStructGetData($trect, "Left")
	$ibottom += DllStructGetData($trect, "Top")
	If $ileft > DllStructGetData($trect, "Right") Then $ileft = DllStructGetData($trect, "Left")
	If $itop > DllStructGetData($trect, "Bottom") Then $itop = DllStructGetData($trect, "Top")
	If $iright > DllStructGetData($trect, "Right") Then $iright = DllStructGetData($trect, "Right") - 1
	If $ibottom > DllStructGetData($trect, "Bottom") Then $ibottom = DllStructGetData($trect, "Bottom") - 1
	$bret = _screencapture_capture($sfilename, $ileft, $itop, $iright, $ibottom, $bcursor)
	Return SetError(@error, @extended, $bret)
EndFunc

Func _screencapture_saveimage($sfilename, $hbitmap, $bfreebmp = True)
	_gdiplus_startup()
	If @error Then Return SetError(-1, -1, False)
	Local $sext = StringUpper(__gdiplus_extractfileext($sfilename))
	Local $sclsid = _gdiplus_encodersgetclsid($sext)
	If $sclsid = "" Then Return SetError(-2, -2, False)
	Local $himage = _gdiplus_bitmapcreatefromhbitmap($hbitmap)
	If @error Then Return SetError(-3, -3, False)
	Local $tdata, $tparams
	Switch $sext
		Case "BMP"
			Local $ix = _gdiplus_imagegetwidth($himage)
			Local $iy = _gdiplus_imagegetheight($himage)
			Local $hclone = _gdiplus_bitmapclonearea($himage, 0, 0, $ix, $iy, $__g_ibmpformat)
			_gdiplus_imagedispose($himage)
			$himage = $hclone
		Case "JPG", "JPEG"
			$tparams = _gdiplus_paraminit(1)
			$tdata = DllStructCreate("int Quality")
			DllStructSetData($tdata, "Quality", $__g_ijpgquality)
			_gdiplus_paramadd($tparams, $gdip_epgquality, 1, $gdip_eptlong, DllStructGetPtr($tdata))
		Case "TIF", "TIFF"
			$tparams = _gdiplus_paraminit(2)
			$tdata = DllStructCreate("int ColorDepth;int Compression")
			DllStructSetData($tdata, "ColorDepth", $__g_itifcolordepth)
			DllStructSetData($tdata, "Compression", $__g_itifcompression)
			_gdiplus_paramadd($tparams, $gdip_epgcolordepth, 1, $gdip_eptlong, DllStructGetPtr($tdata, "ColorDepth"))
			_gdiplus_paramadd($tparams, $gdip_epgcompression, 1, $gdip_eptlong, DllStructGetPtr($tdata, "Compression"))
	EndSwitch
	Local $pparams = 0
	If IsDllStruct($tparams) Then $pparams = $tparams
	Local $bret = _gdiplus_imagesavetofileex($himage, $sfilename, $sclsid, $pparams)
	_gdiplus_imagedispose($himage)
	If $bfreebmp Then _winapi_deleteobject($hbitmap)
	_gdiplus_shutdown()
	Return SetError($bret = False, 0, $bret)
EndFunc

Func _screencapture_setbmpformat($iformat)
	Switch $iformat
		Case 0
			$__g_ibmpformat = $gdip_pxf16rgb555
		Case 1
			$__g_ibmpformat = $gdip_pxf16rgb565
		Case 2
			$__g_ibmpformat = $gdip_pxf24rgb
		Case 3
			$__g_ibmpformat = $gdip_pxf32rgb
		Case 4
			$__g_ibmpformat = $gdip_pxf32argb
		Case Else
			$__g_ibmpformat = $gdip_pxf24rgb
	EndSwitch
EndFunc

Func _screencapture_setjpgquality($iquality)
	If $iquality < 0 Then $iquality = 0
	If $iquality > 100 Then $iquality = 100
	$__g_ijpgquality = $iquality
EndFunc

Func _screencapture_settifcolordepth($idepth)
	Switch $idepth
		Case 24
			$__g_itifcolordepth = 24
		Case 32
			$__g_itifcolordepth = 32
		Case Else
			$__g_itifcolordepth = 0
	EndSwitch
EndFunc

Func _screencapture_settifcompression($icompress)
	Switch $icompress
		Case 1
			$__g_itifcompression = $gdip_evtcompressionnone
		Case 2
			$__g_itifcompression = $gdip_evtcompressionlzw
		Case Else
			$__g_itifcompression = 0
	EndSwitch
EndFunc

Global Const $wc_animate = "SysAnimate32"
Global Const $wc_button = "Button"
Global Const $wc_combobox = "ComboBox"
Global Const $wc_comboboxex = "ComboBoxEx32"
Global Const $wc_datetimepick = "SysDateTimePick32"
Global Const $wc_edit = "Edit"
Global Const $wc_header = "SysHeader32"
Global Const $wc_hotkey = "msctls_hotkey32"
Global Const $wc_ipaddress = "SysIPAddress32"
Global Const $wc_link = "SysLink"
Global Const $wc_listbox = "ListBox"
Global Const $wc_listview = "SysListView32"
Global Const $wc_monthcal = "SysMonthCal32"
Global Const $wc_nativefontctl = "NativeFontCtl"
Global Const $wc_pagescroller = "SysPager"
Global Const $wc_progress = "msctls_progress32"
Global Const $wc_rebar = "ReBarWindow32"
Global Const $wc_scrollbar = "ScrollBar"
Global Const $wc_static = "Static"
Global Const $wc_statusbar = "msctls_statusbar32"
Global Const $wc_tabcontrol = "SysTabControl32"
Global Const $wc_toolbar = "ToolbarWindow32"
Global Const $wc_tooltips = "tooltips_class32"
Global Const $wc_trackbar = "msctls_trackbar32"
Global Const $wc_treeview = "SysTreeView32"
Global Const $wc_updown = "msctls_updown32"
Global Const $ws_overlapped = 0
Global Const $ws_tiled = $ws_overlapped
Global Const $ws_maximizebox = 65536
Global Const $ws_minimizebox = 131072
Global Const $ws_tabstop = 65536
Global Const $ws_group = 131072
Global Const $ws_sizebox = 262144
Global Const $ws_thickframe = $ws_sizebox
Global Const $ws_sysmenu = 524288
Global Const $ws_hscroll = 1048576
Global Const $ws_vscroll = 2097152
Global Const $ws_dlgframe = 4194304
Global Const $ws_border = 8388608
Global Const $ws_caption = 12582912
Global Const $ws_overlappedwindow = BitOR($ws_caption, $ws_maximizebox, $ws_minimizebox, $ws_overlapped, $ws_sysmenu, $ws_thickframe)
Global Const $ws_tiledwindow = $ws_overlappedwindow
Global Const $ws_maximize = 16777216
Global Const $ws_clipchildren = 33554432
Global Const $ws_clipsiblings = 67108864
Global Const $ws_disabled = 134217728
Global Const $ws_visible = 268435456
Global Const $ws_minimize = 536870912
Global Const $ws_iconic = $ws_minimize
Global Const $ws_child = 1073741824
Global Const $ws_childwindow = $ws_child
Global Const $ws_popup = -2147483648
Global Const $ws_popupwindow = -2138570752
Global Const $ds_3dlook = 4
Global Const $ds_absalign = 1
Global Const $ds_center = 2048
Global Const $ds_centermouse = 4096
Global Const $ds_contexthelp = 8192
Global Const $ds_control = 1024
Global Const $ds_fixedsys = 8
Global Const $ds_localedit = 32
Global Const $ds_modalframe = 128
Global Const $ds_nofailcreate = 16
Global Const $ds_noidlemsg = 256
Global Const $ds_setfont = 64
Global Const $ds_setforeground = 512
Global Const $ds_shellfont = BitOR($ds_fixedsys, $ds_setfont)
Global Const $ds_sysmodal = 2
Global Const $ws_ex_acceptfiles = 16
Global Const $ws_ex_appwindow = 262144
Global Const $ws_ex_composited = 33554432
Global Const $ws_ex_controlparent = 65536
Global Const $ws_ex_clientedge = 512
Global Const $ws_ex_contexthelp = 1024
Global Const $ws_ex_dlgmodalframe = 1
Global Const $ws_ex_layered = 524288
Global Const $ws_ex_layoutrtl = 4194304
Global Const $ws_ex_left = 0
Global Const $ws_ex_leftscrollbar = 16384
Global Const $ws_ex_ltrreading = 0
Global Const $ws_ex_mdichild = 64
Global Const $ws_ex_noactivate = 134217728
Global Const $ws_ex_noinheritlayout = 1048576
Global Const $ws_ex_noparentnotify = 4
Global Const $ws_ex_right = 4096
Global Const $ws_ex_rightscrollbar = 0
Global Const $ws_ex_rtlreading = 8192
Global Const $ws_ex_staticedge = 131072
Global Const $ws_ex_toolwindow = 128
Global Const $ws_ex_topmost = 8
Global Const $ws_ex_transparent = 32
Global Const $ws_ex_windowedge = 256
Global Const $ws_ex_overlappedwindow = BitOR($ws_ex_clientedge, $ws_ex_windowedge)
Global Const $ws_ex_palettewindow = BitOR($ws_ex_toolwindow, $ws_ex_topmost, $ws_ex_windowedge)
Global Const $wm_null = 0
Global Const $wm_create = 1
Global Const $wm_destroy = 2
Global Const $wm_move = 3
Global Const $wm_sizewait = 4
Global Const $wm_size = 5
Global Const $wm_activate = 6
Global Const $wm_setfocus = 7
Global Const $wm_killfocus = 8
Global Const $wm_setvisible = 9
Global Const $wm_enable = 10
Global Const $wm_setredraw = 11
Global Const $wm_settext = 12
Global Const $wm_gettext = 13
Global Const $wm_gettextlength = 14
Global Const $wm_paint = 15
Global Const $wm_close = 16
Global Const $wm_queryendsession = 17
Global Const $wm_quit = 18
Global Const $wm_erasebkgnd = 20
Global Const $wm_queryopen = 19
Global Const $wm_syscolorchange = 21
Global Const $wm_endsession = 22
Global Const $wm_systemerror = 23
Global Const $wm_showwindow = 24
Global Const $wm_ctlcolor = 25
Global Const $wm_settingchange = 26
Global Const $wm_wininichange = 26
Global Const $wm_devmodechange = 27
Global Const $wm_activateapp = 28
Global Const $wm_fontchange = 29
Global Const $wm_timechange = 30
Global Const $wm_cancelmode = 31
Global Const $wm_setcursor = 32
Global Const $wm_mouseactivate = 33
Global Const $wm_childactivate = 34
Global Const $wm_queuesync = 35
Global Const $wm_getminmaxinfo = 36
Global Const $wm_logoff = 37
Global Const $wm_painticon = 38
Global Const $wm_iconerasebkgnd = 39
Global Const $wm_nextdlgctl = 40
Global Const $wm_alttabactive = 41
Global Const $wm_spoolerstatus = 42
Global Const $wm_drawitem = 43
Global Const $wm_measureitem = 44
Global Const $wm_deleteitem = 45
Global Const $wm_vkeytoitem = 46
Global Const $wm_chartoitem = 47
Global Const $wm_setfont = 48
Global Const $wm_getfont = 49
Global Const $wm_sethotkey = 50
Global Const $wm_gethotkey = 51
Global Const $wm_filesyschange = 52
Global Const $wm_isactiveicon = 53
Global Const $wm_queryparkicon = 54
Global Const $wm_querydragicon = 55
Global Const $wm_winhelp = 56
Global Const $wm_compareitem = 57
Global Const $wm_fullscreen = 58
Global Const $wm_clientshutdown = 59
Global Const $wm_ddemlevent = 60
Global Const $wm_getobject = 61
Global Const $wm_calcscroll = 63
Global Const $wm_testing = 64
Global Const $wm_compacting = 65
Global Const $wm_otherwindowcreated = 66
Global Const $wm_otherwindowdestroyed = 67
Global Const $wm_commnotify = 68
Global Const $wm_mediastatuschange = 69
Global Const $wm_windowposchanging = 70
Global Const $wm_windowposchanged = 71
Global Const $wm_power = 72
Global Const $wm_copyglobaldata = 73
Global Const $wm_copydata = 74
Global Const $wm_canceljournal = 75
Global Const $wm_logonnotify = 76
Global Const $wm_keyf1 = 77
Global Const $wm_notify = 78
Global Const $wm_access_window = 79
Global Const $wm_inputlangchangerequest = 80
Global Const $wm_inputlangchange = 81
Global Const $wm_tcard = 82
Global Const $wm_help = 83
Global Const $wm_userchanged = 84
Global Const $wm_notifyformat = 85
Global Const $wm_qm_activate = 96
Global Const $wm_hook_do_callback = 97
Global Const $wm_syscopydata = 98
Global Const $wm_finaldestroy = 112
Global Const $wm_measureitem_clientdata = 113
Global Const $wm_contextmenu = 123
Global Const $wm_stylechanging = 124
Global Const $wm_stylechanged = 125
Global Const $wm_displaychange = 126
Global Const $wm_geticon = 127
Global Const $wm_seticon = 128
Global Const $wm_nccreate = 129
Global Const $wm_ncdestroy = 130
Global Const $wm_nccalcsize = 131
Global Const $wm_nchittest = 132
Global Const $wm_ncpaint = 133
Global Const $wm_ncactivate = 134
Global Const $wm_getdlgcode = 135
Global Const $wm_syncpaint = 136
Global Const $wm_synctask = 137
Global Const $wm_kludgeminrect = 139
Global Const $wm_lpkdrawswitchwnd = 140
Global Const $wm_uahdestroywindow = 144
Global Const $wm_uahdrawmenu = 145
Global Const $wm_uahdrawmenuitem = 146
Global Const $wm_uahinitmenu = 147
Global Const $wm_uahmeasuremenuitem = 148
Global Const $wm_uahncpaintmenupopup = 149
Global Const $wm_ncmousemove = 160
Global Const $wm_nclbuttondown = 161
Global Const $wm_nclbuttonup = 162
Global Const $wm_nclbuttondblclk = 163
Global Const $wm_ncrbuttondown = 164
Global Const $wm_ncrbuttonup = 165
Global Const $wm_ncrbuttondblclk = 166
Global Const $wm_ncmbuttondown = 167
Global Const $wm_ncmbuttonup = 168
Global Const $wm_ncmbuttondblclk = 169
Global Const $wm_ncxbuttondown = 171
Global Const $wm_ncxbuttonup = 172
Global Const $wm_ncxbuttondblclk = 173
Global Const $wm_ncuahdrawcaption = 174
Global Const $wm_ncuahdrawframe = 175
Global Const $wm_input_device_change = 254
Global Const $wm_input = 255
Global Const $wm_keydown = 256
Global Const $wm_keyfirst = 256
Global Const $wm_keyup = 257
Global Const $wm_char = 258
Global Const $wm_deadchar = 259
Global Const $wm_syskeydown = 260
Global Const $wm_syskeyup = 261
Global Const $wm_syschar = 262
Global Const $wm_sysdeadchar = 263
Global Const $wm_yomichar = 264
Global Const $wm_keylast = 265
Global Const $wm_unichar = 265
Global Const $wm_convertrequest = 266
Global Const $wm_convertresult = 267
Global Const $wm_im_info = 268
Global Const $wm_ime_startcomposition = 269
Global Const $wm_ime_endcomposition = 270
Global Const $wm_ime_composition = 271
Global Const $wm_ime_keylast = 271
Global Const $wm_initdialog = 272
Global Const $wm_command = 273
Global Const $wm_syscommand = 274
Global Const $wm_timer = 275
Global Const $wm_hscroll = 276
Global Const $wm_vscroll = 277
Global Const $wm_initmenu = 278
Global Const $wm_initmenupopup = 279
Global Const $wm_systimer = 280
Global Const $wm_gesture = 281
Global Const $wm_gesturenotify = 282
Global Const $wm_gestureinput = 283
Global Const $wm_gesturenotified = 284
Global Const $wm_menuselect = 287
Global Const $wm_menuchar = 288
Global Const $wm_enteridle = 289
Global Const $wm_menurbuttonup = 290
Global Const $wm_menudrag = 291
Global Const $wm_menugetobject = 292
Global Const $wm_uninitmenupopup = 293
Global Const $wm_menucommand = 294
Global Const $wm_changeuistate = 295
Global Const $wm_updateuistate = 296
Global Const $wm_queryuistate = 297
Global Const $wm_lbtrackpoint = 305
Global Const $wm_ctlcolormsgbox = 306
Global Const $wm_ctlcoloredit = 307
Global Const $wm_ctlcolorlistbox = 308
Global Const $wm_ctlcolorbtn = 309
Global Const $wm_ctlcolordlg = 310
Global Const $wm_ctlcolorscrollbar = 311
Global Const $wm_ctlcolorstatic = 312
Global Const $mn_gethmenu = 481
Global Const $wm_parentnotify = 528
Global Const $wm_entermenuloop = 529
Global Const $wm_exitmenuloop = 530
Global Const $wm_nextmenu = 531
Global Const $wm_sizing = 532
Global Const $wm_capturechanged = 533
Global Const $wm_moving = 534
Global Const $wm_powerbroadcast = 536
Global Const $wm_devicechange = 537
Global Const $wm_mdicreate = 544
Global Const $wm_mdidestroy = 545
Global Const $wm_mdiactivate = 546
Global Const $wm_mdirestore = 547
Global Const $wm_mdinext = 548
Global Const $wm_mdimaximize = 549
Global Const $wm_mditile = 550
Global Const $wm_mdicascade = 551
Global Const $wm_mdiiconarrange = 552
Global Const $wm_mdigetactive = 553
Global Const $wm_dropobject = 554
Global Const $wm_querydropobject = 555
Global Const $wm_begindrag = 556
Global Const $wm_dragloop = 557
Global Const $wm_dragselect = 558
Global Const $wm_dragmove = 559
Global Const $wm_mdisetmenu = 560
Global Const $wm_entersizemove = 561
Global Const $wm_exitsizemove = 562
Global Const $wm_dropfiles = 563
Global Const $wm_mdirefreshmenu = 564
Global Const $wm_touch = 576
Global Const $wm_ime_setcontext = 641
Global Const $wm_ime_notify = 642
Global Const $wm_ime_control = 643
Global Const $wm_ime_compositionfull = 644
Global Const $wm_ime_select = 645
Global Const $wm_ime_char = 646
Global Const $wm_ime_system = 647
Global Const $wm_ime_request = 648
Global Const $wm_ime_keydown = 656
Global Const $wm_ime_keyup = 657
Global Const $wm_ncmousehover = 672
Global Const $wm_mousehover = 673
Global Const $wm_ncmouseleave = 674
Global Const $wm_mouseleave = 675
Global Const $wm_wtssession_change = 689
Global Const $wm_tablet_first = 704
Global Const $wm_tablet_last = 735
Global Const $wm_cut = 768
Global Const $wm_copy = 769
Global Const $wm_paste = 770
Global Const $wm_clear = 771
Global Const $wm_undo = 772
Global Const $wm_paletteischanging = 784
Global Const $wm_hotkey = 786
Global Const $wm_palettechanged = 785
Global Const $wm_sysmenu = 787
Global Const $wm_hookmsg = 788
Global Const $wm_exitprocess = 789
Global Const $wm_wakethread = 790
Global Const $wm_print = 791
Global Const $wm_printclient = 792
Global Const $wm_appcommand = 793
Global Const $wm_querynewpalette = 783
Global Const $wm_themechanged = 794
Global Const $wm_uahinit = 795
Global Const $wm_desktopnotify = 796
Global Const $wm_clipboardupdate = 797
Global Const $wm_dwmcompositionchanged = 798
Global Const $wm_dwmncrenderingchanged = 799
Global Const $wm_dwmcolorizationcolorchanged = 800
Global Const $wm_dwmwindowmaximizedchange = 801
Global Const $wm_dwmexileframe = 802
Global Const $wm_dwmsendiconicthumbnail = 803
Global Const $wm_magnification_started = 804
Global Const $wm_magnification_ended = 805
Global Const $wm_dwmsendiconiclivepreviewbitmap = 806
Global Const $wm_dwmthumbnailsizechanged = 807
Global Const $wm_magnification_output = 808
Global Const $wm_measurecontrol = 816
Global Const $wm_getactiontext = 817
Global Const $wm_forwardkeydown = 819
Global Const $wm_forwardkeyup = 820
Global Const $wm_gettitlebarinfoex = 831
Global Const $wm_notifywow = 832
Global Const $wm_handheldfirst = 856
Global Const $wm_handheldlast = 863
Global Const $wm_afxfirst = 864
Global Const $wm_afxlast = 895
Global Const $wm_penwinfirst = 896
Global Const $wm_penwinlast = 911
Global Const $wm_dde_initiate = 992
Global Const $wm_dde_terminate = 993
Global Const $wm_dde_advise = 994
Global Const $wm_dde_unadvise = 995
Global Const $wm_dde_ack = 996
Global Const $wm_dde_data = 997
Global Const $wm_dde_request = 998
Global Const $wm_dde_poke = 999
Global Const $wm_dde_execute = 1000
Global Const $wm_dbnotification = 1021
Global Const $wm_netconnect = 1022
Global Const $wm_hibernate = 1023
Global Const $wm_user = 1024
Global Const $wm_app = 32768
Global Const $nm_first = 0
Global Const $nm_outofmemory = $nm_first - 1
Global Const $nm_click = $nm_first - 2
Global Const $nm_dblclk = $nm_first - 3
Global Const $nm_return = $nm_first - 4
Global Const $nm_rclick = $nm_first - 5
Global Const $nm_rdblclk = $nm_first - 6
Global Const $nm_setfocus = $nm_first - 7
Global Const $nm_killfocus = $nm_first - 8
Global Const $nm_customdraw = $nm_first - 12
Global Const $nm_hover = $nm_first - 13
Global Const $nm_nchittest = $nm_first - 14
Global Const $nm_keydown = $nm_first - 15
Global Const $nm_releasedcapture = $nm_first - 16
Global Const $nm_setcursor = $nm_first - 17
Global Const $nm_char = $nm_first - 18
Global Const $nm_tooltipscreated = $nm_first - 19
Global Const $nm_ldown = $nm_first - 20
Global Const $nm_rdown = $nm_first - 21
Global Const $nm_themechanged = $nm_first - 22
Global Const $wm_mousefirst = 512
Global Const $wm_mousemove = 512
Global Const $wm_lbuttondown = 513
Global Const $wm_lbuttonup = 514
Global Const $wm_lbuttondblclk = 515
Global Const $wm_rbuttondown = 516
Global Const $wm_rbuttonup = 517
Global Const $wm_rbuttondblclk = 518
Global Const $wm_mbuttondown = 519
Global Const $wm_mbuttonup = 520
Global Const $wm_mbuttondblclk = 521
Global Const $wm_mousewheel = 522
Global Const $wm_xbuttondown = 523
Global Const $wm_xbuttonup = 524
Global Const $wm_xbuttondblclk = 525
Global Const $wm_mousehwheel = 526
Global Const $ps_solid = 0
Global Const $ps_dash = 1
Global Const $ps_dot = 2
Global Const $ps_dashdot = 3
Global Const $ps_dashdotdot = 4
Global Const $ps_null = 5
Global Const $ps_insideframe = 6
Global Const $ps_userstyle = 7
Global Const $ps_alternate = 8
Global Const $ps_endcap_round = 0
Global Const $ps_endcap_square = 256
Global Const $ps_endcap_flat = 512
Global Const $ps_join_bevel = 4096
Global Const $ps_join_miter = 8192
Global Const $ps_join_round = 0
Global Const $ps_geometric = 65536
Global Const $ps_cosmetic = 0
Global Const $lwa_alpha = 2
Global Const $lwa_colorkey = 1
Global Const $rgn_and = 1
Global Const $rgn_or = 2
Global Const $rgn_xor = 3
Global Const $rgn_diff = 4
Global Const $rgn_copy = 5
Global Const $errorregion = 0
Global Const $nullregion = 1
Global Const $simpleregion = 2
Global Const $complexregion = 3
Global Const $transparent = 1
Global Const $opaque = 2
Global Const $ccm_first = 8192
Global Const $ccm_getunicodeformat = ($ccm_first + 6)
Global Const $ccm_setunicodeformat = ($ccm_first + 5)
Global Const $ccm_setbkcolor = $ccm_first + 1
Global Const $ccm_setcolorscheme = $ccm_first + 2
Global Const $ccm_getcolorscheme = $ccm_first + 3
Global Const $ccm_getdroptarget = $ccm_first + 4
Global Const $ccm_setwindowtheme = $ccm_first + 11
Global Const $ga_parent = 1
Global Const $ga_root = 2
Global Const $ga_rootowner = 3
Global Const $sm_cxscreen = 0
Global Const $sm_cyscreen = 1
Global Const $sm_cxvscroll = 2
Global Const $sm_cyhscroll = 3
Global Const $sm_cycaption = 4
Global Const $sm_cxborder = 5
Global Const $sm_cyborder = 6
Global Const $sm_cxdlgframe = 7
Global Const $sm_cydlgframe = 8
Global Const $sm_cyvthumb = 9
Global Const $sm_cxhthumb = 10
Global Const $sm_cxicon = 11
Global Const $sm_cyicon = 12
Global Const $sm_cxcursor = 13
Global Const $sm_cycursor = 14
Global Const $sm_cymenu = 15
Global Const $sm_cxfullscreen = 16
Global Const $sm_cyfullscreen = 17
Global Const $sm_cykanjiwindow = 18
Global Const $sm_mousepresent = 19
Global Const $sm_cyvscroll = 20
Global Const $sm_cxhscroll = 21
Global Const $sm_debug = 22
Global Const $sm_swapbutton = 23
Global Const $sm_reserved1 = 24
Global Const $sm_reserved2 = 25
Global Const $sm_reserved3 = 26
Global Const $sm_reserved4 = 27
Global Const $sm_cxmin = 28
Global Const $sm_cymin = 29
Global Const $sm_cxsize = 30
Global Const $sm_cysize = 31
Global Const $sm_cxframe = 32
Global Const $sm_cyframe = 33
Global Const $sm_cxmintrack = 34
Global Const $sm_cymintrack = 35
Global Const $sm_cxdoubleclk = 36
Global Const $sm_cydoubleclk = 37
Global Const $sm_cxiconspacing = 38
Global Const $sm_cyiconspacing = 39
Global Const $sm_menudropalignment = 40
Global Const $sm_penwindows = 41
Global Const $sm_dbcsenabled = 42
Global Const $sm_cmousebuttons = 43
Global Const $sm_secure = 44
Global Const $sm_cxedge = 45
Global Const $sm_cyedge = 46
Global Const $sm_cxminspacing = 47
Global Const $sm_cyminspacing = 48
Global Const $sm_cxsmicon = 49
Global Const $sm_cysmicon = 50
Global Const $sm_cysmcaption = 51
Global Const $sm_cxsmsize = 52
Global Const $sm_cysmsize = 53
Global Const $sm_cxmenusize = 54
Global Const $sm_cymenusize = 55
Global Const $sm_arrange = 56
Global Const $sm_cxminimized = 57
Global Const $sm_cyminimized = 58
Global Const $sm_cxmaxtrack = 59
Global Const $sm_cymaxtrack = 60
Global Const $sm_cxmaximized = 61
Global Const $sm_cymaximized = 62
Global Const $sm_network = 63
Global Const $sm_cleanboot = 67
Global Const $sm_cxdrag = 68
Global Const $sm_cydrag = 69
Global Const $sm_showsounds = 70
Global Const $sm_cxmenucheck = 71
Global Const $sm_cymenucheck = 72
Global Const $sm_slowmachine = 73
Global Const $sm_mideastenabled = 74
Global Const $sm_mousewheelpresent = 75
Global Const $sm_xvirtualscreen = 76
Global Const $sm_yvirtualscreen = 77
Global Const $sm_cxvirtualscreen = 78
Global Const $sm_cyvirtualscreen = 79
Global Const $sm_cmonitors = 80
Global Const $sm_samedisplayformat = 81
Global Const $sm_immenabled = 82
Global Const $sm_cxfocusborder = 83
Global Const $sm_cyfocusborder = 84
Global Const $sm_tabletpc = 86
Global Const $sm_mediacenter = 87
Global Const $sm_starter = 88
Global Const $sm_serverr2 = 89
Global Const $sm_cmetrics = 90
Global Const $sm_remotesession = 4096
Global Const $sm_shuttingdown = 8192
Global Const $sm_remotecontrol = 8193
Global Const $sm_caretblinkingenabled = 8194
Global Const $blackness = 66
Global Const $captureblt = 1073741824
Global Const $dstinvert = 5570569
Global Const $mergecopy = 12583114
Global Const $mergepaint = 12255782
Global Const $nomirrorbitmap = -2147483648
Global Const $notsrccopy = 3342344
Global Const $notsrcerase = 1114278
Global Const $patcopy = 15728673
Global Const $patinvert = 5898313
Global Const $patpaint = 16452105
Global Const $srcand = 8913094
Global Const $srccopy = 13369376
Global Const $srcerase = 4457256
Global Const $srcinvert = 6684742
Global Const $srcpaint = 15597702
Global Const $whiteness = 16711778
Global Const $dt_bottom = 8
Global Const $dt_calcrect = 1024
Global Const $dt_center = 1
Global Const $dt_editcontrol = 8192
Global Const $dt_end_ellipsis = 32768
Global Const $dt_expandtabs = 64
Global Const $dt_externalleading = 512
Global Const $dt_hideprefix = 1048576
Global Const $dt_internal = 4096
Global Const $dt_left = 0
Global Const $dt_modifystring = 65536
Global Const $dt_noclip = 256
Global Const $dt_nofullwidthcharbreak = 524288
Global Const $dt_noprefix = 2048
Global Const $dt_path_ellipsis = 16384
Global Const $dt_prefixonly = 2097152
Global Const $dt_right = 2
Global Const $dt_rtlreading = 131072
Global Const $dt_singleline = 32
Global Const $dt_tabstop = 128
Global Const $dt_top = 0
Global Const $dt_vcenter = 4
Global Const $dt_wordbreak = 16
Global Const $dt_word_ellipsis = 262144
Global Const $rdw_erase = 4
Global Const $rdw_frame = 1024
Global Const $rdw_internalpaint = 2
Global Const $rdw_invalidate = 1
Global Const $rdw_noerase = 32
Global Const $rdw_noframe = 2048
Global Const $rdw_nointernalpaint = 16
Global Const $rdw_validate = 8
Global Const $rdw_erasenow = 512
Global Const $rdw_updatenow = 256
Global Const $rdw_allchildren = 128
Global Const $rdw_nochildren = 64
Global Const $wm_renderformat = 773
Global Const $wm_renderallformats = 774
Global Const $wm_destroyclipboard = 775
Global Const $wm_drawclipboard = 776
Global Const $wm_paintclipboard = 777
Global Const $wm_vscrollclipboard = 778
Global Const $wm_sizeclipboard = 779
Global Const $wm_askcbformatname = 780
Global Const $wm_changecbchain = 781
Global Const $wm_hscrollclipboard = 782
Global Const $hterror = -2
Global Const $httransparent = -1
Global Const $htnowhere = 0
Global Const $htclient = 1
Global Const $htcaption = 2
Global Const $htsysmenu = 3
Global Const $htgrowbox = 4
Global Const $htsize = $htgrowbox
Global Const $htmenu = 5
Global Const $hthscroll = 6
Global Const $htvscroll = 7
Global Const $htminbutton = 8
Global Const $htmaxbutton = 9
Global Const $htleft = 10
Global Const $htright = 11
Global Const $httop = 12
Global Const $httopleft = 13
Global Const $httopright = 14
Global Const $htbottom = 15
Global Const $htbottomleft = 16
Global Const $htbottomright = 17
Global Const $htborder = 18
Global Const $htreduce = $htminbutton
Global Const $htzoom = $htmaxbutton
Global Const $htsizefirst = $htleft
Global Const $htsizelast = $htbottomright
Global Const $htobject = 19
Global Const $htclose = 20
Global Const $hthelp = 21
Global Const $color_scrollbar = 0
Global Const $color_background = 1
Global Const $color_activecaption = 2
Global Const $color_inactivecaption = 3
Global Const $color_menu = 4
Global Const $color_window = 5
Global Const $color_windowframe = 6
Global Const $color_menutext = 7
Global Const $color_windowtext = 8
Global Const $color_captiontext = 9
Global Const $color_activeborder = 10
Global Const $color_inactiveborder = 11
Global Const $color_appworkspace = 12
Global Const $color_highlight = 13
Global Const $color_highlighttext = 14
Global Const $color_btnface = 15
Global Const $color_btnshadow = 16
Global Const $color_graytext = 17
Global Const $color_btntext = 18
Global Const $color_inactivecaptiontext = 19
Global Const $color_btnhighlight = 20
Global Const $color_3ddkshadow = 21
Global Const $color_3dlight = 22
Global Const $color_infotext = 23
Global Const $color_infobk = 24
Global Const $color_hotlight = 26
Global Const $color_gradientactivecaption = 27
Global Const $color_gradientinactivecaption = 28
Global Const $color_menuhilight = 29
Global Const $color_menubar = 30
Global Const $color_desktop = 1
Global Const $color_3dface = 15
Global Const $color_3dshadow = 16
Global Const $color_3dhighlight = 20
Global Const $color_3dhilight = 20
Global Const $color_btnhilight = 20
Global Const $hinst_commctrl = -1
Global Const $idb_std_small_color = 0
Global Const $idb_std_large_color = 1
Global Const $idb_view_small_color = 4
Global Const $idb_view_large_color = 5
Global Const $idb_hist_small_color = 8
Global Const $idb_hist_large_color = 9
Global Const $startf_forceofffeedback = 128
Global Const $startf_forceonfeedback = 64
Global Const $startf_preventpinning = 8192
Global Const $startf_runfullscreen = 32
Global Const $startf_titleisappid = 4096
Global Const $startf_titleislinkname = 2048
Global Const $startf_usecountchars = 8
Global Const $startf_usefillattribute = 16
Global Const $startf_usehotkey = 512
Global Const $startf_useposition = 4
Global Const $startf_useshowwindow = 1
Global Const $startf_usesize = 2
Global Const $startf_usestdhandles = 256
Global Const $cdds_prepaint = 1
Global Const $cdds_postpaint = 2
Global Const $cdds_preerase = 3
Global Const $cdds_posterase = 4
Global Const $cdds_item = 65536
Global Const $cdds_itemprepaint = 65537
Global Const $cdds_itempostpaint = 65538
Global Const $cdds_itempreerase = 65539
Global Const $cdds_itemposterase = 65540
Global Const $cdds_subitem = 131072
Global Const $cdis_selected = 1
Global Const $cdis_grayed = 2
Global Const $cdis_disabled = 4
Global Const $cdis_checked = 8
Global Const $cdis_focus = 16
Global Const $cdis_default = 32
Global Const $cdis_hot = 64
Global Const $cdis_marked = 128
Global Const $cdis_indeterminate = 256
Global Const $cdis_showkeyboardcues = 512
Global Const $cdis_nearhot = 1024
Global Const $cdis_othersidehot = 2048
Global Const $cdis_drophilited = 4096
Global Const $cdrf_dodefault = 0
Global Const $cdrf_newfont = 2
Global Const $cdrf_skipdefault = 4
Global Const $cdrf_notifypostpaint = 16
Global Const $cdrf_notifyitemdraw = 32
Global Const $cdrf_notifysubitemdraw = 32
Global Const $cdrf_notifyposterase = 64
Global Const $cdrf_doerase = 8
Global Const $cdrf_skippostpaint = 256
Global Const $gui_ss_default_gui = BitOR($ws_minimizebox, $ws_caption, $ws_popup, $ws_sysmenu)
Global Const $gmem_fixed = 0
Global Const $gmem_moveable = 2
Global Const $gmem_nocompact = 16
Global Const $gmem_nodiscard = 32
Global Const $gmem_zeroinit = 64
Global Const $gmem_modify = 128
Global Const $gmem_discardable = 256
Global Const $gmem_not_banked = 4096
Global Const $gmem_share = 8192
Global Const $gmem_ddeshare = 8192
Global Const $gmem_notify = 16384
Global Const $gmem_lower = 4096
Global Const $gmem_valid_flags = 32626
Global Const $gmem_invalid_handle = 32768
Global Const $gptr = BitOR($gmem_fixed, $gmem_zeroinit)
Global Const $ghnd = BitOR($gmem_moveable, $gmem_zeroinit)
Global Const $mem_commit = 4096
Global Const $mem_reserve = 8192
Global Const $mem_top_down = 1048576
Global Const $mem_shared = 134217728
Global Const $page_noaccess = 1
Global Const $page_readonly = 2
Global Const $page_readwrite = 4
Global Const $page_execute = 16
Global Const $page_execute_read = 32
Global Const $page_execute_readwrite = 64
Global Const $page_execute_writecopy = 128
Global Const $page_guard = 256
Global Const $page_nocache = 512
Global Const $page_writecombine = 1024
Global Const $page_writecopy = 8
Global Const $mem_decommit = 16384
Global Const $mem_release = 32768
Global Const $process_terminate = 1
Global Const $process_create_thread = 2
Global Const $process_set_sessionid = 4
Global Const $process_vm_operation = 8
Global Const $process_vm_read = 16
Global Const $process_vm_write = 32
Global Const $process_dup_handle = 64
Global Const $process_create_process = 128
Global Const $process_set_quota = 256
Global Const $process_set_information = 512
Global Const $process_query_information = 1024
Global Const $process_query_limited_information = 4096
Global Const $process_suspend_resume = 2048
Global Const $process_all_access = 2035711
Global Const $tagmemmap = "handle hProc;ulong_ptr Size;ptr Mem"

Func _memfree(ByRef $tmemmap)
	Local $pmemory = DllStructGetData($tmemmap, "Mem")
	Local $hprocess = DllStructGetData($tmemmap, "hProc")
	Local $bresult = _memvirtualfreeex($hprocess, $pmemory, 0, $mem_release)
	DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hprocess)
	If @error Then Return SetError(@error, @extended, False)
	Return $bresult
EndFunc

Func _memglobalalloc($ibytes, $iflags = 0)
	Local $aresult = DllCall("kernel32.dll", "handle", "GlobalAlloc", "uint", $iflags, "ulong_ptr", $ibytes)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _memglobalfree($hmemory)
	Local $aresult = DllCall("kernel32.dll", "ptr", "GlobalFree", "handle", $hmemory)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _memgloballock($hmemory)
	Local $aresult = DllCall("kernel32.dll", "ptr", "GlobalLock", "handle", $hmemory)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _memglobalsize($hmemory)
	Local $aresult = DllCall("kernel32.dll", "ulong_ptr", "GlobalSize", "handle", $hmemory)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _memglobalunlock($hmemory)
	Local $aresult = DllCall("kernel32.dll", "bool", "GlobalUnlock", "handle", $hmemory)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _meminit($hwnd, $isize, ByRef $tmemmap)
	Local $aresult = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $hwnd, "dword*", 0)
	If @error Then Return SetError(@error + 10, @extended, 0)
	Local $iprocessid = $aresult[2]
	If $iprocessid = 0 Then Return SetError(1, 0, 0)
	Local $iaccess = BitOR($process_vm_operation, $process_vm_read, $process_vm_write)
	Local $hprocess = __mem_openprocess($iaccess, False, $iprocessid, True)
	Local $ialloc = BitOR($mem_reserve, $mem_commit)
	Local $pmemory = _memvirtualallocex($hprocess, 0, $isize, $ialloc, $page_readwrite)
	If $pmemory = 0 Then Return SetError(2, 0, 0)
	$tmemmap = DllStructCreate($tagmemmap)
	DllStructSetData($tmemmap, "hProc", $hprocess)
	DllStructSetData($tmemmap, "Size", $isize)
	DllStructSetData($tmemmap, "Mem", $pmemory)
	Return $pmemory
EndFunc

Func _memmovememory($psource, $pdest, $ilength)
	DllCall("kernel32.dll", "none", "RtlMoveMemory", "struct*", $pdest, "struct*", $psource, "ulong_ptr", $ilength)
	If @error Then Return SetError(@error, @extended)
EndFunc

Func _memread(ByRef $tmemmap, $psrce, $pdest, $isize)
	Local $aresult = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", DllStructGetData($tmemmap, "hProc"), "ptr", $psrce, "struct*", $pdest, "ulong_ptr", $isize, "ulong_ptr*", 0)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _memwrite(ByRef $tmemmap, $psrce, $pdest = 0, $isize = 0, $ssrce = "struct*")
	If $pdest = 0 Then $pdest = DllStructGetData($tmemmap, "Mem")
	If $isize = 0 Then $isize = DllStructGetData($tmemmap, "Size")
	Local $aresult = DllCall("kernel32.dll", "bool", "WriteProcessMemory", "handle", DllStructGetData($tmemmap, "hProc"), "ptr", $pdest, $ssrce, $psrce, "ulong_ptr", $isize, "ulong_ptr*", 0)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _memvirtualalloc($paddress, $isize, $iallocation, $iprotect)
	Local $aresult = DllCall("kernel32.dll", "ptr", "VirtualAlloc", "ptr", $paddress, "ulong_ptr", $isize, "dword", $iallocation, "dword", $iprotect)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _memvirtualallocex($hprocess, $paddress, $isize, $iallocation, $iprotect)
	Local $aresult = DllCall("kernel32.dll", "ptr", "VirtualAllocEx", "handle", $hprocess, "ptr", $paddress, "ulong_ptr", $isize, "dword", $iallocation, "dword", $iprotect)
	If @error Then Return SetError(@error, @extended, 0)
	Return $aresult[0]
EndFunc

Func _memvirtualfree($paddress, $isize, $ifreetype)
	Local $aresult = DllCall("kernel32.dll", "bool", "VirtualFree", "ptr", $paddress, "ulong_ptr", $isize, "dword", $ifreetype)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func _memvirtualfreeex($hprocess, $paddress, $isize, $ifreetype)
	Local $aresult = DllCall("kernel32.dll", "bool", "VirtualFreeEx", "handle", $hprocess, "ptr", $paddress, "ulong_ptr", $isize, "dword", $ifreetype)
	If @error Then Return SetError(@error, @extended, False)
	Return $aresult[0]
EndFunc

Func __mem_openprocess($iaccess, $binherit, $iprocessid, $bdebugpriv = False)
	Local $aresult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iaccess, "bool", $binherit, "dword", $iprocessid)
	If @error Then Return SetError(@error + 10, @extended, 0)
	If $aresult[0] Then Return $aresult[0]
	If NOT $bdebugpriv Then Return 0
	Local $htoken = _security__openthreadtokenex(BitOR($token_adjust_privileges, $token_query))
	If @error Then Return SetError(@error + 20, @extended, 0)
	_security__setprivilege($htoken, "SeDebugPrivilege", True)
	Local $ierror = @error
	Local $ilasterror = @extended
	Local $iret = 0
	If NOT @error Then
		$aresult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iaccess, "bool", $binherit, "dword", $iprocessid)
		$ierror = @error
		$ilasterror = @extended
		If $aresult[0] Then $iret = $aresult[0]
		_security__setprivilege($htoken, "SeDebugPrivilege", False)
		If @error Then
			$ierror = @error + 30
			$ilasterror = @extended
		EndIf
	Else
		$ierror = @error + 40
	EndIf
	DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $htoken)
	Return SetError($ierror, $ilasterror, $iret)
EndFunc

Global Const $sbars_sizegrip = 256
Global Const $sbt_tooltips = 2048
Global Const $sbars_tooltips = 2048
Global Const $sbt_sunken = 0
Global Const $sbt_noborders = 256
Global Const $sbt_popout = 512
Global Const $sbt_rtlreading = 1024
Global Const $sbt_notabparsing = 2048
Global Const $sbt_ownerdraw = 4096
Global Const $__statusbarconstant_wm_user = 1024
Global Const $sb_getborders = ($__statusbarconstant_wm_user + 7)
Global Const $sb_geticon = ($__statusbarconstant_wm_user + 20)
Global Const $sb_getparts = ($__statusbarconstant_wm_user + 6)
Global Const $sb_getrect = ($__statusbarconstant_wm_user + 10)
Global Const $sb_gettexta = ($__statusbarconstant_wm_user + 2)
Global Const $sb_gettextw = ($__statusbarconstant_wm_user + 13)
Global Const $sb_gettext = $sb_gettexta
Global Const $sb_gettextlengtha = ($__statusbarconstant_wm_user + 3)
Global Const $sb_gettextlengthw = ($__statusbarconstant_wm_user + 12)
Global Const $sb_gettextlength = $sb_gettextlengtha
Global Const $sb_gettiptexta = ($__statusbarconstant_wm_user + 18)
Global Const $sb_gettiptextw = ($__statusbarconstant_wm_user + 19)
Global Const $sb_getunicodeformat = 8192 + 6
Global Const $sb_issimple = ($__statusbarconstant_wm_user + 14)
Global Const $sb_setbkcolor = 8192 + 1
Global Const $sb_seticon = ($__statusbarconstant_wm_user + 15)
Global Const $sb_setminheight = ($__statusbarconstant_wm_user + 8)
Global Const $sb_setparts = ($__statusbarconstant_wm_user + 4)
Global Const $sb_settexta = ($__statusbarconstant_wm_user + 1)
Global Const $sb_settextw = ($__statusbarconstant_wm_user + 11)
Global Const $sb_settext = $sb_settexta
Global Const $sb_settiptexta = ($__statusbarconstant_wm_user + 16)
Global Const $sb_settiptextw = ($__statusbarconstant_wm_user + 17)
Global Const $sb_setunicodeformat = 8192 + 5
Global Const $sb_simple = ($__statusbarconstant_wm_user + 9)
Global Const $sb_simpleid = 255
Global Const $sbn_first = -880
Global Const $sbn_simplemodechange = $sbn_first + 0
Global Const $_udf_globalids_offset = 2
Global Const $_udf_globalid_max_win = 16
Global Const $_udf_startid = 10000
Global Const $_udf_globalid_max_ids = 55535
Global Const $__udfguiconstant_ws_tabstop = 65536
Global Const $__udfguiconstant_ws_visible = 268435456
Global Const $__udfguiconstant_ws_child = 1073741824
Global $__g_audf_globalids_used[$_udf_globalid_max_win][$_udf_globalid_max_ids + $_udf_globalids_offset + 1]

Func __udf_getnextglobalid($hwnd)
	Local $nctrlid, $iusedindex = -1, $ballused = True
	If NOT WinExists($hwnd) Then Return SetError(-1, -1, 0)
	For $iindex = 0 To $_udf_globalid_max_win - 1
		If $__g_audf_globalids_used[$iindex][0] <> 0 Then
			If NOT WinExists($__g_audf_globalids_used[$iindex][0]) Then
				For $x = 0 To UBound($__g_audf_globalids_used, $ubound_columns) - 1
					$__g_audf_globalids_used[$iindex][$x] = 0
				Next
				$__g_audf_globalids_used[$iindex][1] = $_udf_startid
				$ballused = False
			EndIf
		EndIf
	Next
	For $iindex = 0 To $_udf_globalid_max_win - 1
		If $__g_audf_globalids_used[$iindex][0] = $hwnd Then
			$iusedindex = $iindex
			ExitLoop
		EndIf
	Next
	If $iusedindex = -1 Then
		For $iindex = 0 To $_udf_globalid_max_win - 1
			If $__g_audf_globalids_used[$iindex][0] = 0 Then
				$__g_audf_globalids_used[$iindex][0] = $hwnd
				$__g_audf_globalids_used[$iindex][1] = $_udf_startid
				$ballused = False
				$iusedindex = $iindex
				ExitLoop
			EndIf
		Next
	EndIf
	If $iusedindex = -1 AND $ballused Then Return SetError(16, 0, 0)
	If $__g_audf_globalids_used[$iusedindex][1] = $_udf_startid + $_udf_globalid_max_ids Then
		For $iidindex = $_udf_globalids_offset To UBound($__g_audf_globalids_used, $ubound_columns) - 1
			If $__g_audf_globalids_used[$iusedindex][$iidindex] = 0 Then
				$nctrlid = ($iidindex - $_udf_globalids_offset) + 10000
				$__g_audf_globalids_used[$iusedindex][$iidindex] = $nctrlid
				Return $nctrlid
			EndIf
		Next
		Return SetError(-1, $_udf_globalid_max_ids, 0)
	EndIf
	$nctrlid = $__g_audf_globalids_used[$iusedindex][1]
	$__g_audf_globalids_used[$iusedindex][1] += 1
	$__g_audf_globalids_used[$iusedindex][($nctrlid - 10000) + $_udf_globalids_offset] = $nctrlid
	Return $nctrlid
EndFunc

Func __udf_freeglobalid($hwnd, $iglobalid)
	If $iglobalid - $_udf_startid < 0 OR $iglobalid - $_udf_startid > $_udf_globalid_max_ids Then Return SetError(-1, 0, False)
	For $iindex = 0 To $_udf_globalid_max_win - 1
		If $__g_audf_globalids_used[$iindex][0] = $hwnd Then
			For $x = $_udf_globalids_offset To UBound($__g_audf_globalids_used, $ubound_columns) - 1
				If $__g_audf_globalids_used[$iindex][$x] = $iglobalid Then
					$__g_audf_globalids_used[$iindex][$x] = 0
					Return True
				EndIf
			Next
			Return SetError(-3, 0, False)
		EndIf
	Next
	Return SetError(-2, 0, False)
EndFunc

Global $__g_hsblastwnd
Global Const $__statusbarconstant_classname = "msctls_statusbar32"
Global Const $__statusbarconstant_wm_size = 5
Global Const $__statusbarconstant_clr_default = -16777216
Global Const $tagborders = "int BX;int BY;int RX"

Func _guictrlstatusbar_create($hwnd, $vpartedge = -1, $vparttext = "", $istyles = -1, $iexstyles = 0)
	If NOT IsHWnd($hwnd) Then Return SetError(1, 0, 0)
	Local $istyle = BitOR($__udfguiconstant_ws_child, $__udfguiconstant_ws_visible)
	If $istyles = -1 Then $istyles = 0
	If $iexstyles = -1 Then $iexstyles = 0
	Local $apartwidth[1], $aparttext[1]
	If @NumParams > 1 Then
		If IsArray($vpartedge) Then
			$apartwidth = $vpartedge
		Else
			$apartwidth[0] = $vpartedge
		EndIf
		If @NumParams = 2 Then
			ReDim $aparttext[UBound($apartwidth)]
		Else
			If IsArray($vparttext) Then
				$aparttext = $vparttext
			Else
				$aparttext[0] = $vparttext
			EndIf
			If UBound($apartwidth) <> UBound($aparttext) Then
				Local $ilast
				If UBound($apartwidth) > UBound($aparttext) Then
					$ilast = UBound($aparttext)
					ReDim $aparttext[UBound($apartwidth)]
				Else
					$ilast = UBound($apartwidth)
					ReDim $apartwidth[UBound($aparttext)]
					For $x = $ilast To UBound($apartwidth) - 1
						$apartwidth[$x] = $apartwidth[$x - 1] + 75
					Next
					$apartwidth[UBound($aparttext) - 1] = -1
				EndIf
			EndIf
		EndIf
		If NOT IsHWnd($hwnd) Then $hwnd = HWnd($hwnd)
		If @NumParams > 3 Then $istyle = BitOR($istyle, $istyles)
	EndIf
	Local $nctrlid = __udf_getnextglobalid($hwnd)
	If @error Then Return SetError(@error, @extended, 0)
	Local $hwndsbar = _winapi_createwindowex($iexstyles, $__statusbarconstant_classname, "", $istyle, 0, 0, 0, 0, $hwnd, $nctrlid)
	If @error Then Return SetError(@error, @extended, 0)
	If @NumParams > 1 Then
		_guictrlstatusbar_setparts($hwndsbar, UBound($apartwidth), $apartwidth)
		For $x = 0 To UBound($aparttext) - 1
			_guictrlstatusbar_settext($hwndsbar, $aparttext[$x], $x)
		Next
	EndIf
	Return $hwndsbar
EndFunc

Func _guictrlstatusbar_destroy(ByRef $hwnd)
	If NOT _winapi_isclassname($hwnd, $__statusbarconstant_classname) Then Return SetError(2, 2, False)
	Local $idestroyed = 0
	If IsHWnd($hwnd) Then
		If _winapi_inprocess($hwnd, $__g_hsblastwnd) Then
			Local $nctrlid = _winapi_getdlgctrlid($hwnd)
			Local $hparent = _winapi_getparent($hwnd)
			$idestroyed = _winapi_destroywindow($hwnd)
			Local $iret = __udf_freeglobalid($hparent, $nctrlid)
			If NOT $iret Then
			EndIf
		Else
			Return SetError(1, 1, False)
		EndIf
	EndIf
	If $idestroyed Then $hwnd = 0
	Return $idestroyed <> 0
EndFunc

Func _guictrlstatusbar_embedcontrol($hwnd, $ipart, $hcontrol, $ifit = 4)
	Local $arect = _guictrlstatusbar_getrect($hwnd, $ipart)
	Local $ibarx = $arect[0]
	Local $ibary = $arect[1]
	Local $ibarw = $arect[2] - $ibarx
	Local $ibarh = $arect[3] - $ibary
	Local $iconx = $ibarx
	Local $icony = $ibary
	Local $iconw = _winapi_getwindowwidth($hcontrol)
	Local $iconh = _winapi_getwindowheight($hcontrol)
	If $iconw > $ibarw Then $iconw = $ibarw
	If $iconh > $ibarh Then $iconh = $ibarh
	Local $ipadx = ($ibarw - $iconw) / 2
	Local $ipady = ($ibarh - $iconh) / 2
	If $ipadx < 0 Then $ipadx = 0
	If $ipady < 0 Then $ipady = 0
	If BitAND($ifit, 1) = 1 Then $iconx = $ibarx + $ipadx
	If BitAND($ifit, 2) = 2 Then $icony = $ibary + $ipady
	If BitAND($ifit, 4) = 4 Then
		$ipadx = _guictrlstatusbar_getbordersrect($hwnd)
		$ipady = _guictrlstatusbar_getbordersvert($hwnd)
		$iconx = $ibarx
		If _guictrlstatusbar_issimple($hwnd) Then $iconx += $ipadx
		$icony = $ibary + $ipady
		$iconw = $ibarw - ($ipadx * 2)
		$iconh = $ibarh - ($ipady * 2)
	EndIf
	_winapi_setparent($hcontrol, $hwnd)
	_winapi_movewindow($hcontrol, $iconx, $icony, $iconw, $iconh)
EndFunc

Func _guictrlstatusbar_getborders($hwnd)
	Local $tborders = DllStructCreate($tagborders)
	Local $iret
	If _winapi_inprocess($hwnd, $__g_hsblastwnd) Then
		$iret = _sendmessage($hwnd, $sb_getborders, 0, $tborders, 0, "wparam", "struct*")
	Else
		Local $isize = DllStructGetSize($tborders)
		Local $tmemmap
		Local $pmemory = _meminit($hwnd, $isize, $tmemmap)
		$iret = _sendmessage($hwnd, $sb_getborders, 0, $pmemory, 0, "wparam", "ptr")
		_memread($tmemmap, $pmemory, $tborders, $isize)
		_memfree($tmemmap)
	EndIf
	Local $aborders[3]
	If $iret = 0 Then Return SetError(-1, -1, $aborders)
	$aborders[0] = DllStructGetData($tborders, "BX")
	$aborders[1] = DllStructGetData($tborders, "BY")
	$aborders[2] = DllStructGetData($tborders, "RX")
	Return $aborders
EndFunc

Func _guictrlstatusbar_getbordershorz($hwnd)
	Local $aborders = _guictrlstatusbar_getborders($hwnd)
	Return SetError(@error, @extended, $aborders[0])
EndFunc

Func _guictrlstatusbar_getbordersrect($hwnd)
	Local $aborders = _guictrlstatusbar_getborders($hwnd)
	Return SetError(@error, @extended, $aborders[2])
EndFunc

Func _guictrlstatusbar_getbordersvert($hwnd)
	Local $aborders = _guictrlstatusbar_getborders($hwnd)
	Return SetError(@error, @extended, $aborders[1])
EndFunc

Func _guictrlstatusbar_getcount($hwnd)
	Return _sendmessage($hwnd, $sb_getparts)
EndFunc

Func _guictrlstatusbar_getheight($hwnd)
	Local $trect = _guictrlstatusbar_getrectex($hwnd, 0)
	Return DllStructGetData($trect, "Bottom") - DllStructGetData($trect, "Top") - (_guictrlstatusbar_getbordersvert($hwnd) * 2)
EndFunc

Func _guictrlstatusbar_geticon($hwnd, $iindex = 0)
	Return _sendmessage($hwnd, $sb_geticon, $iindex, 0, 0, "wparam", "lparam", "handle")
EndFunc

Func _guictrlstatusbar_getparts($hwnd)
	Local $icount = _guictrlstatusbar_getcount($hwnd)
	Local $tparts = DllStructCreate("int[" & $icount & "]")
	Local $aparts[$icount + 1]
	If _winapi_inprocess($hwnd, $__g_hsblastwnd) Then
		$aparts[0] = _sendmessage($hwnd, $sb_getparts, $icount, $tparts, 0, "wparam", "struct*")
	Else
		Local $iparts = DllStructGetSize($tparts)
		Local $tmemmap
		Local $pmemory = _meminit($hwnd, $iparts, $tmemmap)
		$aparts[0] = _sendmessage($hwnd, $sb_getparts, $icount, $pmemory, 0, "wparam", "ptr")
		_memread($tmemmap, $pmemory, $tparts, $iparts)
		_memfree($tmemmap)
	EndIf
	For $ii = 1 To $icount
		$aparts[$ii] = DllStructGetData($tparts, 1, $ii)
	Next
	Return $aparts
EndFunc

Func _guictrlstatusbar_getrect($hwnd, $ipart)
	Local $trect = _guictrlstatusbar_getrectex($hwnd, $ipart)
	If @error Then Return SetError(@error, 0, 0)
	Local $arect[4]
	$arect[0] = DllStructGetData($trect, "Left")
	$arect[1] = DllStructGetData($trect, "Top")
	$arect[2] = DllStructGetData($trect, "Right")
	$arect[3] = DllStructGetData($trect, "Bottom")
	Return $arect
EndFunc

Func _guictrlstatusbar_getrectex($hwnd, $ipart)
	Local $trect = DllStructCreate($tagrect)
	Local $iret
	If _winapi_inprocess($hwnd, $__g_hsblastwnd) Then
		$iret = _sendmessage($hwnd, $sb_getrect, $ipart, $trect, 0, "wparam", "struct*")
	Else
		Local $irect = DllStructGetSize($trect)
		Local $tmemmap
		Local $pmemory = _meminit($hwnd, $irect, $tmemmap)
		$iret = _sendmessage($hwnd, $sb_getrect, $ipart, $pmemory, 0, "wparam", "ptr")
		_memread($tmemmap, $pmemory, $trect, $irect)
		_memfree($tmemmap)
	EndIf
	Return SetError($iret = 0, 0, $trect)
EndFunc

Func _guictrlstatusbar_gettext($hwnd, $ipart)
	Local $bunicode = _guictrlstatusbar_getunicodeformat($hwnd)
	Local $ibuffer = _guictrlstatusbar_gettextlength($hwnd, $ipart) + 1
	If $ibuffer = 1 Then Return SetError(1, 0, "")
	Local $tbuffer
	If $bunicode Then
		$tbuffer = DllStructCreate("wchar Text[" & $ibuffer & "]")
		$ibuffer *= 2
	Else
		$tbuffer = DllStructCreate("char Text[" & $ibuffer & "]")
	EndIf
	If _winapi_inprocess($hwnd, $__g_hsblastwnd) Then
		_sendmessage($hwnd, $sb_gettextw, $ipart, $tbuffer, 0, "wparam", "struct*")
	Else
		Local $tmemmap
		Local $pmemory = _meminit($hwnd, $ibuffer, $tmemmap)
		If $bunicode Then
			_sendmessage($hwnd, $sb_gettextw, $ipart, $pmemory, 0, "wparam", "ptr")
		Else
			_sendmessage($hwnd, $sb_gettext, $ipart, $pmemory, 0, "wparam", "ptr")
		EndIf
		_memread($tmemmap, $pmemory, $tbuffer, $ibuffer)
		_memfree($tmemmap)
	EndIf
	Return DllStructGetData($tbuffer, "Text")
EndFunc

Func _guictrlstatusbar_gettextflags($hwnd, $ipart)
	If _guictrlstatusbar_getunicodeformat($hwnd) Then
		Return _sendmessage($hwnd, $sb_gettextlengthw, $ipart)
	Else
		Return _sendmessage($hwnd, $sb_gettextlength, $ipart)
	EndIf
EndFunc

Func _guictrlstatusbar_gettextlength($hwnd, $ipart)
	Return _winapi_loword(_guictrlstatusbar_gettextflags($hwnd, $ipart))
EndFunc

Func _guictrlstatusbar_gettextlengthex($hwnd, $ipart)
	Return _winapi_hiword(_guictrlstatusbar_gettextflags($hwnd, $ipart))
EndFunc

Func _guictrlstatusbar_gettiptext($hwnd, $ipart)
	Local $bunicode = _guictrlstatusbar_getunicodeformat($hwnd)
	Local $tbuffer
	If $bunicode Then
		$tbuffer = DllStructCreate("wchar Text[4096]")
	Else
		$tbuffer = DllStructCreate("char Text[4096]")
	EndIf
	If _winapi_inprocess($hwnd, $__g_hsblastwnd) Then
		_sendmessage($hwnd, $sb_gettiptextw, _winapi_makelong($ipart, 4096), $tbuffer, 0, "wparam", "struct*")
	Else
		Local $tmemmap
		Local $pmemory = _meminit($hwnd, 4096, $tmemmap)
		If $bunicode Then
			_sendmessage($hwnd, $sb_gettiptextw, _winapi_makelong($ipart, 4096), $pmemory, 0, "wparam", "ptr")
		Else
			_sendmessage($hwnd, $sb_gettiptexta, _winapi_makelong($ipart, 4096), $pmemory, 0, "wparam", "ptr")
		EndIf
		_memread($tmemmap, $pmemory, $tbuffer, 4096)
		_memfree($tmemmap)
	EndIf
	Return DllStructGetData($tbuffer, "Text")
EndFunc

Func _guictrlstatusbar_getunicodeformat($hwnd)
	Return _sendmessage($hwnd, $sb_getunicodeformat) <> 0
EndFunc

Func _guictrlstatusbar_getwidth($hwnd, $ipart)
	Local $trect = _guictrlstatusbar_getrectex($hwnd, $ipart)
	Return DllStructGetData($trect, "Right") - DllStructGetData($trect, "Left") - (_guictrlstatusbar_getbordershorz($hwnd) * 2)
EndFunc

Func _guictrlstatusbar_issimple($hwnd)
	Return _sendmessage($hwnd, $sb_issimple) <> 0
EndFunc

Func _guictrlstatusbar_resize($hwnd)
	_sendmessage($hwnd, $__statusbarconstant_wm_size)
EndFunc

Func _guictrlstatusbar_setbkcolor($hwnd, $icolor)
	$icolor = _sendmessage($hwnd, $sb_setbkcolor, 0, $icolor)
	If $icolor = $__statusbarconstant_clr_default Then Return "0x" & Hex($__statusbarconstant_clr_default)
	Return $icolor
EndFunc

Func _guictrlstatusbar_seticon($hwnd, $ipart, $hicon = -1, $siconfile = "")
	If $hicon = -1 Then Return _sendmessage($hwnd, $sb_seticon, $ipart, $hicon, 0, "wparam", "handle") <> 0
	If StringLen($siconfile) <= 0 Then Return _sendmessage($hwnd, $sb_seticon, $ipart, $hicon) <> 0
	Local $ticon = DllStructCreate("handle")
	Local $vresult = DllCall("shell32.dll", "uint", "ExtractIconExW", "wstr", $siconfile, "int", $hicon, "ptr", 0, "struct*", $ticon, "uint", 1)
	If @error Then Return SetError(@error, @extended, False)
	$vresult = $vresult[0]
	If $vresult > 0 Then $vresult = _sendmessage($hwnd, $sb_seticon, $ipart, DllStructGetData($ticon, 1), 0, "wparam", "handle")
	DllCall("user32.dll", "bool", "DestroyIcon", "handle", DllStructGetData($ticon, 1))
	Return $vresult
EndFunc

Func _guictrlstatusbar_setminheight($hwnd, $iminheight)
	_sendmessage($hwnd, $sb_setminheight, $iminheight)
	_guictrlstatusbar_resize($hwnd)
EndFunc

Func _guictrlstatusbar_setparts($hwnd, $aparts = -1, $apartwidth = 25)
	Local $tparts, $iparts = 1
	If IsArray($aparts) <> 0 Then
		$aparts[UBound($aparts) - 1] = -1
		$iparts = UBound($aparts)
		$tparts = DllStructCreate("int[" & $iparts & "]")
		For $x = 0 To $iparts - 2
			DllStructSetData($tparts, 1, $aparts[$x], $x + 1)
		Next
		DllStructSetData($tparts, 1, -1, $iparts)
	ElseIf IsArray($apartwidth) <> 0 Then
		$iparts = UBound($apartwidth)
		$tparts = DllStructCreate("int[" & $iparts & "]")
		For $x = 0 To $iparts - 2
			DllStructSetData($tparts, 1, $apartwidth[$x], $x + 1)
		Next
		DllStructSetData($tparts, 1, -1, $iparts)
	ElseIf $aparts > 1 Then
		$iparts = $aparts
		$tparts = DllStructCreate("int[" & $iparts & "]")
		For $x = 1 To $iparts - 1
			DllStructSetData($tparts, 1, $apartwidth * $x, $x)
		Next
		DllStructSetData($tparts, 1, -1, $iparts)
	Else
		$tparts = DllStructCreate("int")
		DllStructSetData($tparts, $iparts, -1)
	EndIf
	If _winapi_inprocess($hwnd, $__g_hsblastwnd) Then
		_sendmessage($hwnd, $sb_setparts, $iparts, $tparts, 0, "wparam", "struct*")
	Else
		Local $isize = DllStructGetSize($tparts)
		Local $tmemmap
		Local $pmemory = _meminit($hwnd, $isize, $tmemmap)
		_memwrite($tmemmap, $tparts)
		_sendmessage($hwnd, $sb_setparts, $iparts, $pmemory, 0, "wparam", "ptr")
		_memfree($tmemmap)
	EndIf
	_guictrlstatusbar_resize($hwnd)
	Return True
EndFunc

Func _guictrlstatusbar_setsimple($hwnd, $bsimple = True)
	_sendmessage($hwnd, $sb_simple, $bsimple)
EndFunc

Func _guictrlstatusbar_settext($hwnd, $stext = "", $ipart = 0, $iuflag = 0)
	Local $bunicode = _guictrlstatusbar_getunicodeformat($hwnd)
	Local $ibuffer = StringLen($stext) + 1
	Local $ttext
	If $bunicode Then
		$ttext = DllStructCreate("wchar Text[" & $ibuffer & "]")
		$ibuffer *= 2
	Else
		$ttext = DllStructCreate("char Text[" & $ibuffer & "]")
	EndIf
	DllStructSetData($ttext, "Text", $stext)
	If _guictrlstatusbar_issimple($hwnd) Then $ipart = $sb_simpleid
	Local $iret
	If _winapi_inprocess($hwnd, $__g_hsblastwnd) Then
		$iret = _sendmessage($hwnd, $sb_settextw, BitOR($ipart, $iuflag), $ttext, 0, "wparam", "struct*")
	Else
		Local $tmemmap
		Local $pmemory = _meminit($hwnd, $ibuffer, $tmemmap)
		_memwrite($tmemmap, $ttext)
		If $bunicode Then
			$iret = _sendmessage($hwnd, $sb_settextw, BitOR($ipart, $iuflag), $pmemory, 0, "wparam", "ptr")
		Else
			$iret = _sendmessage($hwnd, $sb_settext, BitOR($ipart, $iuflag), $pmemory, 0, "wparam", "ptr")
		EndIf
		_memfree($tmemmap)
	EndIf
	Return $iret <> 0
EndFunc

Func _guictrlstatusbar_settiptext($hwnd, $ipart, $stext)
	Local $bunicode = _guictrlstatusbar_getunicodeformat($hwnd)
	Local $ibuffer = StringLen($stext) + 1
	Local $ttext
	If $bunicode Then
		$ttext = DllStructCreate("wchar TipText[" & $ibuffer & "]")
		$ibuffer *= 2
	Else
		$ttext = DllStructCreate("char TipText[" & $ibuffer & "]")
	EndIf
	DllStructSetData($ttext, "TipText", $stext)
	If _winapi_inprocess($hwnd, $__g_hsblastwnd) Then
		_sendmessage($hwnd, $sb_settiptextw, $ipart, $ttext, 0, "wparam", "struct*")
	Else
		Local $tmemmap
		Local $pmemory = _meminit($hwnd, $ibuffer, $tmemmap)
		_memwrite($tmemmap, $ttext, $pmemory, $ibuffer)
		If $bunicode Then
			_sendmessage($hwnd, $sb_settiptextw, $ipart, $pmemory, 0, "wparam", "ptr")
		Else
			_sendmessage($hwnd, $sb_settiptexta, $ipart, $pmemory, 0, "wparam", "ptr")
		EndIf
		_memfree($tmemmap)
	EndIf
EndFunc

Func _guictrlstatusbar_setunicodeformat($hwnd, $bunicode = True)
	Return _sendmessage($hwnd, $sb_setunicodeformat, $bunicode)
EndFunc

Func _guictrlstatusbar_showhide($hwnd, $istate)
	If $istate <> @SW_HIDE AND $istate <> @SW_SHOW Then Return SetError(1, 1, False)
	Return _winapi_showwindow($hwnd, $istate)
EndFunc

Global Const $ttf_idishwnd = 1
Global Const $ttf_centertip = 2
Global Const $ttf_rtlreading = 4
Global Const $ttf_subclass = 16
Global Const $ttf_track = 32
Global Const $ttf_absolute = 128
Global Const $ttf_transparent = 256
Global Const $ttf_parselinks = 4096
Global Const $ttf_di_setitem = 32768
Global Const $__tooltipconstants_wm_user = 1024
Global Const $ttm_activate = $__tooltipconstants_wm_user + 1
Global Const $ttm_setdelaytime = $__tooltipconstants_wm_user + 3
Global Const $ttm_addtool = $__tooltipconstants_wm_user + 4
Global Const $ttm_deltool = $__tooltipconstants_wm_user + 5
Global Const $ttm_newtoolrect = $__tooltipconstants_wm_user + 6
Global Const $ttm_gettoolinfo = $__tooltipconstants_wm_user + 8
Global Const $ttm_settoolinfo = $__tooltipconstants_wm_user + 9
Global Const $ttm_hittest = $__tooltipconstants_wm_user + 10
Global Const $ttm_gettext = $__tooltipconstants_wm_user + 11
Global Const $ttm_updatetiptext = $__tooltipconstants_wm_user + 12
Global Const $ttm_gettoolcount = $__tooltipconstants_wm_user + 13
Global Const $ttm_enumtools = $__tooltipconstants_wm_user + 14
Global Const $ttm_getcurrenttool = $__tooltipconstants_wm_user + 15
Global Const $ttm_windowfrompoint = $__tooltipconstants_wm_user + 16
Global Const $ttm_trackactivate = $__tooltipconstants_wm_user + 17
Global Const $ttm_trackposition = $__tooltipconstants_wm_user + 18
Global Const $ttm_settipbkcolor = $__tooltipconstants_wm_user + 19
Global Const $ttm_settiptextcolor = $__tooltipconstants_wm_user + 20
Global Const $ttm_getdelaytime = $__tooltipconstants_wm_user + 21
Global Const $ttm_gettipbkcolor = $__tooltipconstants_wm_user + 22
Global Const $ttm_gettiptextcolor = $__tooltipconstants_wm_user + 23
Global Const $ttm_setmaxtipwidth = $__tooltipconstants_wm_user + 24
Global Const $ttm_getmaxtipwidth = $__tooltipconstants_wm_user + 25
Global Const $ttm_setmargin = $__tooltipconstants_wm_user + 26
Global Const $ttm_getmargin = $__tooltipconstants_wm_user + 27
Global Const $ttm_pop = $__tooltipconstants_wm_user + 28
Global Const $ttm_update = $__tooltipconstants_wm_user + 29
Global Const $ttm_getbubblesize = $__tooltipconstants_wm_user + 30
Global Const $ttm_adjustrect = $__tooltipconstants_wm_user + 31
Global Const $ttm_settitle = $__tooltipconstants_wm_user + 32
Global Const $ttm_settitlew = $__tooltipconstants_wm_user + 33
Global Const $ttm_popup = $__tooltipconstants_wm_user + 34
Global Const $ttm_gettitle = $__tooltipconstants_wm_user + 35
Global Const $ttm_addtoolw = $__tooltipconstants_wm_user + 50
Global Const $ttm_deltoolw = $__tooltipconstants_wm_user + 51
Global Const $ttm_newtoolrectw = $__tooltipconstants_wm_user + 52
Global Const $ttm_gettoolinfow = $__tooltipconstants_wm_user + 53
Global Const $ttm_settoolinfow = $__tooltipconstants_wm_user + 54
Global Const $ttm_hittestw = $__tooltipconstants_wm_user + 55
Global Const $ttm_gettextw = $__tooltipconstants_wm_user + 56
Global Const $ttm_updatetiptextw = $__tooltipconstants_wm_user + 57
Global Const $ttm_enumtoolsw = $__tooltipconstants_wm_user + 58
Global Const $ttm_getcurrenttoolw = $__tooltipconstants_wm_user + 59
Global Const $ttm_setwindowtheme = 8192 + 11
Global Const $ttn_first = -520
Global Const $ttn_getdispinfo = $ttn_first + 0
Global Const $ttn_show = $ttn_first - 1
Global Const $ttn_pop = $ttn_first - 2
Global Const $ttn_linkclick = $ttn_first - 3
Global Const $ttn_getdispinfow = $ttn_first - 10
Global Const $tts_alwaystip = 1
Global Const $tts_noprefix = 2
Global Const $tts_noanimate = 16
Global Const $tts_nofade = 32
Global Const $tts_balloon = 64
Global Const $tts_close = 128
Global Const $tts_usevisualstyle = 256
Global Const $ttdt_automatic = 0
Global Const $ttdt_reshow = 1
Global Const $ttdt_autopop = 2
Global Const $ttdt_initial = 3
Global Enum $tti_none, $tti_info, $tti_warning, $tti_error, $tti_info_large, $tti_warning_large, $tti_error_large
Global $__g_heditlastwnd
Global Const $__editconstant_classname = "Edit"
Global Const $__editconstant_gui_checked = 1
Global Const $__editconstant_gui_hide = 32
Global Const $__editconstant_gui_event_close = -3
Global Const $__editconstant_gui_enable = 64
Global Const $__editconstant_gui_disable = 128
Global Const $__editconstant_ss_center = 1
Global Const $__editconstant_wm_setredraw = 11
Global Const $__editconstant_ws_caption = 12582912
Global Const $__editconstant_ws_popup = -2147483648
Global Const $__editconstant_ws_sysmenu = 524288
Global Const $__editconstant_ws_minimizebox = 131072
Global Const $__editconstant_default_gui_font = 17
Global Const $__editconstant_wm_setfont = 48
Global Const $__editconstant_wm_gettextlength = 14
Global Const $__editconstant_wm_gettext = 13
Global Const $__editconstant_wm_settext = 12
Global Const $__editconstant_sb_lineup = 0
Global Const $__editconstant_sb_linedown = 1
Global Const $__editconstant_sb_pagedown = 3
Global Const $__editconstant_sb_pageup = 2
Global Const $__editconstant_sb_scrollcaret = 4
Global Const $__tageditballoontip = "dword Size;ptr Title;ptr Text;int Icon"

Func _guictrledit_appendtext($hwnd, $stext)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Local $ilength = _guictrledit_gettextlen($hwnd)
	_guictrledit_setsel($hwnd, $ilength, $ilength)
	_sendmessage($hwnd, $em_replacesel, True, $stext, 0, "wparam", "wstr")
EndFunc

Func _guictrledit_beginupdate($hwnd)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Return _sendmessage($hwnd, $__editconstant_wm_setredraw, False) = 0
EndFunc

Func _guictrledit_canundo($hwnd)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Return _sendmessage($hwnd, $em_canundo) <> 0
EndFunc

Func _guictrledit_charfrompos($hwnd, $ix, $iy)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Local $areturn[2]
	Local $iret = _sendmessage($hwnd, $em_charfrompos, 0, _winapi_makelong($ix, $iy))
	$areturn[0] = _winapi_loword($iret)
	$areturn[1] = _winapi_hiword($iret)
	Return $areturn
EndFunc

Func _guictrledit_create($hwnd, $stext, $ix, $iy, $iwidth = 150, $iheight = 150, $istyle = 3150020, $iexstyle = 512)
	If NOT IsHWnd($hwnd) Then Return SetError(1, 0, 0)
	If NOT IsString($stext) Then Return SetError(2, 0, 0)
	If $iwidth = -1 Then $iwidth = 150
	If $iheight = -1 Then $iheight = 150
	If $istyle = -1 Then $istyle = 3150020
	If $iexstyle = -1 Then $iexstyle = 512
	If BitAND($istyle, $es_readonly) = $es_readonly Then
		$istyle = BitOR($__udfguiconstant_ws_child, $__udfguiconstant_ws_visible, $istyle)
	Else
		$istyle = BitOR($__udfguiconstant_ws_child, $__udfguiconstant_ws_visible, $__udfguiconstant_ws_tabstop, $istyle)
	EndIf
	Local $nctrlid = __udf_getnextglobalid($hwnd)
	If @error Then Return SetError(@error, @extended, 0)
	Local $hedit = _winapi_createwindowex($iexstyle, $__editconstant_classname, "", $istyle, $ix, $iy, $iwidth, $iheight, $hwnd, $nctrlid)
	_sendmessage($hedit, $__editconstant_wm_setfont, _winapi_getstockobject($__editconstant_default_gui_font), True)
	_guictrledit_settext($hedit, $stext)
	_guictrledit_setlimittext($hedit, 0)
	Return $hedit
EndFunc

Func _guictrledit_destroy(ByRef $hwnd)
	If NOT _winapi_isclassname($hwnd, $__editconstant_classname) Then Return SetError(2, 2, False)
	Local $idestroyed = 0
	If IsHWnd($hwnd) Then
		If _winapi_inprocess($hwnd, $__g_heditlastwnd) Then
			Local $nctrlid = _winapi_getdlgctrlid($hwnd)
			Local $hparent = _winapi_getparent($hwnd)
			$idestroyed = _winapi_destroywindow($hwnd)
			Local $iret = __udf_freeglobalid($hparent, $nctrlid)
			If NOT $iret Then
			EndIf
		Else
			Return SetError(1, 1, False)
		EndIf
	Else
		$idestroyed = GUICtrlDelete($hwnd)
	EndIf
	If $idestroyed Then $hwnd = 0
	Return $idestroyed <> 0
EndFunc

Func _guictrledit_emptyundobuffer($hwnd)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	_sendmessage($hwnd, $em_emptyundobuffer)
EndFunc

Func _guictrledit_endupdate($hwnd)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Return _sendmessage($hwnd, $__editconstant_wm_setredraw, True) = 0
EndFunc

Func _guictrledit_fmtlines($hwnd, $bsoftbreak = False)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Return _sendmessage($hwnd, $em_fmtlines, $bsoftbreak)
EndFunc

Func _guictrledit_find($hwnd, $breplace = False)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Local $ipos = 0, $icase, $ioccurance = 0, $ireplacements = 0
	Local $apartsrightedge[3] = [125, 225, -1]
	Local $ioldmode = Opt("GUIOnEventMode", 0)
	Local $asel = _guictrledit_getsel($hwnd)
	Local $stext = _guictrledit_gettext($hwnd)
	Local $hguisearch = GUICreate("Find", 349, 177, -1, -1, BitOR($__udfguiconstant_ws_child, $__editconstant_ws_minimizebox, $__editconstant_ws_caption, $__editconstant_ws_popup, $__editconstant_ws_sysmenu))
	Local $idstatusbar1 = _guictrlstatusbar_create($hguisearch, $apartsrightedge)
	_guictrlstatusbar_settext($idstatusbar1, "Find: ")
	GUISetIcon(@SystemDir & "\shell32.dll", 22, $hguisearch)
	GUICtrlCreateLabel("Find what:", 9, 10, 53, 16, $__editconstant_ss_center)
	Local $idinputsearch = GUICtrlCreateInput("", 80, 8, 257, 21)
	Local $idlblreplace = GUICtrlCreateLabel("Replace with:", 9, 42, 69, 17, $__editconstant_ss_center)
	Local $idinputreplace = GUICtrlCreateInput("", 80, 40, 257, 21)
	Local $idchkwholeonly = GUICtrlCreateCheckbox("Match whole word only", 9, 72, 145, 17)
	Local $idchkmatchcase = GUICtrlCreateCheckbox("Match case", 9, 96, 145, 17)
	Local $idbtnfindnext = GUICtrlCreateButton("Find Next", 168, 72, 161, 21, 0)
	Local $idbtnreplace = GUICtrlCreateButton("Replace", 168, 96, 161, 21, 0)
	Local $idbtnclose = GUICtrlCreateButton("Close", 104, 130, 161, 21, 0)
	If (IsArray($asel) AND $asel <> $ec_err) Then
		GUICtrlSetData($idinputsearch, StringMid($stext, $asel[0] + 1, $asel[1] - $asel[0]))
		If $asel[0] <> $asel[1] Then
			$ipos = $asel[0]
			If BitAND(GUICtrlRead($idchkmatchcase), $__editconstant_gui_checked) = $__editconstant_gui_checked Then $icase = 1
			$ioccurance = 1
			Local $itpose
			While 1
				$itpose = StringInStr($stext, GUICtrlRead($idinputsearch), $icase, $ioccurance)
				If NOT $itpose Then
					$ioccurance = 0
					ExitLoop
				ElseIf $itpose = $ipos + 1 Then
					ExitLoop
				EndIf
				$ioccurance += 1
			WEnd
		EndIf
		_guictrlstatusbar_settext($idstatusbar1, "Find: " & GUICtrlRead($idinputsearch))
	EndIf
	If $breplace = False Then
		GUICtrlSetState($idlblreplace, $__editconstant_gui_hide)
		GUICtrlSetState($idinputreplace, $__editconstant_gui_hide)
		GUICtrlSetState($idbtnreplace, $__editconstant_gui_hide)
	Else
		_guictrlstatusbar_settext($idstatusbar1, "Replacements: " & $ireplacements, 1)
		_guictrlstatusbar_settext($idstatusbar1, "With: ", 2)
	EndIf
	GUISetState(@SW_SHOW)
	Local $imsgfind
	While 1
		$imsgfind = GUIGetMsg()
		Select
			Case $imsgfind = $__editconstant_gui_event_close OR $imsgfind = $idbtnclose
				ExitLoop
			Case $imsgfind = $idbtnfindnext
				GUICtrlSetState($idbtnfindnext, $__editconstant_gui_disable)
				GUICtrlSetCursor($idbtnfindnext, 15)
				Sleep(100)
				_guictrlstatusbar_settext($idstatusbar1, "Find: " & GUICtrlRead($idinputsearch))
				If $breplace = True Then
					_guictrlstatusbar_settext($idstatusbar1, "Find: " & GUICtrlRead($idinputsearch))
					_guictrlstatusbar_settext($idstatusbar1, "With: " & GUICtrlRead($idinputreplace), 2)
				EndIf
				__guictrledit_findtext($hwnd, $idinputsearch, $idchkmatchcase, $idchkwholeonly, $ipos, $ioccurance, $ireplacements)
				Sleep(100)
				GUICtrlSetState($idbtnfindnext, $__editconstant_gui_enable)
				GUICtrlSetCursor($idbtnfindnext, 2)
			Case $imsgfind = $idbtnreplace
				GUICtrlSetState($idbtnreplace, $__editconstant_gui_disable)
				GUICtrlSetCursor($idbtnreplace, 15)
				Sleep(100)
				_guictrlstatusbar_settext($idstatusbar1, "Find: " & GUICtrlRead($idinputsearch))
				_guictrlstatusbar_settext($idstatusbar1, "With: " & GUICtrlRead($idinputreplace), 2)
				If $ipos Then
					_guictrledit_replacesel($hwnd, GUICtrlRead($idinputreplace))
					$ireplacements += 1
					$ioccurance -= 1
					_guictrlstatusbar_settext($idstatusbar1, "Replacements: " & $ireplacements, 1)
				EndIf
				__guictrledit_findtext($hwnd, $idinputsearch, $idchkmatchcase, $idchkwholeonly, $ipos, $ioccurance, $ireplacements)
				Sleep(100)
				GUICtrlSetState($idbtnreplace, $__editconstant_gui_enable)
				GUICtrlSetCursor($idbtnreplace, 2)
		EndSelect
	WEnd
	GUIDelete($hguisearch)
	Opt("GUIOnEventMode", $ioldmode)
EndFunc

Func _guictrledit_getcuebanner($hwnd)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Local $ttext = DllStructCreate("wchar[4096]")
	If _sendmessage($hwnd, $em_getcuebanner, $ttext, 4096, 0, "struct*") <> 1 Then Return SetError(-1, 0, "")
	Return _winapi_widechartomultibyte($ttext)
EndFunc

Func __guictrledit_findtext($hwnd, $idinputsearch, $idchkmatchcase, $idchkwholeonly, ByRef $ipos, ByRef $ioccurance, ByRef $ireplacements)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Local $icase = 0, $iwhole = 0
	Local $bexact = False
	Local $sfind = GUICtrlRead($idinputsearch)
	Local $stext = _guictrledit_gettext($hwnd)
	If BitAND(GUICtrlRead($idchkmatchcase), $__editconstant_gui_checked) = $__editconstant_gui_checked Then $icase = 1
	If BitAND(GUICtrlRead($idchkwholeonly), $__editconstant_gui_checked) = $__editconstant_gui_checked Then $iwhole = 1
	If $sfind <> "" Then
		$ioccurance += 1
		$ipos = StringInStr($stext, $sfind, $icase, $ioccurance)
		If $iwhole AND $ipos Then
			Local $s_compare2 = StringMid($stext, $ipos + StringLen($sfind), 1)
			If $ipos = 1 Then
				If ($ipos + StringLen($sfind)) - 1 = StringLen($stext) OR ($s_compare2 = " " OR $s_compare2 = @LF OR $s_compare2 = @CR OR $s_compare2 = @CRLF OR $s_compare2 = @TAB) Then $bexact = True
			Else
				Local $s_compare1 = StringMid($stext, $ipos - 1, 1)
				If ($ipos + StringLen($sfind)) - 1 = StringLen($stext) Then
					If ($s_compare1 = " " OR $s_compare1 = @LF OR $s_compare1 = @CR OR $s_compare1 = @CRLF OR $s_compare1 = @TAB) Then $bexact = True
				Else
					If ($s_compare1 = " " OR $s_compare1 = @LF OR $s_compare1 = @CR OR $s_compare1 = @CRLF OR $s_compare1 = @TAB) AND ($s_compare2 = " " OR $s_compare2 = @LF OR $s_compare2 = @CR OR $s_compare2 = @CRLF OR $s_compare2 = @TAB) Then $bexact = True
				EndIf
			EndIf
			If $bexact = False Then
				__guictrledit_findtext($hwnd, $idinputsearch, $idchkmatchcase, $idchkwholeonly, $ipos, $ioccurance, $ireplacements)
			Else
				_guictrledit_setsel($hwnd, $ipos - 1, ($ipos + StringLen($sfind)) - 1)
				_guictrledit_scroll($hwnd, $__editconstant_sb_scrollcaret)
			EndIf
		ElseIf $iwhole AND NOT $ipos Then
			$ioccurance = 0
			MsgBox($mb_systemmodal, "Find", "Reached End of document, Can not find the string '" & $sfind & "'")
		ElseIf NOT $iwhole Then
			If NOT $ipos Then
				$ioccurance = 1
				_guictrledit_setsel($hwnd, -1, 0)
				_guictrledit_scroll($hwnd, $__editconstant_sb_scrollcaret)
				$ipos = StringInStr($stext, $sfind, $icase, $ioccurance)
				If NOT $ipos Then
					$ioccurance = 0
					MsgBox($mb_systemmodal, "Find", "Reached End of document, Can not find the string  '" & $sfind & "'")
				Else
					_guictrledit_setsel($hwnd, $ipos - 1, ($ipos + StringLen($sfind)) - 1)
					_guictrledit_scroll($hwnd, $__editconstant_sb_scrollcaret)
				EndIf
			Else
				_guictrledit_setsel($hwnd, $ipos - 1, ($ipos + StringLen($sfind)) - 1)
				_guictrledit_scroll($hwnd, $__editconstant_sb_scrollcaret)
			EndIf
		EndIf
	EndIf
EndFunc

Func _guictrledit_getfirstvisibleline($hwnd)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Return _sendmessage($hwnd, $em_getfirstvisibleline)
EndFunc

Func _guictrledit_gethandle($hwnd)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Return Ptr(_sendmessage($hwnd, $em_gethandle))
EndFunc

Func _guictrledit_getimestatus($hwnd)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Return _sendmessage($hwnd, $em_getimestatus, $emsis_compositionstring)
EndFunc

Func _guictrledit_getlimittext($hwnd)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Return _sendmessage($hwnd, $em_getlimittext)
EndFunc

Func _guictrledit_getline($hwnd, $iline)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Local $ilength = _guictrledit_linelength($hwnd, $iline)
	If $ilength = 0 Then Return ""
	Local $tbuffer = DllStructCreate("short Len;wchar Text[" & $ilength & "]")
	DllStructSetData($tbuffer, "Len", $ilength + 1)
	Local $iret = _sendmessage($hwnd, $em_getline, $iline, $tbuffer, 0, "wparam", "struct*")
	If $iret = 0 Then Return SetError($ec_err, $ec_err, "")
	Local $ttext = DllStructCreate("wchar Text[" & $ilength & "]", DllStructGetPtr($tbuffer))
	Return DllStructGetData($ttext, "Text")
EndFunc

Func _guictrledit_getlinecount($hwnd)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Return _sendmessage($hwnd, $em_getlinecount)
EndFunc

Func _guictrledit_getmargins($hwnd)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Local $amargins[2]
	Local $imargins = _sendmessage($hwnd, $em_getmargins)
	$amargins[0] = _winapi_loword($imargins)
	$amargins[1] = _winapi_hiword($imargins)
	Return $amargins
EndFunc

Func _guictrledit_getmodify($hwnd)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Return _sendmessage($hwnd, $em_getmodify) <> 0
EndFunc

Func _guictrledit_getpasswordchar($hwnd)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Return _sendmessage($hwnd, $em_getpasswordchar)
EndFunc

Func _guictrledit_getrect($hwnd)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Local $arect[4]
	Local $trect = _guictrledit_getrectex($hwnd)
	$arect[0] = DllStructGetData($trect, "Left")
	$arect[1] = DllStructGetData($trect, "Top")
	$arect[2] = DllStructGetData($trect, "Right")
	$arect[3] = DllStructGetData($trect, "Bottom")
	Return $arect
EndFunc

Func _guictrledit_getrectex($hwnd)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Local $trect = DllStructCreate($tagrect)
	_sendmessage($hwnd, $em_getrect, 0, $trect, 0, "wparam", "struct*")
	Return $trect
EndFunc

Func _guictrledit_getsel($hwnd)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Local $asel[2]
	Local $tstart = DllStructCreate("uint Start")
	Local $tend = DllStructCreate("uint End")
	_sendmessage($hwnd, $em_getsel, $tstart, $tend, 0, "struct*", "struct*")
	$asel[0] = DllStructGetData($tstart, "Start")
	$asel[1] = DllStructGetData($tend, "End")
	Return $asel
EndFunc

Func _guictrledit_gettext($hwnd)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Local $itextlen = _guictrledit_gettextlen($hwnd) + 1
	Local $ttext = DllStructCreate("wchar Text[" & $itextlen & "]")
	_sendmessage($hwnd, $__editconstant_wm_gettext, $itextlen, $ttext, 0, "wparam", "struct*")
	Return DllStructGetData($ttext, "Text")
EndFunc

Func _guictrledit_gettextlen($hwnd)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Return _sendmessage($hwnd, $__editconstant_wm_gettextlength)
EndFunc

Func _guictrledit_getthumb($hwnd)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Return _sendmessage($hwnd, $em_getthumb)
EndFunc

Func _guictrledit_getwordbreakproc($hwnd)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Return _sendmessage($hwnd, $em_getwordbreakproc)
EndFunc

Func _guictrledit_hideballoontip($hwnd)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Return _sendmessage($hwnd, $em_hideballoontip) <> 0
EndFunc

Func _guictrledit_inserttext($hwnd, $stext, $iindex = -1)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	If $iindex = -1 Then
		_guictrledit_appendtext($hwnd, $stext)
	Else
		_guictrledit_setsel($hwnd, $iindex, $iindex)
		_sendmessage($hwnd, $em_replacesel, True, $stext, 0, "wparam", "wstr")
	EndIf
EndFunc

Func _guictrledit_linefromchar($hwnd, $iindex = -1)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Return _sendmessage($hwnd, $em_linefromchar, $iindex)
EndFunc

Func _guictrledit_lineindex($hwnd, $iindex = -1)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Return _sendmessage($hwnd, $em_lineindex, $iindex)
EndFunc

Func _guictrledit_linelength($hwnd, $iindex = -1)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Local $icharindex = _guictrledit_lineindex($hwnd, $iindex)
	Return _sendmessage($hwnd, $em_linelength, $icharindex)
EndFunc

Func _guictrledit_linescroll($hwnd, $ihoriz, $ivert)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Return _sendmessage($hwnd, $em_linescroll, $ihoriz, $ivert) <> 0
EndFunc

Func _guictrledit_posfromchar($hwnd, $iindex)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Local $acoord[2]
	Local $iret = _sendmessage($hwnd, $em_posfromchar, $iindex)
	$acoord[0] = _winapi_loword($iret)
	$acoord[1] = _winapi_hiword($iret)
	Return $acoord
EndFunc

Func _guictrledit_replacesel($hwnd, $stext, $bundo = True)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	_sendmessage($hwnd, $em_replacesel, $bundo, $stext, 0, "wparam", "wstr")
EndFunc

Func _guictrledit_scroll($hwnd, $idirection)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	If BitAND($idirection, $__editconstant_sb_linedown) <> $__editconstant_sb_linedown AND BitAND($idirection, $__editconstant_sb_lineup) <> $__editconstant_sb_lineup AND BitAND($idirection, $__editconstant_sb_pagedown) <> $__editconstant_sb_pagedown AND BitAND($idirection, $__editconstant_sb_pageup) <> $__editconstant_sb_pageup AND BitAND($idirection, $__editconstant_sb_scrollcaret) <> $__editconstant_sb_scrollcaret Then Return 0
	If $idirection == $__editconstant_sb_scrollcaret Then
		Return _sendmessage($hwnd, $em_scrollcaret)
	Else
		Return _sendmessage($hwnd, $em_scroll, $idirection)
	EndIf
EndFunc

Func _guictrledit_setcuebanner($hwnd, $stext, $bonfocus = False)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Local $ttext = _winapi_multibytetowidechar($stext)
	Return _sendmessage($hwnd, $em_setcuebanner, $bonfocus, $ttext, 0, "wparam", "struct*") = 1
EndFunc

Func _guictrledit_sethandle($hwnd, $hmemory)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	_sendmessage($hwnd, $em_sethandle, $hmemory, 0, 0, "handle")
EndFunc

Func _guictrledit_setimestatus($hwnd, $icomposition)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Return _sendmessage($hwnd, $em_setimestatus, $emsis_compositionstring, $icomposition)
EndFunc

Func _guictrledit_setlimittext($hwnd, $ilimit)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	_sendmessage($hwnd, $em_setlimittext, $ilimit)
EndFunc

Func _guictrledit_setmargins($hwnd, $imargin = 1, $ileft = 65535, $iright = 65535)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	_sendmessage($hwnd, $em_setmargins, $imargin, _winapi_makelong($ileft, $iright))
EndFunc

Func _guictrledit_setmodify($hwnd, $bmodified)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	_sendmessage($hwnd, $em_setmodify, $bmodified)
EndFunc

Func _guictrledit_setpasswordchar($hwnd, $sdisplaychar = "0")
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	$sdisplaychar = StringLeft($sdisplaychar, 1)
	If Asc($sdisplaychar) = 48 Then
		_sendmessage($hwnd, $em_setpasswordchar)
	Else
		_sendmessage($hwnd, $em_setpasswordchar, Asc($sdisplaychar))
	EndIf
EndFunc

Func _guictrledit_setreadonly($hwnd, $breadonly)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Return _sendmessage($hwnd, $em_setreadonly, $breadonly) <> 0
EndFunc

Func _guictrledit_setrect($hwnd, $arect)
	Local $trect = DllStructCreate($tagrect)
	DllStructSetData($trect, "Left", $arect[0])
	DllStructSetData($trect, "Top", $arect[1])
	DllStructSetData($trect, "Right", $arect[2])
	DllStructSetData($trect, "Bottom", $arect[3])
	_guictrledit_setrectex($hwnd, $trect)
EndFunc

Func _guictrledit_setrectex($hwnd, $trect)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	_sendmessage($hwnd, $em_setrect, 0, $trect, 0, "wparam", "struct*")
EndFunc

Func _guictrledit_setrectnp($hwnd, $arect)
	Local $trect = DllStructCreate($tagrect)
	DllStructSetData($trect, "Left", $arect[0])
	DllStructSetData($trect, "Top", $arect[1])
	DllStructSetData($trect, "Right", $arect[2])
	DllStructSetData($trect, "Bottom", $arect[3])
	_guictrledit_setrectnpex($hwnd, $trect)
EndFunc

Func _guictrledit_setrectnpex($hwnd, $trect)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	_sendmessage($hwnd, $em_setrectnp, 0, $trect, 0, "wparam", "struct*")
EndFunc

Func _guictrledit_setsel($hwnd, $istart, $iend)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	_sendmessage($hwnd, $em_setsel, $istart, $iend)
EndFunc

Func _guictrledit_settabstops($hwnd, $atabstops)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	If NOT IsArray($atabstops) Then Return SetError(-1, -1, False)
	Local $stabstops = ""
	Local $inumtabstops = UBound($atabstops)
	For $x = 0 To $inumtabstops - 1
		$stabstops &= "int;"
	Next
	$stabstops = StringTrimRight($stabstops, 1)
	Local $ttabstops = DllStructCreate($stabstops)
	For $x = 0 To $inumtabstops - 1
		DllStructSetData($ttabstops, $x + 1, $atabstops[$x])
	Next
	Local $iret = _sendmessage($hwnd, $em_settabstops, $inumtabstops, $ttabstops, 0, "wparam", "struct*") <> 0
	_winapi_invalidaterect($hwnd)
	Return $iret
EndFunc

Func _guictrledit_settext($hwnd, $stext)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	_sendmessage($hwnd, $__editconstant_wm_settext, 0, $stext, 0, "wparam", "wstr")
EndFunc

Func _guictrledit_setwordbreakproc($hwnd, $iaddressfunc)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	_sendmessage($hwnd, $em_setwordbreakproc, 0, $iaddressfunc)
EndFunc

Func _guictrledit_showballoontip($hwnd, $stitle, $stext, $iicon)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Local $ttitle = _winapi_multibytetowidechar($stitle)
	Local $ttext = _winapi_multibytetowidechar($stext)
	Local $ttt = DllStructCreate($__tageditballoontip)
	DllStructSetData($ttt, "Size", DllStructGetSize($ttt))
	DllStructSetData($ttt, "Title", DllStructGetPtr($ttitle))
	DllStructSetData($ttt, "Text", DllStructGetPtr($ttext))
	DllStructSetData($ttt, "Icon", $iicon)
	Return _sendmessage($hwnd, $em_showballoontip, 0, $ttt, 0, "wparam", "struct*") <> 0
EndFunc

Func _guictrledit_undo($hwnd)
	If NOT IsHWnd($hwnd) Then $hwnd = GUICtrlGetHandle($hwnd)
	Return _sendmessage($hwnd, $em_undo) <> 0
EndFunc

#RequireAdmin
#Region Declarations gwAPI_basics
	Global $mkernelhandle
	Global $mgwprochandle
	Global $mgwhwnd
	Global $mgwtitleold = "Guild Wars"
	Global $mmemory
	Global $mlabeldict = 0
	Global $mrestoredict = 0
	Global $mbase = 14548992
	Global $masmstring, $masmsize, $masmcodeoffset
	Global $mgui = GUICreate("GWA²"), $mskillactivate, $mskillcancel, $mskillcomplete, $mchatreceive, $mloadfinished
	Global $mskilllogstruct = DllStructCreate("dword;dword;dword;float")
	Global $mskilllogstructptr = DllStructGetPtr($mskilllogstruct)
	Global $mchatlogstruct = DllStructCreate("dword;wchar[256]")
	Global $mchatlogstructptr = DllStructGetPtr($mchatlogstruct)
	GUIRegisterMsg(1281, "Event")
	Global $mqueuecounter, $mqueuesize, $mqueuebase
	Global $mtargetlogbase
	Global $mstringlogbase
	Global $mskillbase
	Global $mensureenglish
	Global $mmyid, $mcurrenttarget
	Global $magentbase
	Global $mbasepointer
	Global $mregion, $mlanguage
	Global $mping
	Global $mcharname
	Global $mmapid
	Global $mmaxagents
	Global $mmaploading
	Global $mmapisloaded
	Global $mmaxplayer
	Global $mplayarray
	Global $mtargplayid
	Global $mmyplayid
	Global $mloggedin
	Global $mstringhandlerptr
	Global $mwritechatsender
	Global $mtraderquoteid, $mtradercostid, $mtradercostvalue
	Global $mskilltimer
	Global $mbuildnumber
	Global $mzoomstill, $mzoommoving
	Global $mdisablerendering
	Global $magentcopycount
	Global $magentcopybase
	Global $mchangetitle = True
	Global $musestringlog
	Global $museeventsystem
	Global $mlastdialogid
	Global $mlastdialogid
	Global $mstoragesessionbase
	Global $currentmapid = 0
	Global $mrendering = True
	Global $gwpid = -1
	Global $magentmovement
	Global $mfirstchar = ""
	Global $msleepafterport = 1000
#EndRegion Declarations
#Region UpdateWorld Variables
	Global $myid
	Global $myptr
	Global $skillbar
	Global $mself
	Global $mselfid
	Global $mlowestally
	Global $mlowestallyhp
	Global $mhighestally
	Global $mhighestallyhp
	Global $mlowestotherally
	Global $mlowestotherallyhp
	Global $mlowestenemy
	Global $mlowestenemyhp
	Global $mclosestenemy
	Global $maverageteamhp
	Global $numberoffoesinattackrange = 0
	Global $numberoffoesinspellrange = 0
	Global $bestaoetarget
	Global $hexedally
	Global $conditionedally
	Global $enemyhexed
	Global $enemynonhexed
	Global $enemyconditioned
	Global $enemynonconditioned
	Global $enemynonenchanted
	Global $enemyenchanted
	Global $enemyhealer
	Global $lowhpenemy
	Global $enemyattacker = 0
	Global $mteam[2] = [0, 0]
	Global $mteamothers[1]
	Global $mteamdead[1]
	Global $mspirits[1]
	Global $mminions[1]
	Global $mdazed = False
	Global $mblind = False
	Global $mskillhardcounter = False
	Global $mskillsoftcounter = 0
	Global $mattackhardcounter = False
	Global $mattacksoftcounter = 0
	Global $mallyspellhardcounter = False
	Global $menemyspellhardcounter = False
	Global $mspellsoftcounter = 0
	Global $mblocking = False
	Global $mclosestenemy
	Global $mclosestenemydist
	Global $meffects
	Global $menergy
	Global $currentmapstate = 0
	Global $resigned = False
	Global $gotbounty = False
	Global $getskillbar = False
	Global $savedleader = 0
	Global $savedleaderid = 0
	Global $hurttimer = TimerInit()
	Global $currenthp = 1000
	Global $aoedanger = False
	Global $aoedangerrange = 0
	Global $aoedangerxlocation
	Global $aoedangerylocation
	Global $aoedangerduration
	Global $aoedangertimer
#EndRegion
#Region SmartCast Variables
	#Region MoveToSafeSpot
		Global $clostestx[1]
		Global $clostesty[1]
		Global $spiritaveragexlocation = 0
		Global $spiritaverageylocation = 0
		Global $enemyaveragexlocation = 0
	#EndRegion MoveToSafeSpot
	#Region CacheSkill
		Global $mskillpriorityrating[9][3]
		Global $mskillbarcache[9] = [False]
		Global $mskillbarcachestruct[9] = [False]
		Global $mskillbarcacheenergyreq[9] = [False]
		Global $mskillbar
		Global $mskillbarptr
		Global $mskillbarcachearray[9][11]
		Global $mskillbarcacheptr[9] = [False]
		Global $ishealingspell[9] = [False]
		Global $isymlad[9] = [False]
		Global $isinterrupt[9] = [False]
		Global $ymladslot = 0
		Global $issummonspell[9] = [False]
		Global $issoultwistingspell[9] = [False]
		Global $isselfcastingspell[9] = [False]
		Global $isweaponspell[9] = [False]
		Global $skilldamageamount[9] = [False]
		Global $skilladrenalinereq[9] = [False]
		Global $lmyprofession
		Global $lattrprimary
	#EndRegion
#EndRegion
#Region GUI
	Global $boolrun = False
	Global $resigned = False
	Global $updatetext
	Global $firstrun = True
#EndRegion
#Region Misc Variables
	Global $mmaxpartysize = 12
	Global $mpartyarray[13]
	Global $muuid = ""
	#Region PickUp
		Global $mbattleplans = False
		Global $mmappieces = False
		Global $mtomes = True
		Global $melitetomes = True
		Global $mmesmertomes = False
		Global $melementalisttomes = False
		Global $mquestitems = False
		Global $mdyes = False
		Global $msalvagetrophies = True
		Global $mraritygold = True
		Global $mraritygreen = False
		Global $meventmodelid = 0
		Global $meventcount = 0
		Global $mpickupall = True
		Global $mleecher = False
		Global $mpickupquestitems = True
	#EndRegion
	#Region Inventory
		Global $memptybag = 8
		Global $memptyslot = 0
		Global $mstoregold = True
		Global $mstorematerials = True
		Global $mblackwhite = True
		Global $mmatexchangegold = 930
		Global $msalvagestacks = True
		Global $mdustfeatherfiber = 0
		Global $mgraniteironbone = 0
		Global $mwhitemantleemblem = True
		Global $mwhitemantlebadge = True
	#EndRegion
	#Region TempStorage
		Global $mbags = 16
		Global $mtempstorage[1][2] = [[0, 0]]
		Global $mfoundmerch = False
		Global $mfoundchest = False
	#EndRegion TempStorage
#EndRegion
#Region Map and co.
	Global Enum $difficulty_normal, $difficulty_hard
	Global Enum $instancetype_outpost, $instancetype_explorable, $instancetype_loading
	Global Enum $region_international = -2, $region_america = 0, $region_korea, $region_europe, $region_china, $region_japan
	Global Enum $language_english = 0, $language_french = 2, $language_german, $language_italian, $language_spanish, $language_polish = 9, $language_russian
#EndRegion
#Region Items and Inventory/Bags
	Global Enum $rarity_white = 2621, $rarity_blue = 2623, $rarity_purple = 2626, $rarity_gold = 2624, $rarity_green = 2627
	Global Enum $bag_backpack = 1, $bag_beltpouch, $bag_bag1, $bag_bag2, $bag_equipmentpack, $bag_unclaimeditems = 7, $bag_storage1, $bag_storage2, $bag_storage3, $bag_storage4, $bag_storage5, $bag_storage6, $bag_storage7, $bag_storage8, $bag_storageanniversary
	Global Enum $dye_blue = 2, $dye_green, $dye_purple, $dye_red, $dye_yellow, $dye_brown, $dye_orange, $dye_silver, $dye_black, $dye_gray, $dye_white, $dye_pink
	Global $pink = 9
	Global Const $modstruct_headpiece_domination_magic = "3F"
	Global Const $modstruct_headpiece_fast_casting = "40"
	Global Const $modstruct_headpiece_illusion_magic = "41"
	Global Const $modstruct_headpiece_inspiration_magic = "42"
	Global Const $modstruct_headpiece_blood_magic = "43"
	Global Const $modstruct_headpiece_curses = "44"
	Global Const $modstruct_headpiece_death_magic = "45"
	Global Const $modstruct_headpiece_soul_reaping = "46"
	Global Const $modstruct_headpiece_air_magic = "47"
	Global Const $modstruct_headpiece_earth_magic = "48"
	Global Const $modstruct_headpiece_energy_storage = "49"
	Global Const $modstruct_headpiece_fire_magic = "4A"
	Global Const $modstruct_headpiece_water_magic = "4B"
	Global Const $modstruct_headpiece_divine_favor = "4C"
	Global Const $modstruct_headpiece_healing_prayers = "4D"
	Global Const $modstruct_headpiece_protection_prayers = "4E"
	Global Const $modstruct_headpiece_smiting_prayers = "4F"
	Global Const $modstruct_headpiece_axe_mastery = "50"
	Global Const $modstruct_headpiece_hammer_mastery = "51"
	Global Const $modstruct_headpiece_swordsmanship = "53"
	Global Const $modstruct_headpiece_strength = "54"
	Global Const $modstruct_headpiece_tactics = "55"
	Global Const $modstruct_headpiece_beast_mastery = "56"
	Global Const $modstruct_headpiece_marksmanship = "57"
	Global Const $modstruct_headpiece_expertise = "58"
	Global Const $modstruct_headpiece_wilderness_survival = "59"
	#Region ItemModelIDs
		Global Const $ectoplasm = 930
		Global Const $obsidianshards = 945
		Global Const $ruby = 937
		Global Const $sapphire = 938
		Global Const $diessachalice = 24353
		Global Const $goldenrinrelics = 24354
		Global Const $lockpicks = 22751
		Global Const $superbcharrcarving = 27052
		Global Const $darkremains = 522
		Global Const $umbralskeletallimbs = 525
		Global Const $scroll_underworld = 3746
		Global Const $scroll_fow = 22280
		Global Const $mat_bone = 921
		Global Const $mat_dust = 929
		Global Const $mat_iron = 948
		Global Const $mat_tannedhides = 940
		Global Const $mat_scales = 953
		Global Const $mat_chitin = 954
		Global Const $mat_cloth = 925
		Global Const $mat_wood = 946
		Global Const $mat_granite = 955
		Global Const $mat_fiber = 934
		Global Const $mat_feathers = 933
		Global Const $con_essenceofcelerity = 24859
		Global Const $con_grailofmight = 24861
		Global Const $con_armorofsalvation = 24860
		Global Const $grog = 30855
		Global Const $golds = 2511
		Global Const $gstones = 27047
		Global Const $tots = 28434
	#EndRegion ItemModelIDs
#EndRegion
#Region Heroes
	Global Enum $hero_norgu = 1, $hero_goren, $hero_tahlkora, $hero_masterofwhispers, $hero_acolytejin, $hero_koss, $hero_dunkoro, $hero_acolytesousuke, $hero_melonni, $hero_zhedshadowhoof, $hero_generalmorgahn, $hero_margridthesly, $hero_olias = 14, $hero_razah, $hero_mox, $hero_jora = 18, $hero_pyrefierceshot, $hero_livia = 21, $hero_hayda, $hero_kahmu, $hero_gwen, $hero_xandra, $hero_vekk, $hero_ogden
	Global Enum $heromode_fight, $heromode_guard, $heromode_avoid
#EndRegion
#Region ProfessionStats
	Global Enum $profession_none, $profession_warrior, $profession_ranger, $profession_monk, $profession_necromancer, $profession_mesmer, $profession_elementalist, $profession_assassin, $profession_ritualist, $profession_paragon, $profession_dervish
	Global Enum $attrib_fastcasting, $attrib_illusionmagic, $attrib_dominationmagic, $attrib_inspirationmagic, $attrib_bloodmagic, $attrib_deathmagic, $attrib_soulreaping, $attrib_curses, $attrib_airmagic, $attrib_earthmagic, $attrib_firemagic, $attrib_watermagic, $attrib_energystorage, $attrib_healingprayers, $attrib_smitingprayers, $attrib_protectionprayers, $attrib_divinefavor, $attrib_strength, $attrib_axemastery, $attrib_hammermastery, $attrib_swordsmanship, $attrib_tactics, $attrib_beastmastery, $attrib_expertise, $attrib_wildernesssurvival, $attrib_marksmanship, $attrib_daggermastery, $attrib_deadlyarts, $attrib_shadowarts, $attrib_communing, $attrib_restorationmagic, $attrib_channelingmagic, $attrib_criticalstrikes, $attrib_spawningpower, $attrib_spearmastery, $attrib_command, $attrib_motivation, $attrib_leadership, $attrib_scythemastery, $attrib_windprayers, $attrib_earthprayers, $attrib_mysticism
	Global Enum $equip_weapon, $equip_offhand, $equip_chest, $equip_legs, $equip_head, $equip_feet, $equip_hands
#EndRegion
#Region Skills
	Global Enum $skilltype_stance = 3, $skilltype_hex, $skilltype_spell, $skilltype_enchantment, $skilltype_signet, $skilltype_well = 9, $skilltype_skill, $skilltype_ward, $skilltype_glyph, $skilltype_attack = 14, $skilltype_shout, $skilltype_preparation = 19, $skilltype_trap = 21, $skilltype_ritual, $skilltype_itemspell = 24, $skilltype_weaponspell, $skilltype_chant = 27, $skilltype_echorefrain
	Global $target_self = 0
	Global $target_none = 0
	Global $target_spirit = 1
	Global $target_animal = 1
	Global $target_corpse = 1
	Global $target_ally = 3
	Global $target_otherally = 4
	Global $target_enemy = 5
	Global $target_dead_ally = 6
	Global $target_minion = 14
	Global $target_ground = 16
	Global Const $range_adjacent = 156
	Global Const $range_nearby = 240
	Global Const $range_area = 312
	Global Const $range_earshot = 1000
	Global Const $range_spell_casting = 1085
	Global Const $range_spirit = 2500
	Global Const $range_compass = 5000
	Global Const $skillid_no_skill = 0
	Global Const $skillid_healing_signet = 1
	Global Const $skillid_resurrection_signet = 2
	Global Const $skillid_signet_of_capture = 3
	Global Const $skillid_bamph = 4
	Global Const $skillid_power_block = 5
	Global Const $skillid_mantra_of_earth = 6
	Global Const $skillid_mantra_of_flame = 7
	Global Const $skillid_mantra_of_frost = 8
	Global Const $skillid_mantra_of_lightning = 9
	Global Const $skillid_hex_breaker = 10
	Global Const $skillid_distortion = 11
	Global Const $skillid_mantra_of_celerity = 12
	Global Const $skillid_mantra_of_recovery = 13
	Global Const $skillid_mantra_of_persistence = 14
	Global Const $skillid_mantra_of_inscriptions = 15
	Global Const $skillid_mantra_of_concentration = 16
	Global Const $skillid_mantra_of_resolve = 17
	Global Const $skillid_mantra_of_signets = 18
	Global Const $skillid_fragility = 19
	Global Const $skillid_confusion = 20
	Global Const $skillid_inspired_enchantment = 21
	Global Const $skillid_inspired_hex = 22
	Global Const $skillid_power_spike = 23
	Global Const $skillid_power_leak = 24
	Global Const $skillid_power_drain = 25
	Global Const $skillid_empathy = 26
	Global Const $skillid_shatter_delusions = 27
	Global Const $skillid_backfire = 28
	Global Const $skillid_blackout = 29
	Global Const $skillid_diversion = 30
	Global Const $skillid_conjure_phantasm = 31
	Global Const $skillid_illusion_of_weakness = 32
	Global Const $skillid_illusionary_weaponry = 33
	Global Const $skillid_sympathetic_visage = 34
	Global Const $skillid_ignorance = 35
	Global Const $skillid_arcane_conundrum = 36
	Global Const $skillid_illusion_of_haste = 37
	Global Const $skillid_channeling = 38
	Global Const $skillid_energy_surge = 39
	Global Const $skillid_ether_feast = 40
	Global Const $skillid_ether_lord = 41
	Global Const $skillid_energy_burn = 42
	Global Const $skillid_clumsiness = 43
	Global Const $skillid_phantom_pain = 44
	Global Const $skillid_ethereal_burden = 45
	Global Const $skillid_guilt = 46
	Global Const $skillid_ineptitude = 47
	Global Const $skillid_spirit_of_failure = 48
	Global Const $skillid_mind_wrack = 49
	Global Const $skillid_wastrels_worry = 50
	Global Const $skillid_shame = 51
	Global Const $skillid_panic = 52
	Global Const $skillid_migraine = 53
	Global Const $skillid_crippling_anguish = 54
	Global Const $skillid_fevered_dreams = 55
	Global Const $skillid_soothing_images = 56
	Global Const $skillid_cry_of_frustration = 57
	Global Const $skillid_signet_of_midnight = 58
	Global Const $skillid_signet_of_weariness = 59
	Global Const $skillid_signet_of_illusions_beta_version = 60
	Global Const $skillid_leech_signet = 61
	Global Const $skillid_signet_of_humility = 62
	Global Const $skillid_keystone_signet = 63
	Global Const $skillid_mimic = 64
	Global Const $skillid_arcane_mimicry = 65
	Global Const $skillid_spirit_shackles = 66
	Global Const $skillid_shatter_hex = 67
	Global Const $skillid_drain_enchantment = 68
	Global Const $skillid_shatter_enchantment = 69
	Global Const $skillid_disappear = 70
	Global Const $skillid_unnatural_signet_alpha_version = 71
	Global Const $skillid_elemental_resistance = 72
	Global Const $skillid_physical_resistance = 73
	Global Const $skillid_echo = 74
	Global Const $skillid_arcane_echo = 75
	Global Const $skillid_imagined_burden = 76
	Global Const $skillid_chaos_storm = 77
	Global Const $skillid_epidemic = 78
	Global Const $skillid_energy_drain = 79
	Global Const $skillid_energy_tap = 80
	Global Const $skillid_arcane_thievery = 81
	Global Const $skillid_mantra_of_recall = 82
	Global Const $skillid_animate_bone_horror = 83
	Global Const $skillid_animate_bone_fiend = 84
	Global Const $skillid_animate_bone_minions = 85
	Global Const $skillid_grenths_balance = 86
	Global Const $skillid_veratas_gaze = 87
	Global Const $skillid_veratas_aura = 88
	Global Const $skillid_deathly_chill = 89
	Global Const $skillid_veratas_sacrifice = 90
	Global Const $skillid_well_of_power = 91
	Global Const $skillid_well_of_blood = 92
	Global Const $skillid_well_of_suffering = 93
	Global Const $skillid_well_of_the_profane = 94
	Global Const $skillid_putrid_explosion = 95
	Global Const $skillid_soul_feast = 96
	Global Const $skillid_necrotic_traversal = 97
	Global Const $skillid_consume_corpse = 98
	Global Const $skillid_parasitic_bond = 99
	Global Const $skillid_soul_barbs = 100
	Global Const $skillid_barbs = 101
	Global Const $skillid_shadow_strike = 102
	Global Const $skillid_price_of_failure = 103
	Global Const $skillid_death_nova = 104
	Global Const $skillid_deathly_swarm = 105
	Global Const $skillid_rotting_flesh = 106
	Global Const $skillid_virulence = 107
	Global Const $skillid_suffering = 108
	Global Const $skillid_life_siphon = 109
	Global Const $skillid_unholy_feast = 110
	Global Const $skillid_awaken_the_blood = 111
	Global Const $skillid_desecrate_enchantments = 112
	Global Const $skillid_tainted_flesh = 113
	Global Const $skillid_aura_of_the_lich = 114
	Global Const $skillid_blood_renewal = 115
	Global Const $skillid_dark_aura = 116
	Global Const $skillid_enfeeble = 117
	Global Const $skillid_enfeebling_blood = 118
	Global Const $skillid_blood_is_power = 119
	Global Const $skillid_blood_of_the_master = 120
	Global Const $skillid_spiteful_spirit = 121
	Global Const $skillid_malign_intervention = 122
	Global Const $skillid_insidious_parasite = 123
	Global Const $skillid_spinal_shivers = 124
	Global Const $skillid_wither = 125
	Global Const $skillid_life_transfer = 126
	Global Const $skillid_mark_of_subversion = 127
	Global Const $skillid_soul_leech = 128
	Global Const $skillid_defile_flesh = 129
	Global Const $skillid_demonic_flesh = 130
	Global Const $skillid_barbed_signet = 131
	Global Const $skillid_plague_signet = 132
	Global Const $skillid_dark_pact = 133
	Global Const $skillid_order_of_pain = 134
	Global Const $skillid_faintheartedness = 135
	Global Const $skillid_shadow_of_fear = 136
	Global Const $skillid_rigor_mortis = 137
	Global Const $skillid_dark_bond = 138
	Global Const $skillid_infuse_condition = 139
	Global Const $skillid_malaise = 140
	Global Const $skillid_rend_enchantments = 141
	Global Const $skillid_lingering_curse = 142
	Global Const $skillid_strip_enchantment = 143
	Global Const $skillid_chilblains = 144
	Global Const $skillid_signet_of_agony = 145
	Global Const $skillid_offering_of_blood = 146
	Global Const $skillid_dark_fury = 147
	Global Const $skillid_order_of_the_vampire = 148
	Global Const $skillid_plague_sending = 149
	Global Const $skillid_mark_of_pain = 150
	Global Const $skillid_feast_of_corruption = 151
	Global Const $skillid_taste_of_death = 152
	Global Const $skillid_vampiric_gaze = 153
	Global Const $skillid_plague_touch = 154
	Global Const $skillid_vile_touch = 155
	Global Const $skillid_vampiric_touch = 156
	Global Const $skillid_blood_ritual = 157
	Global Const $skillid_touch_of_agony = 158
	Global Const $skillid_weaken_armor = 159
	Global Const $skillid_windborne_speed = 160
	Global Const $skillid_lightning_storm = 161
	Global Const $skillid_gale = 162
	Global Const $skillid_whirlwind = 163
	Global Const $skillid_elemental_attunement = 164
	Global Const $skillid_armor_of_earth = 165
	Global Const $skillid_kinetic_armor = 166
	Global Const $skillid_eruption = 167
	Global Const $skillid_magnetic_aura = 168
	Global Const $skillid_earth_attunement = 169
	Global Const $skillid_earthquake = 170
	Global Const $skillid_stoning = 171
	Global Const $skillid_stone_daggers = 172
	Global Const $skillid_grasping_earth = 173
	Global Const $skillid_aftershock = 174
	Global Const $skillid_ward_against_elements = 175
	Global Const $skillid_ward_against_melee = 176
	Global Const $skillid_ward_against_foes = 177
	Global Const $skillid_ether_prodigy = 178
	Global Const $skillid_incendiary_bonds = 179
	Global Const $skillid_aura_of_restoration = 180
	Global Const $skillid_ether_renewal = 181
	Global Const $skillid_conjure_flame = 182
	Global Const $skillid_inferno = 183
	Global Const $skillid_fire_attunement = 184
	Global Const $skillid_mind_burn = 185
	Global Const $skillid_fireball = 186
	Global Const $skillid_meteor = 187
	Global Const $skillid_flame_burst = 188
	Global Const $skillid_rodgorts_invocation = 189
	Global Const $skillid_mark_of_rodgort = 190
	Global Const $skillid_immolate = 191
	Global Const $skillid_meteor_shower = 192
	Global Const $skillid_phoenix = 193
	Global Const $skillid_flare = 194
	Global Const $skillid_lava_font = 195
	Global Const $skillid_searing_heat = 196
	Global Const $skillid_fire_storm = 197
	Global Const $skillid_glyph_of_elemental_power = 198
	Global Const $skillid_glyph_of_energy = 199
	Global Const $skillid_glyph_of_lesser_energy = 200
	Global Const $skillid_glyph_of_concentration = 201
	Global Const $skillid_glyph_of_sacrifice = 202
	Global Const $skillid_glyph_of_renewal = 203
	Global Const $skillid_rust = 204
	Global Const $skillid_lightning_surge = 205
	Global Const $skillid_armor_of_frost = 206
	Global Const $skillid_conjure_frost = 207
	Global Const $skillid_water_attunement = 208
	Global Const $skillid_mind_freeze = 209
	Global Const $skillid_ice_prison = 210
	Global Const $skillid_ice_spikes = 211
	Global Const $skillid_frozen_burst = 212
	Global Const $skillid_shard_storm = 213
	Global Const $skillid_ice_spear = 214
	Global Const $skillid_maelstrom = 215
	Global Const $skillid_iron_mist = 216
	Global Const $skillid_crystal_wave = 217
	Global Const $skillid_obsidian_flesh = 218
	Global Const $skillid_obsidian_flame = 219
	Global Const $skillid_blinding_flash = 220
	Global Const $skillid_conjure_lightning = 221
	Global Const $skillid_lightning_strike = 222
	Global Const $skillid_chain_lightning = 223
	Global Const $skillid_enervating_charge = 224
	Global Const $skillid_air_attunement = 225
	Global Const $skillid_mind_shock = 226
	Global Const $skillid_glimmering_mark = 227
	Global Const $skillid_thunderclap = 228
	Global Const $skillid_lightning_orb = 229
	Global Const $skillid_lightning_javelin = 230
	Global Const $skillid_shock = 231
	Global Const $skillid_lightning_touch = 232
	Global Const $skillid_swirling_aura = 233
	Global Const $skillid_deep_freeze = 234
	Global Const $skillid_blurred_vision = 235
	Global Const $skillid_mist_form = 236
	Global Const $skillid_water_trident = 237
	Global Const $skillid_armor_of_mist = 238
	Global Const $skillid_ward_against_harm = 239
	Global Const $skillid_smite = 240
	Global Const $skillid_life_bond = 241
	Global Const $skillid_balthazars_spirit = 242
	Global Const $skillid_strength_of_honor = 243
	Global Const $skillid_life_attunement = 244
	Global Const $skillid_protective_spirit = 245
	Global Const $skillid_divine_intervention = 246
	Global Const $skillid_symbol_of_wrath = 247
	Global Const $skillid_retribution = 248
	Global Const $skillid_holy_wrath = 249
	Global Const $skillid_essence_bond = 250
	Global Const $skillid_scourge_healing = 251
	Global Const $skillid_banish = 252
	Global Const $skillid_scourge_sacrifice = 253
	Global Const $skillid_vigorous_spirit = 254
	Global Const $skillid_watchful_spirit = 255
	Global Const $skillid_blessed_aura = 256
	Global Const $skillid_aegis = 257
	Global Const $skillid_guardian = 258
	Global Const $skillid_shield_of_deflection = 259
	Global Const $skillid_aura_of_faith = 260
	Global Const $skillid_shield_of_regeneration = 261
	Global Const $skillid_shield_of_judgment = 262
	Global Const $skillid_protective_bond = 263
	Global Const $skillid_pacifism = 264
	Global Const $skillid_amity = 265
	Global Const $skillid_peace_and_harmony = 266
	Global Const $skillid_judges_insight = 267
	Global Const $skillid_unyielding_aura = 268
	Global Const $skillid_mark_of_protection = 269
	Global Const $skillid_life_barrier = 270
	Global Const $skillid_zealots_fire = 271
	Global Const $skillid_balthazars_aura = 272
	Global Const $skillid_spell_breaker = 273
	Global Const $skillid_healing_seed = 274
	Global Const $skillid_mend_condition = 275
	Global Const $skillid_restore_condition = 276
	Global Const $skillid_mend_ailment = 277
	Global Const $skillid_purge_conditions = 278
	Global Const $skillid_divine_healing = 279
	Global Const $skillid_heal_area = 280
	Global Const $skillid_orison_of_healing = 281
	Global Const $skillid_word_of_healing = 282
	Global Const $skillid_dwaynas_kiss = 283
	Global Const $skillid_divine_boon = 284
	Global Const $skillid_healing_hands = 285
	Global Const $skillid_heal_other = 286
	Global Const $skillid_heal_party = 287
	Global Const $skillid_healing_breeze = 288
	Global Const $skillid_vital_blessing = 289
	Global Const $skillid_mending = 290
	Global Const $skillid_live_vicariously = 291
	Global Const $skillid_infuse_health = 292
	Global Const $skillid_signet_of_devotion = 293
	Global Const $skillid_signet_of_judgment = 294
	Global Const $skillid_purge_signet = 295
	Global Const $skillid_bane_signet = 296
	Global Const $skillid_blessed_signet = 297
	Global Const $skillid_martyr = 298
	Global Const $skillid_shielding_hands = 299
	Global Const $skillid_contemplation_of_purity = 300
	Global Const $skillid_remove_hex = 301
	Global Const $skillid_smite_hex = 302
	Global Const $skillid_convert_hexes = 303
	Global Const $skillid_light_of_dwayna = 304
	Global Const $skillid_resurrect = 305
	Global Const $skillid_rebirth = 306
	Global Const $skillid_reversal_of_fortune = 307
	Global Const $skillid_succor = 308
	Global Const $skillid_holy_veil = 309
	Global Const $skillid_divine_spirit = 310
	Global Const $skillid_draw_conditions = 311
	Global Const $skillid_holy_strike = 312
	Global Const $skillid_healing_touch = 313
	Global Const $skillid_restore_life = 314
	Global Const $skillid_vengeance = 315
	Global Const $skillid_to_the_limit = 316
	Global Const $skillid_battle_rage = 317
	Global Const $skillid_defy_pain = 318
	Global Const $skillid_rush = 319
	Global Const $skillid_hamstring = 320
	Global Const $skillid_wild_blow = 321
	Global Const $skillid_power_attack = 322
	Global Const $skillid_desperation_blow = 323
	Global Const $skillid_thrill_of_victory = 324
	Global Const $skillid_distracting_blow = 325
	Global Const $skillid_protectors_strike = 326
	Global Const $skillid_griffons_sweep = 327
	Global Const $skillid_pure_strike = 328
	Global Const $skillid_skull_crack = 329
	Global Const $skillid_cyclone_axe = 330
	Global Const $skillid_hammer_bash = 331
	Global Const $skillid_bulls_strike = 332
	Global Const $skillid_i_will_avenge_you = 333
	Global Const $skillid_axe_rake = 334
	Global Const $skillid_cleave = 335
	Global Const $skillid_executioners_strike = 336
	Global Const $skillid_dismember = 337
	Global Const $skillid_eviscerate = 338
	Global Const $skillid_penetrating_blow = 339
	Global Const $skillid_disrupting_chop = 340
	Global Const $skillid_swift_chop = 341
	Global Const $skillid_axe_twist = 342
	Global Const $skillid_for_great_justice = 343
	Global Const $skillid_flurry = 344
	Global Const $skillid_defensive_stance = 345
	Global Const $skillid_frenzy = 346
	Global Const $skillid_endure_pain = 347
	Global Const $skillid_watch_yourself = 348
	Global Const $skillid_sprint = 349
	Global Const $skillid_belly_smash = 350
	Global Const $skillid_mighty_blow = 351
	Global Const $skillid_crushing_blow = 352
	Global Const $skillid_crude_swing = 353
	Global Const $skillid_earth_shaker = 354
	Global Const $skillid_devastating_hammer = 355
	Global Const $skillid_irresistible_blow = 356
	Global Const $skillid_counter_blow = 357
	Global Const $skillid_backbreaker = 358
	Global Const $skillid_heavy_blow = 359
	Global Const $skillid_staggering_blow = 360
	Global Const $skillid_dolyak_signet = 361
	Global Const $skillid_warriors_cunning = 362
	Global Const $skillid_shield_bash = 363
	Global Const $skillid_charge = 364
	Global Const $skillid_victory_is_mine = 365
	Global Const $skillid_fear_me = 366
	Global Const $skillid_shields_up = 367
	Global Const $skillid_i_will_survive = 368
	Global Const $skillid_dont_believe_their_lies = 369
	Global Const $skillid_berserker_stance = 370
	Global Const $skillid_balanced_stance = 371
	Global Const $skillid_gladiators_defense = 372
	Global Const $skillid_deflect_arrows = 373
	Global Const $skillid_warriors_endurance = 374
	Global Const $skillid_dwarven_battle_stance = 375
	Global Const $skillid_disciplined_stance = 376
	Global Const $skillid_wary_stance = 377
	Global Const $skillid_shield_stance = 378
	Global Const $skillid_bulls_charge = 379
	Global Const $skillid_bonettis_defense = 380
	Global Const $skillid_hundred_blades = 381
	Global Const $skillid_sever_artery = 382
	Global Const $skillid_galrath_slash = 383
	Global Const $skillid_gash = 384
	Global Const $skillid_final_thrust = 385
	Global Const $skillid_seeking_blade = 386
	Global Const $skillid_riposte = 387
	Global Const $skillid_deadly_riposte = 388
	Global Const $skillid_flourish = 389
	Global Const $skillid_savage_slash = 390
	Global Const $skillid_hunters_shot = 391
	Global Const $skillid_pin_down = 392
	Global Const $skillid_crippling_shot = 393
	Global Const $skillid_power_shot = 394
	Global Const $skillid_barrage = 395
	Global Const $skillid_dual_shot = 396
	Global Const $skillid_quick_shot = 397
	Global Const $skillid_penetrating_attack = 398
	Global Const $skillid_distracting_shot = 399
	Global Const $skillid_precision_shot = 400
	Global Const $skillid_splinter_shot_monster_skill = 401
	Global Const $skillid_determined_shot = 402
	Global Const $skillid_called_shot = 403
	Global Const $skillid_poison_arrow = 404
	Global Const $skillid_oath_shot = 405
	Global Const $skillid_debilitating_shot = 406
	Global Const $skillid_point_blank_shot = 407
	Global Const $skillid_concussion_shot = 408
	Global Const $skillid_punishing_shot = 409
	Global Const $skillid_call_of_ferocity = 410
	Global Const $skillid_charm_animal = 411
	Global Const $skillid_call_of_protection = 412
	Global Const $skillid_call_of_elemental_protection = 413
	Global Const $skillid_call_of_vitality = 414
	Global Const $skillid_call_of_haste = 415
	Global Const $skillid_call_of_healing = 416
	Global Const $skillid_call_of_resilience = 417
	Global Const $skillid_call_of_feeding = 418
	Global Const $skillid_call_of_the_hunter = 419
	Global Const $skillid_call_of_brutality = 420
	Global Const $skillid_call_of_disruption = 421
	Global Const $skillid_revive_animal = 422
	Global Const $skillid_symbiotic_bond = 423
	Global Const $skillid_throw_dirt = 424
	Global Const $skillid_dodge = 425
	Global Const $skillid_savage_shot = 426
	Global Const $skillid_antidote_signet = 427
	Global Const $skillid_incendiary_arrows = 428
	Global Const $skillid_melandrus_arrows = 429
	Global Const $skillid_marksmans_wager = 430
	Global Const $skillid_ignite_arrows = 431
	Global Const $skillid_read_the_wind = 432
	Global Const $skillid_kindle_arrows = 433
	Global Const $skillid_choking_gas = 434
	Global Const $skillid_apply_poison = 435
	Global Const $skillid_comfort_animal = 436
	Global Const $skillid_bestial_pounce = 437
	Global Const $skillid_maiming_strike = 438
	Global Const $skillid_feral_lunge = 439
	Global Const $skillid_scavenger_strike = 440
	Global Const $skillid_melandrus_assault = 441
	Global Const $skillid_ferocious_strike = 442
	Global Const $skillid_predators_pounce = 443
	Global Const $skillid_brutal_strike = 444
	Global Const $skillid_disrupting_lunge = 445
	Global Const $skillid_troll_unguent = 446
	Global Const $skillid_otyughs_cry = 447
	Global Const $skillid_escape = 448
	Global Const $skillid_practiced_stance = 449
	Global Const $skillid_whirling_defense = 450
	Global Const $skillid_melandrus_resilience = 451
	Global Const $skillid_dryders_defenses = 452
	Global Const $skillid_lightning_reflexes = 453
	Global Const $skillid_tigers_fury = 454
	Global Const $skillid_storm_chaser = 455
	Global Const $skillid_serpents_quickness = 456
	Global Const $skillid_dust_trap = 457
	Global Const $skillid_barbed_trap = 458
	Global Const $skillid_flame_trap = 459
	Global Const $skillid_healing_spring = 460
	Global Const $skillid_spike_trap = 461
	Global Const $skillid_winter = 462
	Global Const $skillid_winnowing = 463
	Global Const $skillid_edge_of_extinction = 464
	Global Const $skillid_greater_conflagration = 465
	Global Const $skillid_conflagration = 466
	Global Const $skillid_fertile_season = 467
	Global Const $skillid_symbiosis = 468
	Global Const $skillid_primal_echoes = 469
	Global Const $skillid_predatory_season = 470
	Global Const $skillid_frozen_soil = 471
	Global Const $skillid_favorable_winds = 472
	Global Const $skillid_high_winds = 473
	Global Const $skillid_energizing_wind = 474
	Global Const $skillid_quickening_zephyr = 475
	Global Const $skillid_natures_renewal = 476
	Global Const $skillid_muddy_terrain = 477
	Global Const $skillid_bleeding = 478
	Global Const $skillid_blind = 479
	Global Const $skillid_burning = 480
	Global Const $skillid_crippled = 481
	Global Const $skillid_deep_wound = 482
	Global Const $skillid_disease = 483
	Global Const $skillid_poison = 484
	Global Const $skillid_dazed = 485
	Global Const $skillid_weakness = 486
	Global Const $skillid_cleansed = 487
	Global Const $skillid_eruption_environment = 488
	Global Const $skillid_fire_storm_environment = 489
	Global Const $skillid_fount_of_maguuma = 491
	Global Const $skillid_healing_fountain = 492
	Global Const $skillid_icy_ground = 493
	Global Const $skillid_maelstrom_environment = 494
	Global Const $skillid_mursaat_tower_skill = 495
	Global Const $skillid_quicksand_environment_effect = 496
	Global Const $skillid_curse_of_the_bloodstone = 497
	Global Const $skillid_chain_lightning_environment = 498
	Global Const $skillid_obelisk_lightning = 499
	Global Const $skillid_tar = 500
	Global Const $skillid_siege_attack = 501
	Global Const $skillid_scepter_of_orrs_aura = 503
	Global Const $skillid_scepter_of_orrs_power = 504
	Global Const $skillid_burden_totem = 505
	Global Const $skillid_splinter_mine_skill = 506
	Global Const $skillid_entanglement = 507
	Global Const $skillid_dwarven_powder_keg = 508
	Global Const $skillid_seed_of_resurrection = 509
	Global Const $skillid_deafening_roar = 510
	Global Const $skillid_brutal_mauling = 511
	Global Const $skillid_crippling_attack = 512
	Global Const $skillid_breaking_charm = 514
	Global Const $skillid_charr_buff = 515
	Global Const $skillid_claim_resource = 516
	Global Const $skillid_dozen_shot = 524
	Global Const $skillid_nibble = 525
	Global Const $skillid_reflection = 528
	Global Const $skillid_giant_stomp = 530
	Global Const $skillid_agnars_rage = 531
	Global Const $skillid_crystal_haze = 533
	Global Const $skillid_crystal_bonds = 534
	Global Const $skillid_jagged_crystal_skin = 535
	Global Const $skillid_crystal_hibernation = 536
	Global Const $skillid_hunger_of_the_lich = 539
	Global Const $skillid_embrace_the_pain = 540
	Global Const $skillid_life_vortex = 541
	Global Const $skillid_oracle_link = 542
	Global Const $skillid_guardian_pacify = 543
	Global Const $skillid_soul_vortex = 544
	Global Const $skillid_spectral_agony = 546
	Global Const $skillid_undead_sensitivity_to_light = 554
	Global Const $skillid_titans_get_plus_health_regen_and_set_enemies_on_fire_each_time_he_is_hit = 558
	Global Const $skillid_resurrect_resurrect_gargoyle = 560
	Global Const $skillid_wurm_siege = 563
	Global Const $skillid_shiver_touch = 566
	Global Const $skillid_spontaneous_combustion = 567
	Global Const $skillid_vanish = 568
	Global Const $skillid_victory_or_death = 569
	Global Const $skillid_mark_of_insecurity = 570
	Global Const $skillid_disrupting_dagger = 571
	Global Const $skillid_deadly_paradox = 572
	Global Const $skillid_holy_blessing = 575
	Global Const $skillid_statues_blessing = 576
	Global Const $skillid_domain_of_energy_draining = 580
	Global Const $skillid_domain_of_health_draining = 582
	Global Const $skillid_domain_of_slow = 583
	Global Const $skillid_divine_fire = 584
	Global Const $skillid_swamp_water = 585
	Global Const $skillid_janthirs_gaze = 586
	Global Const $skillid_stormcaller_skill = 589
	Global Const $skillid_knock = 590
	Global Const $skillid_blessing_of_the_kurzicks = 593
	Global Const $skillid_chimera_of_intensity = 596
	Global Const $skillid_life_stealing_effect = 657
	Global Const $skillid_jaundiced_gaze = 763
	Global Const $skillid_wail_of_doom = 764
	Global Const $skillid_heros_insight = 765
	Global Const $skillid_gaze_of_contempt = 766
	Global Const $skillid_berserkers_insight = 767
	Global Const $skillid_slayers_insight = 768
	Global Const $skillid_vipers_defense = 769
	Global Const $skillid_return = 770
	Global Const $skillid_aura_of_displacement = 771
	Global Const $skillid_generous_was_tsungrai = 772
	Global Const $skillid_mighty_was_vorizun = 773
	Global Const $skillid_to_the_death = 774
	Global Const $skillid_death_blossom = 775
	Global Const $skillid_twisting_fangs = 776
	Global Const $skillid_horns_of_the_ox = 777
	Global Const $skillid_falling_spider = 778
	Global Const $skillid_black_lotus_strike = 779
	Global Const $skillid_fox_fangs = 780
	Global Const $skillid_moebius_strike = 781
	Global Const $skillid_jagged_strike = 782
	Global Const $skillid_unsuspecting_strike = 783
	Global Const $skillid_entangling_asp = 784
	Global Const $skillid_mark_of_death = 785
	Global Const $skillid_iron_palm = 786
	Global Const $skillid_resilient_weapon = 787
	Global Const $skillid_blind_was_mingson = 788
	Global Const $skillid_grasping_was_kuurong = 789
	Global Const $skillid_vengeful_was_khanhei = 790
	Global Const $skillid_flesh_of_my_flesh = 791
	Global Const $skillid_splinter_weapon = 792
	Global Const $skillid_weapon_of_warding = 793
	Global Const $skillid_wailing_weapon = 794
	Global Const $skillid_nightmare_weapon = 795
	Global Const $skillid_sorrows_flame = 796
	Global Const $skillid_sorrows_fist = 797
	Global Const $skillid_blast_furnace = 798
	Global Const $skillid_beguiling_haze = 799
	Global Const $skillid_enduring_toxin = 800
	Global Const $skillid_shroud_of_silence = 801
	Global Const $skillid_expose_defenses = 802
	Global Const $skillid_power_leech = 803
	Global Const $skillid_arcane_languor = 804
	Global Const $skillid_animate_vampiric_horror = 805
	Global Const $skillid_cultists_fervor = 806
	Global Const $skillid_reapers_mark = 808
	Global Const $skillid_shatterstone = 809
	Global Const $skillid_protectors_defense = 810
	Global Const $skillid_run_as_one = 811
	Global Const $skillid_defiant_was_xinrae = 812
	Global Const $skillid_lyssas_aura = 813
	Global Const $skillid_shadow_refuge = 814
	Global Const $skillid_scorpion_wire = 815
	Global Const $skillid_mirrored_stance = 816
	Global Const $skillid_discord = 817
	Global Const $skillid_well_of_weariness = 818
	Global Const $skillid_vampiric_spirit = 819
	Global Const $skillid_depravity = 820
	Global Const $skillid_icy_veins = 821
	Global Const $skillid_weaken_knees = 822
	Global Const $skillid_burning_speed = 823
	Global Const $skillid_lava_arrows = 824
	Global Const $skillid_bed_of_coals = 825
	Global Const $skillid_shadow_form = 826
	Global Const $skillid_siphon_strength = 827
	Global Const $skillid_vile_miasma = 828
	Global Const $skillid_ray_of_judgment = 830
	Global Const $skillid_primal_rage = 831
	Global Const $skillid_animate_flesh_golem = 832
	Global Const $skillid_reckless_haste = 834
	Global Const $skillid_blood_bond = 835
	Global Const $skillid_ride_the_lightning = 836
	Global Const $skillid_energy_boon = 837
	Global Const $skillid_dwaynas_sorrow = 838
	Global Const $skillid_retreat = 839
	Global Const $skillid_poisoned_heart = 840
	Global Const $skillid_fetid_ground = 841
	Global Const $skillid_arc_lightning = 842
	Global Const $skillid_gust = 843
	Global Const $skillid_churning_earth = 844
	Global Const $skillid_liquid_flame = 845
	Global Const $skillid_steam = 846
	Global Const $skillid_boon_signet = 847
	Global Const $skillid_reverse_hex = 848
	Global Const $skillid_lacerating_chop = 849
	Global Const $skillid_fierce_blow = 850
	Global Const $skillid_sun_and_moon_slash = 851
	Global Const $skillid_splinter_shot = 852
	Global Const $skillid_melandrus_shot = 853
	Global Const $skillid_snare = 854
	Global Const $skillid_kilroy_stonekin = 856
	Global Const $skillid_adventurers_insight = 857
	Global Const $skillid_dancing_daggers = 858
	Global Const $skillid_conjure_nightmare = 859
	Global Const $skillid_signet_of_disruption = 860
	Global Const $skillid_ravenous_gaze = 862
	Global Const $skillid_order_of_apostasy = 863
	Global Const $skillid_oppressive_gaze = 864
	Global Const $skillid_lightning_hammer = 865
	Global Const $skillid_vapor_blade = 866
	Global Const $skillid_healing_light = 867
	Global Const $skillid_coward = 869
	Global Const $skillid_pestilence = 870
	Global Const $skillid_shadowsong = 871
	Global Const $skillid_shadowsong_attack = 872
	Global Const $skillid_resurrect_monster_skill = 873
	Global Const $skillid_consuming_flames = 874
	Global Const $skillid_chains_of_enslavement = 875
	Global Const $skillid_signet_of_shadows = 876
	Global Const $skillid_lyssas_balance = 877
	Global Const $skillid_visions_of_regret = 878
	Global Const $skillid_illusion_of_pain = 879
	Global Const $skillid_stolen_speed = 880
	Global Const $skillid_ether_signet = 881
	Global Const $skillid_signet_of_disenchantment = 882
	Global Const $skillid_vocal_minority = 883
	Global Const $skillid_searing_flames = 884
	Global Const $skillid_shield_guardian = 885
	Global Const $skillid_restful_breeze = 886
	Global Const $skillid_signet_of_rejuvenation = 887
	Global Const $skillid_whirling_axe = 888
	Global Const $skillid_forceful_blow = 889
	Global Const $skillid_none_shall_pass = 891
	Global Const $skillid_quivering_blade = 892
	Global Const $skillid_seeking_arrows = 893
	Global Const $skillid_rampagers_insight = 894
	Global Const $skillid_hunters_insight = 895
	Global Const $skillid_oath_of_healing = 897
	Global Const $skillid_overload = 898
	Global Const $skillid_images_of_remorse = 899
	Global Const $skillid_shared_burden = 900
	Global Const $skillid_soul_bind = 901
	Global Const $skillid_blood_of_the_aggressor = 902
	Global Const $skillid_icy_prism = 903
	Global Const $skillid_furious_axe = 904
	Global Const $skillid_auspicious_blow = 905
	Global Const $skillid_on_your_knees = 906
	Global Const $skillid_dragon_slash = 907
	Global Const $skillid_marauders_shot = 908
	Global Const $skillid_focused_shot = 909
	Global Const $skillid_spirit_rift = 910
	Global Const $skillid_union = 911
	Global Const $skillid_tranquil_was_tanasen = 913
	Global Const $skillid_consume_soul = 914
	Global Const $skillid_spirit_light = 915
	Global Const $skillid_lamentation = 916
	Global Const $skillid_rupture_soul = 917
	Global Const $skillid_spirit_to_flesh = 918
	Global Const $skillid_spirit_burn = 919
	Global Const $skillid_destruction = 920
	Global Const $skillid_dissonance = 921
	Global Const $skillid_dissonance_attack = 922
	Global Const $skillid_disenchantment = 923
	Global Const $skillid_disenchantment_attack = 924
	Global Const $skillid_recall = 925
	Global Const $skillid_sharpen_daggers = 926
	Global Const $skillid_shameful_fear = 927
	Global Const $skillid_shadow_shroud = 928
	Global Const $skillid_shadow_of_haste = 929
	Global Const $skillid_auspicious_incantation = 930
	Global Const $skillid_power_return = 931
	Global Const $skillid_complicate = 932
	Global Const $skillid_shatter_storm = 933
	Global Const $skillid_unnatural_signet = 934
	Global Const $skillid_rising_bile = 935
	Global Const $skillid_envenom_enchantments = 936
	Global Const $skillid_shockwave = 937
	Global Const $skillid_ward_of_stability = 938
	Global Const $skillid_icy_shackles = 939
	Global Const $skillid_blessed_light = 941
	Global Const $skillid_withdraw_hexes = 942
	Global Const $skillid_extinguish = 943
	Global Const $skillid_signet_of_strength = 944
	Global Const $skillid_trappers_focus = 946
	Global Const $skillid_brambles = 947
	Global Const $skillid_desperate_strike = 948
	Global Const $skillid_way_of_the_fox = 949
	Global Const $skillid_shadowy_burden = 950
	Global Const $skillid_siphon_speed = 951
	Global Const $skillid_deaths_charge = 952
	Global Const $skillid_power_flux = 953
	Global Const $skillid_expel_hexes = 954
	Global Const $skillid_rip_enchantment = 955
	Global Const $skillid_spell_shield = 957
	Global Const $skillid_healing_whisper = 958
	Global Const $skillid_ethereal_light = 959
	Global Const $skillid_release_enchantments = 960
	Global Const $skillid_lacerate = 961
	Global Const $skillid_spirit_transfer = 962
	Global Const $skillid_restoration = 963
	Global Const $skillid_vengeful_weapon = 964
	Global Const $skillid_spear_of_archemorus = 966
	Global Const $skillid_argos_cry = 971
	Global Const $skillid_jade_fury = 972
	Global Const $skillid_blinding_powder = 973
	Global Const $skillid_mantis_touch = 974
	Global Const $skillid_exhausting_assault = 975
	Global Const $skillid_repeating_strike = 976
	Global Const $skillid_way_of_the_lotus = 977
	Global Const $skillid_mark_of_instability = 978
	Global Const $skillid_mistrust = 979
	Global Const $skillid_feast_of_souls = 980
	Global Const $skillid_recuperation = 981
	Global Const $skillid_shelter = 982
	Global Const $skillid_weapon_of_shadow = 983
	Global Const $skillid_torch_enchantment = 984
	Global Const $skillid_caltrops = 985
	Global Const $skillid_nine_tail_strike = 986
	Global Const $skillid_way_of_the_empty_palm = 987
	Global Const $skillid_temple_strike = 988
	Global Const $skillid_golden_phoenix_strike = 989
	Global Const $skillid_expunge_enchantments = 990
	Global Const $skillid_deny_hexes = 991
	Global Const $skillid_triple_chop = 992
	Global Const $skillid_enraged_smash = 993
	Global Const $skillid_renewing_smash = 994
	Global Const $skillid_tiger_stance = 995
	Global Const $skillid_standing_slash = 996
	Global Const $skillid_famine = 997
	Global Const $skillid_torch_hex = 998
	Global Const $skillid_torch_degeneration_hex = 999
	Global Const $skillid_blinding_snow = 1000
	Global Const $skillid_avalanche_skill = 1001
	Global Const $skillid_snowball = 1002
	Global Const $skillid_mega_snowball = 1003
	Global Const $skillid_yuletide = 1004
	Global Const $skillid_ice_fort = 1006
	Global Const $skillid_yellow_snow = 1007
	Global Const $skillid_hidden_rock = 1008
	Global Const $skillid_snow_down_the_shirt = 1009
	Global Const $skillid_mmmm_snowcone = 1010
	Global Const $skillid_holiday_blues = 1011
	Global Const $skillid_icicles = 1012
	Global Const $skillid_ice_breaker = 1013
	Global Const $skillid_lets_get_em = 1014
	Global Const $skillid_flurry_of_ice = 1015
	Global Const $skillid_critical_eye = 1018
	Global Const $skillid_critical_strike = 1019
	Global Const $skillid_blades_of_steel = 1020
	Global Const $skillid_jungle_strike = 1021
	Global Const $skillid_wild_strike = 1022
	Global Const $skillid_leaping_mantis_sting = 1023
	Global Const $skillid_black_mantis_thrust = 1024
	Global Const $skillid_disrupting_stab = 1025
	Global Const $skillid_golden_lotus_strike = 1026
	Global Const $skillid_critical_defenses = 1027
	Global Const $skillid_way_of_perfection = 1028
	Global Const $skillid_dark_apostasy = 1029
	Global Const $skillid_locusts_fury = 1030
	Global Const $skillid_shroud_of_distress = 1031
	Global Const $skillid_heart_of_shadow = 1032
	Global Const $skillid_impale = 1033
	Global Const $skillid_seeping_wound = 1034
	Global Const $skillid_assassins_promise = 1035
	Global Const $skillid_signet_of_malice = 1036
	Global Const $skillid_dark_escape = 1037
	Global Const $skillid_crippling_dagger = 1038
	Global Const $skillid_star_strike = 1039
	Global Const $skillid_spirit_walk = 1040
	Global Const $skillid_unseen_fury = 1041
	Global Const $skillid_flashing_blades = 1042
	Global Const $skillid_dash = 1043
	Global Const $skillid_dark_prison = 1044
	Global Const $skillid_palm_strike = 1045
	Global Const $skillid_assassin_of_lyssa = 1046
	Global Const $skillid_mesmer_of_lyssa = 1047
	Global Const $skillid_revealed_enchantment = 1048
	Global Const $skillid_revealed_hex = 1049
	Global Const $skillid_disciple_of_energy = 1050
	Global Const $skillid_accumulated_pain = 1052
	Global Const $skillid_psychic_distraction = 1053
	Global Const $skillid_ancestors_visage = 1054
	Global Const $skillid_recurring_insecurity = 1055
	Global Const $skillid_kitahs_burden = 1056
	Global Const $skillid_psychic_instability = 1057
	Global Const $skillid_chaotic_power = 1058
	Global Const $skillid_hex_eater_signet = 1059
	Global Const $skillid_celestial_haste = 1060
	Global Const $skillid_feedback = 1061
	Global Const $skillid_arcane_larceny = 1062
	Global Const $skillid_chaotic_ward = 1063
	Global Const $skillid_favor_of_the_gods = 1064
	Global Const $skillid_dark_aura_blessing = 1065
	Global Const $skillid_spoil_victor = 1066
	Global Const $skillid_lifebane_strike = 1067
	Global Const $skillid_bitter_chill = 1068
	Global Const $skillid_taste_of_pain = 1069
	Global Const $skillid_defile_enchantments = 1070
	Global Const $skillid_shivers_of_dread = 1071
	Global Const $skillid_star_servant = 1072
	Global Const $skillid_necromancer_of_grenth = 1073
	Global Const $skillid_ritualist_of_grenth = 1074
	Global Const $skillid_vampiric_swarm = 1075
	Global Const $skillid_blood_drinker = 1076
	Global Const $skillid_vampiric_bite = 1077
	Global Const $skillid_wallows_bite = 1078
	Global Const $skillid_enfeebling_touch = 1079
	Global Const $skillid_disciple_of_ice = 1080
	Global Const $skillid_teinais_wind = 1081
	Global Const $skillid_shock_arrow = 1082
	Global Const $skillid_unsteady_ground = 1083
	Global Const $skillid_sliver_armor = 1084
	Global Const $skillid_ash_blast = 1085
	Global Const $skillid_dragons_stomp = 1086
	Global Const $skillid_unnatural_resistance = 1087
	Global Const $skillid_second_wind = 1088
	Global Const $skillid_cloak_of_faith = 1089
	Global Const $skillid_smoldering_embers = 1090
	Global Const $skillid_double_dragon = 1091
	Global Const $skillid_disciple_of_the_air = 1092
	Global Const $skillid_teinais_heat = 1093
	Global Const $skillid_breath_of_fire = 1094
	Global Const $skillid_star_burst = 1095
	Global Const $skillid_glyph_of_essence = 1096
	Global Const $skillid_teinais_prison = 1097
	Global Const $skillid_mirror_of_ice = 1098
	Global Const $skillid_teinais_crystals = 1099
	Global Const $skillid_celestial_storm = 1100
	Global Const $skillid_monk_of_dwayna = 1101
	Global Const $skillid_aura_of_the_grove = 1102
	Global Const $skillid_cathedral_collapse = 1103
	Global Const $skillid_miasma = 1104
	Global Const $skillid_acid_trap = 1105
	Global Const $skillid_shield_of_saint_viktor = 1106
	Global Const $skillid_urn_of_saint_viktor = 1107
	Global Const $skillid_aura_of_light = 1112
	Global Const $skillid_kirins_wrath = 1113
	Global Const $skillid_spirit_bond = 1114
	Global Const $skillid_air_of_enchantment = 1115
	Global Const $skillid_warriors_might = 1116
	Global Const $skillid_heavens_delight = 1117
	Global Const $skillid_healing_burst = 1118
	Global Const $skillid_kareis_healing_circle = 1119
	Global Const $skillid_jameis_gaze = 1120
	Global Const $skillid_gift_of_health = 1121
	Global Const $skillid_battle_fervor = 1122
	Global Const $skillid_life_sheath = 1123
	Global Const $skillid_star_shine = 1124
	Global Const $skillid_disciple_of_fire = 1125
	Global Const $skillid_empathic_removal = 1126
	Global Const $skillid_warrior_of_balthazar = 1127
	Global Const $skillid_resurrection_chant = 1128
	Global Const $skillid_word_of_censure = 1129
	Global Const $skillid_spear_of_light = 1130
	Global Const $skillid_stonesoul_strike = 1131
	Global Const $skillid_shielding_branches = 1132
	Global Const $skillid_drunken_blow = 1133
	Global Const $skillid_leviathans_sweep = 1134
	Global Const $skillid_jaizhenju_strike = 1135
	Global Const $skillid_penetrating_chop = 1136
	Global Const $skillid_yeti_smash = 1137
	Global Const $skillid_disciple_of_the_earth = 1138
	Global Const $skillid_ranger_of_melandru = 1139
	Global Const $skillid_storm_of_swords = 1140
	Global Const $skillid_you_will_die = 1141
	Global Const $skillid_auspicious_parry = 1142
	Global Const $skillid_strength_of_the_oak = 1143
	Global Const $skillid_silverwing_slash = 1144
	Global Const $skillid_destroy_enchantment = 1145
	Global Const $skillid_shove = 1146
	Global Const $skillid_base_defense = 1147
	Global Const $skillid_carrier_defense = 1148
	Global Const $skillid_the_chalice_of_corruption = 1149
	Global Const $skillid_song_of_the_mists = 1151
	Global Const $skillid_demonic_agility = 1152
	Global Const $skillid_blessing_of_the_kirin = 1153
	Global Const $skillid_juggernaut_toss = 1155
	Global Const $skillid_aura_of_the_juggernaut = 1156
	Global Const $skillid_star_shards = 1157
	Global Const $skillid_turtle_shell = 1172
	Global Const $skillid_blood_of_zu_heltzer = 1175
	Global Const $skillid_afflicted_soul_explosion = 1176
	Global Const $skillid_dark_chain_lightning = 1179
	Global Const $skillid_corrupted_breath = 1181
	Global Const $skillid_renewing_corruption = 1182
	Global Const $skillid_corrupted_dragon_spores = 1183
	Global Const $skillid_corrupted_dragon_scales = 1184
	Global Const $skillid_construct_possession = 1185
	Global Const $skillid_siege_turtle_attack = 1186
	Global Const $skillid_of_royal_blood = 1189
	Global Const $skillid_passage_to_tahnnakai = 1190
	Global Const $skillid_sundering_attack = 1191
	Global Const $skillid_zojuns_shot = 1192
	Global Const $skillid_predatory_bond = 1194
	Global Const $skillid_heal_as_one = 1195
	Global Const $skillid_zojuns_haste = 1196
	Global Const $skillid_needling_shot = 1197
	Global Const $skillid_broad_head_arrow = 1198
	Global Const $skillid_glass_arrows = 1199
	Global Const $skillid_archers_signet = 1200
	Global Const $skillid_savage_pounce = 1201
	Global Const $skillid_enraged_lunge = 1202
	Global Const $skillid_bestial_mauling = 1203
	Global Const $skillid_energy_drain_effect = 1204
	Global Const $skillid_poisonous_bite = 1205
	Global Const $skillid_pounce = 1206
	Global Const $skillid_celestial_stance = 1207
	Global Const $skillid_sheer_exhaustion = 1208
	Global Const $skillid_bestial_fury = 1209
	Global Const $skillid_life_drain = 1210
	Global Const $skillid_vipers_nest = 1211
	Global Const $skillid_equinox = 1212
	Global Const $skillid_tranquility = 1213
	Global Const $skillid_clamor_of_souls = 1215
	Global Const $skillid_ritual_lord = 1217
	Global Const $skillid_cruel_was_daoshen = 1218
	Global Const $skillid_protective_was_kaolai = 1219
	Global Const $skillid_attuned_was_songkai = 1220
	Global Const $skillid_resilient_was_xiko = 1221
	Global Const $skillid_lively_was_naomei = 1222
	Global Const $skillid_anguished_was_lingwah = 1223
	Global Const $skillid_draw_spirit = 1224
	Global Const $skillid_channeled_strike = 1225
	Global Const $skillid_spirit_boon_strike = 1226
	Global Const $skillid_essence_strike = 1227
	Global Const $skillid_spirit_siphon = 1228
	Global Const $skillid_explosive_growth = 1229
	Global Const $skillid_boon_of_creation = 1230
	Global Const $skillid_spirit_channeling = 1231
	Global Const $skillid_armor_of_unfeeling = 1232
	Global Const $skillid_soothing_memories = 1233
	Global Const $skillid_mend_body_and_soul = 1234
	Global Const $skillid_dulled_weapon = 1235
	Global Const $skillid_binding_chains = 1236
	Global Const $skillid_painful_bond = 1237
	Global Const $skillid_signet_of_creation = 1238
	Global Const $skillid_signet_of_spirits = 1239
	Global Const $skillid_soul_twisting = 1240
	Global Const $skillid_celestial_summoning = 1241
	Global Const $skillid_ghostly_haste = 1244
	Global Const $skillid_gaze_from_beyond = 1245
	Global Const $skillid_ancestors_rage = 1246
	Global Const $skillid_pain = 1247
	Global Const $skillid_pain_attack = 1248
	Global Const $skillid_displacement = 1249
	Global Const $skillid_preservation = 1250
	Global Const $skillid_life = 1251
	Global Const $skillid_earthbind = 1252
	Global Const $skillid_bloodsong = 1253
	Global Const $skillid_bloodsong_attack = 1254
	Global Const $skillid_wanderlust = 1255
	Global Const $skillid_wanderlust_attack = 1256
	Global Const $skillid_spirit_light_weapon = 1257
	Global Const $skillid_brutal_weapon = 1258
	Global Const $skillid_guided_weapon = 1259
	Global Const $skillid_meekness = 1260
	Global Const $skillid_frigid_armor = 1261
	Global Const $skillid_healing_ring = 1262
	Global Const $skillid_renew_life = 1263
	Global Const $skillid_doom = 1264
	Global Const $skillid_wielders_boon = 1265
	Global Const $skillid_soothing = 1266
	Global Const $skillid_vital_weapon = 1267
	Global Const $skillid_weapon_of_quickening = 1268
	Global Const $skillid_signet_of_rage = 1269
	Global Const $skillid_fingers_of_chaos = 1270
	Global Const $skillid_echoing_banishment = 1271
	Global Const $skillid_suicidal_impulse = 1272
	Global Const $skillid_impossible_odds = 1273
	Global Const $skillid_battle_scars = 1274
	Global Const $skillid_riposting_shadows = 1275
	Global Const $skillid_meditation_of_the_reaper = 1276
	Global Const $skillid_blessed_water = 1280
	Global Const $skillid_defiled_water = 1281
	Global Const $skillid_stone_spores = 1282
	Global Const $skillid_haiju_lagoon_water = 1287
	Global Const $skillid_aspect_of_exhaustion = 1288
	Global Const $skillid_aspect_of_exposure = 1289
	Global Const $skillid_aspect_of_surrender = 1290
	Global Const $skillid_aspect_of_death = 1291
	Global Const $skillid_aspect_of_soothing = 1292
	Global Const $skillid_aspect_of_pain = 1293
	Global Const $skillid_aspect_of_lethargy = 1294
	Global Const $skillid_aspect_of_depletion_energy_loss = 1295
	Global Const $skillid_aspect_of_failure = 1296
	Global Const $skillid_aspect_of_shadows = 1297
	Global Const $skillid_scorpion_aspect = 1298
	Global Const $skillid_aspect_of_fear = 1299
	Global Const $skillid_aspect_of_depletion_energy_depletion_damage = 1300
	Global Const $skillid_aspect_of_decay = 1301
	Global Const $skillid_aspect_of_torment = 1302
	Global Const $skillid_nightmare_aspect = 1303
	Global Const $skillid_spiked_coral = 1304
	Global Const $skillid_shielding_urn = 1305
	Global Const $skillid_extensive_plague_exposure = 1306
	Global Const $skillid_forests_binding = 1307
	Global Const $skillid_exploding_spores = 1308
	Global Const $skillid_suicide_energy = 1309
	Global Const $skillid_suicide_health = 1310
	Global Const $skillid_nightmare_refuge = 1311
	Global Const $skillid_rage_of_the_sea = 1315
	Global Const $skillid_sugar_rush = 1323
	Global Const $skillid_torment_slash = 1324
	Global Const $skillid_spirit_of_the_festival = 1325
	Global Const $skillid_trade_winds = 1326
	Global Const $skillid_dragon_blast = 1327
	Global Const $skillid_imperial_majesty = 1328
	Global Const $skillid_extend_conditions = 1333
	Global Const $skillid_hypochondria = 1334
	Global Const $skillid_wastrels_demise = 1335
	Global Const $skillid_spiritual_pain = 1336
	Global Const $skillid_drain_delusions = 1337
	Global Const $skillid_persistence_of_memory = 1338
	Global Const $skillid_symbols_of_inspiration = 1339
	Global Const $skillid_symbolic_celerity = 1340
	Global Const $skillid_frustration = 1341
	Global Const $skillid_tease = 1342
	Global Const $skillid_ether_phantom = 1343
	Global Const $skillid_web_of_disruption = 1344
	Global Const $skillid_enchanters_conundrum = 1345
	Global Const $skillid_signet_of_illusions = 1346
	Global Const $skillid_discharge_enchantment = 1347
	Global Const $skillid_hex_eater_vortex = 1348
	Global Const $skillid_mirror_of_disenchantment = 1349
	Global Const $skillid_simple_thievery = 1350
	Global Const $skillid_animate_shambling_horror = 1351
	Global Const $skillid_order_of_undeath = 1352
	Global Const $skillid_putrid_flesh = 1353
	Global Const $skillid_feast_for_the_dead = 1354
	Global Const $skillid_jagged_bones = 1355
	Global Const $skillid_contagion = 1356
	Global Const $skillid_ulcerous_lungs = 1358
	Global Const $skillid_pain_of_disenchantment = 1359
	Global Const $skillid_mark_of_fury = 1360
	Global Const $skillid_corrupt_enchantment = 1362
	Global Const $skillid_signet_of_sorrow = 1363
	Global Const $skillid_signet_of_suffering = 1364
	Global Const $skillid_signet_of_lost_souls = 1365
	Global Const $skillid_well_of_darkness = 1366
	Global Const $skillid_blinding_surge = 1367
	Global Const $skillid_chilling_winds = 1368
	Global Const $skillid_lightning_bolt = 1369
	Global Const $skillid_storm_djinns_haste = 1370
	Global Const $skillid_stone_striker = 1371
	Global Const $skillid_sandstorm = 1372
	Global Const $skillid_stone_sheath = 1373
	Global Const $skillid_ebon_hawk = 1374
	Global Const $skillid_stoneflesh_aura = 1375
	Global Const $skillid_glyph_of_restoration = 1376
	Global Const $skillid_ether_prism = 1377
	Global Const $skillid_master_of_magic = 1378
	Global Const $skillid_glowing_gaze = 1379
	Global Const $skillid_savannah_heat = 1380
	Global Const $skillid_flame_djinns_haste = 1381
	Global Const $skillid_freezing_gust = 1382
	Global Const $skillid_sulfurous_haze = 1384
	Global Const $skillid_sentry_trap_skill = 1386
	Global Const $skillid_judges_intervention = 1390
	Global Const $skillid_supportive_spirit = 1391
	Global Const $skillid_watchful_healing = 1392
	Global Const $skillid_healers_boon = 1393
	Global Const $skillid_healers_covenant = 1394
	Global Const $skillid_balthazars_pendulum = 1395
	Global Const $skillid_words_of_comfort = 1396
	Global Const $skillid_light_of_deliverance = 1397
	Global Const $skillid_scourge_enchantment = 1398
	Global Const $skillid_shield_of_absorption = 1399
	Global Const $skillid_reversal_of_damage = 1400
	Global Const $skillid_mending_touch = 1401
	Global Const $skillid_critical_chop = 1402
	Global Const $skillid_agonizing_chop = 1403
	Global Const $skillid_flail = 1404
	Global Const $skillid_charging_strike = 1405
	Global Const $skillid_headbutt = 1406
	Global Const $skillid_lions_comfort = 1407
	Global Const $skillid_rage_of_the_ntouka = 1408
	Global Const $skillid_mokele_smash = 1409
	Global Const $skillid_overbearing_smash = 1410
	Global Const $skillid_signet_of_stamina = 1411
	Global Const $skillid_youre_all_alone = 1412
	Global Const $skillid_burst_of_aggression = 1413
	Global Const $skillid_enraging_charge = 1414
	Global Const $skillid_crippling_slash = 1415
	Global Const $skillid_barbarous_slice = 1416
	Global Const $skillid_vial_of_purified_water = 1417
	Global Const $skillid_disarm_trap = 1418
	Global Const $skillid_feeding_frenzy_skill = 1419
	Global Const $skillid_quake_of_ahdashim = 1420
	Global Const $skillid_create_light_of_seborhin = 1422
	Global Const $skillid_unlock_cell = 1423
	Global Const $skillid_wave_of_torment = 1430
	Global Const $skillid_corsairs_net = 1433
	Global Const $skillid_corrupted_healing = 1434
	Global Const $skillid_corrupted_strength = 1436
	Global Const $skillid_desert_wurm_disguise = 1437
	Global Const $skillid_junundu_feast = 1438
	Global Const $skillid_junundu_strike = 1439
	Global Const $skillid_junundu_smash = 1440
	Global Const $skillid_junundu_siege = 1441
	Global Const $skillid_junundu_tunnel = 1442
	Global Const $skillid_leave_junundu = 1443
	Global Const $skillid_summon_torment = 1444
	Global Const $skillid_signal_flare = 1445
	Global Const $skillid_the_elixir_of_strength = 1446
	Global Const $skillid_ehzah_from_above = 1447
	Global Const $skillid_last_rites_of_torment = 1449
	Global Const $skillid_abaddons_conspiracy = 1450
	Global Const $skillid_hungers_bite = 1451
	Global Const $skillid_call_to_the_torment = 1454
	Global Const $skillid_command_of_torment = 1455
	Global Const $skillid_abaddons_favor = 1456
	Global Const $skillid_abaddons_chosen = 1457
	Global Const $skillid_enchantment_collapse = 1458
	Global Const $skillid_call_of_sacrifice = 1459
	Global Const $skillid_enemies_must_die = 1460
	Global Const $skillid_earth_vortex = 1461
	Global Const $skillid_frost_vortex = 1462
	Global Const $skillid_rough_current = 1463
	Global Const $skillid_turbulent_flow = 1464
	Global Const $skillid_prepared_shot = 1465
	Global Const $skillid_burning_arrow = 1466
	Global Const $skillid_arcing_shot = 1467
	Global Const $skillid_strike_as_one = 1468
	Global Const $skillid_crossfire = 1469
	Global Const $skillid_barbed_arrows = 1470
	Global Const $skillid_scavengers_focus = 1471
	Global Const $skillid_toxicity = 1472
	Global Const $skillid_quicksand = 1473
	Global Const $skillid_storms_embrace = 1474
	Global Const $skillid_trappers_speed = 1475
	Global Const $skillid_tripwire = 1476
	Global Const $skillid_kournan_guardsman_uniform = 1477
	Global Const $skillid_renewing_surge = 1478
	Global Const $skillid_offering_of_spirit = 1479
	Global Const $skillid_spirits_gift = 1480
	Global Const $skillid_death_pact_signet = 1481
	Global Const $skillid_reclaim_essence = 1482
	Global Const $skillid_banishing_strike = 1483
	Global Const $skillid_mystic_sweep = 1484
	Global Const $skillid_eremites_attack = 1485
	Global Const $skillid_reap_impurities = 1486
	Global Const $skillid_twin_moon_sweep = 1487
	Global Const $skillid_victorious_sweep = 1488
	Global Const $skillid_irresistible_sweep = 1489
	Global Const $skillid_pious_assault = 1490
	Global Const $skillid_mystic_twister = 1491
	Global Const $skillid_grenths_fingers = 1493
	Global Const $skillid_aura_of_thorns = 1495
	Global Const $skillid_balthazars_rage = 1496
	Global Const $skillid_dust_cloak = 1497
	Global Const $skillid_staggering_force = 1498
	Global Const $skillid_pious_renewal = 1499
	Global Const $skillid_mirage_cloak = 1500
	Global Const $skillid_arcane_zeal = 1502
	Global Const $skillid_mystic_vigor = 1503
	Global Const $skillid_watchful_intervention = 1504
	Global Const $skillid_vow_of_piety = 1505
	Global Const $skillid_vital_boon = 1506
	Global Const $skillid_heart_of_holy_flame = 1507
	Global Const $skillid_extend_enchantments = 1508
	Global Const $skillid_faithful_intervention = 1509
	Global Const $skillid_sand_shards = 1510
	Global Const $skillid_lyssas_haste = 1512
	Global Const $skillid_guiding_hands = 1513
	Global Const $skillid_fleeting_stability = 1514
	Global Const $skillid_armor_of_sanctity = 1515
	Global Const $skillid_mystic_regeneration = 1516
	Global Const $skillid_vow_of_silence = 1517
	Global Const $skillid_avatar_of_balthazar = 1518
	Global Const $skillid_avatar_of_dwayna = 1519
	Global Const $skillid_avatar_of_grenth = 1520
	Global Const $skillid_avatar_of_lyssa = 1521
	Global Const $skillid_avatar_of_melandru = 1522
	Global Const $skillid_meditation = 1523
	Global Const $skillid_eremites_zeal = 1524
	Global Const $skillid_natural_healing = 1525
	Global Const $skillid_imbue_health = 1526
	Global Const $skillid_mystic_healing = 1527
	Global Const $skillid_dwaynas_touch = 1528
	Global Const $skillid_pious_restoration = 1529
	Global Const $skillid_signet_of_pious_light = 1530
	Global Const $skillid_intimidating_aura = 1531
	Global Const $skillid_mystic_sandstorm = 1532
	Global Const $skillid_winds_of_disenchantment = 1533
	Global Const $skillid_rending_touch = 1534
	Global Const $skillid_crippling_sweep = 1535
	Global Const $skillid_wounding_strike = 1536
	Global Const $skillid_wearying_strike = 1537
	Global Const $skillid_lyssas_assault = 1538
	Global Const $skillid_chilling_victory = 1539
	Global Const $skillid_conviction = 1540
	Global Const $skillid_enchanted_haste = 1541
	Global Const $skillid_pious_concentration = 1542
	Global Const $skillid_pious_haste = 1543
	Global Const $skillid_whirling_charge = 1544
	Global Const $skillid_test_of_faith = 1545
	Global Const $skillid_blazing_spear = 1546
	Global Const $skillid_mighty_throw = 1547
	Global Const $skillid_cruel_spear = 1548
	Global Const $skillid_harriers_toss = 1549
	Global Const $skillid_unblockable_throw = 1550
	Global Const $skillid_spear_of_lightning = 1551
	Global Const $skillid_wearying_spear = 1552
	Global Const $skillid_anthem_of_fury = 1553
	Global Const $skillid_crippling_anthem = 1554
	Global Const $skillid_defensive_anthem = 1555
	Global Const $skillid_godspeed = 1556
	Global Const $skillid_anthem_of_flame = 1557
	Global Const $skillid_go_for_the_eyes = 1558
	Global Const $skillid_anthem_of_envy = 1559
	Global Const $skillid_song_of_power = 1560
	Global Const $skillid_zealous_anthem = 1561
	Global Const $skillid_aria_of_zeal = 1562
	Global Const $skillid_lyric_of_zeal = 1563
	Global Const $skillid_ballad_of_restoration = 1564
	Global Const $skillid_chorus_of_restoration = 1565
	Global Const $skillid_aria_of_restoration = 1566
	Global Const $skillid_song_of_concentration = 1567
	Global Const $skillid_anthem_of_guidance = 1568
	Global Const $skillid_energizing_chorus = 1569
	Global Const $skillid_song_of_purification = 1570
	Global Const $skillid_hexbreaker_aria = 1571
	Global Const $skillid_brace_yourself = 1572
	Global Const $skillid_awe = 1573
	Global Const $skillid_enduring_harmony = 1574
	Global Const $skillid_blazing_finale = 1575
	Global Const $skillid_burning_refrain = 1576
	Global Const $skillid_finale_of_restoration = 1577
	Global Const $skillid_mending_refrain = 1578
	Global Const $skillid_purifying_finale = 1579
	Global Const $skillid_bladeturn_refrain = 1580
	Global Const $skillid_glowing_signet = 1581
	Global Const $skillid_leaders_zeal = 1583
	Global Const $skillid_leaders_comfort = 1584
	Global Const $skillid_signet_of_synergy = 1585
	Global Const $skillid_angelic_protection = 1586
	Global Const $skillid_angelic_bond = 1587
	Global Const $skillid_cautery_signet = 1588
	Global Const $skillid_stand_your_ground = 1589
	Global Const $skillid_lead_the_way = 1590
	Global Const $skillid_make_haste = 1591
	Global Const $skillid_we_shall_return = 1592
	Global Const $skillid_never_give_up = 1593
	Global Const $skillid_help_me = 1594
	Global Const $skillid_fall_back = 1595
	Global Const $skillid_incoming = 1596
	Global Const $skillid_theyre_on_fire = 1597
	Global Const $skillid_never_surrender = 1598
	Global Const $skillid_its_just_a_flesh_wound = 1599
	Global Const $skillid_barbed_spear = 1600
	Global Const $skillid_vicious_attack = 1601
	Global Const $skillid_stunning_strike = 1602
	Global Const $skillid_merciless_spear = 1603
	Global Const $skillid_disrupting_throw = 1604
	Global Const $skillid_wild_throw = 1605
	Global Const $skillid_curse_of_the_staff_of_the_mists = 1606
	Global Const $skillid_aura_of_the_staff_of_the_mists = 1607
	Global Const $skillid_power_of_the_staff_of_the_mists = 1608
	Global Const $skillid_scepter_of_ether = 1609
	Global Const $skillid_summoning_of_the_scepter = 1610
	Global Const $skillid_rise_from_your_grave = 1611
	Global Const $skillid_corsair_disguise = 1613
	Global Const $skillid_queen_heal = 1616
	Global Const $skillid_queen_wail = 1617
	Global Const $skillid_queen_armor = 1618
	Global Const $skillid_queen_bite = 1619
	Global Const $skillid_queen_thump = 1620
	Global Const $skillid_queen_siege = 1621
	Global Const $skillid_dervish_of_the_mystic = 1624
	Global Const $skillid_dervish_of_the_wind = 1625
	Global Const $skillid_paragon_of_leadership = 1626
	Global Const $skillid_paragon_of_motivation = 1627
	Global Const $skillid_dervish_of_the_blade = 1628
	Global Const $skillid_paragon_of_command = 1629
	Global Const $skillid_paragon_of_the_spear = 1630
	Global Const $skillid_dervish_of_the_earth = 1631
	Global Const $skillid_malicious_strike = 1633
	Global Const $skillid_shattering_assault = 1634
	Global Const $skillid_golden_skull_strike = 1635
	Global Const $skillid_black_spider_strike = 1636
	Global Const $skillid_golden_fox_strike = 1637
	Global Const $skillid_deadly_haste = 1638
	Global Const $skillid_assassins_remedy = 1639
	Global Const $skillid_foxs_promise = 1640
	Global Const $skillid_feigned_neutrality = 1641
	Global Const $skillid_hidden_caltrops = 1642
	Global Const $skillid_assault_enchantments = 1643
	Global Const $skillid_wastrels_collapse = 1644
	Global Const $skillid_lift_enchantment = 1645
	Global Const $skillid_augury_of_death = 1646
	Global Const $skillid_signet_of_toxic_shock = 1647
	Global Const $skillid_signet_of_twilight = 1648
	Global Const $skillid_way_of_the_assassin = 1649
	Global Const $skillid_shadow_walk = 1650
	Global Const $skillid_deaths_retreat = 1651
	Global Const $skillid_shadow_prison = 1652
	Global Const $skillid_swap = 1653
	Global Const $skillid_shadow_meld = 1654
	Global Const $skillid_price_of_pride = 1655
	Global Const $skillid_air_of_disenchantment = 1656
	Global Const $skillid_signet_of_clumsiness = 1657
	Global Const $skillid_symbolic_posture = 1658
	Global Const $skillid_toxic_chill = 1659
	Global Const $skillid_well_of_silence = 1660
	Global Const $skillid_glowstone = 1661
	Global Const $skillid_mind_blast = 1662
	Global Const $skillid_elemental_flame = 1663
	Global Const $skillid_invoke_lightning = 1664
	Global Const $skillid_battle_cry = 1665
	Global Const $skillid_energy_shrine_bonus = 1667
	Global Const $skillid_northern_health_shrine_bonus = 1668
	Global Const $skillid_southern_health_shrine_bonus = 1669
	Global Const $skillid_curse_of_silence = 1671
	Global Const $skillid_to_the_pain_hero_battles = 1672
	Global Const $skillid_edge_of_reason = 1673
	Global Const $skillid_depths_of_madness_environment_effect = 1674
	Global Const $skillid_cower_in_fear = 1675
	Global Const $skillid_dreadful_pain = 1676
	Global Const $skillid_veiled_nightmare = 1677
	Global Const $skillid_base_protection = 1678
	Global Const $skillid_kournan_siege_flame = 1679
	Global Const $skillid_drake_skin = 1680
	Global Const $skillid_skale_vigor = 1681
	Global Const $skillid_pahnai_salad_item_effect = 1682
	Global Const $skillid_pensive_guardian = 1683
	Global Const $skillid_scribes_insight = 1684
	Global Const $skillid_holy_haste = 1685
	Global Const $skillid_glimmer_of_light = 1686
	Global Const $skillid_zealous_benediction = 1687
	Global Const $skillid_defenders_zeal = 1688
	Global Const $skillid_signet_of_mystic_wrath = 1689
	Global Const $skillid_signet_of_removal = 1690
	Global Const $skillid_dismiss_condition = 1691
	Global Const $skillid_divert_hexes = 1692
	Global Const $skillid_counterattack = 1693
	Global Const $skillid_magehunter_strike = 1694
	Global Const $skillid_soldiers_strike = 1695
	Global Const $skillid_decapitate = 1696
	Global Const $skillid_magehunters_smash = 1697
	Global Const $skillid_soldiers_stance = 1698
	Global Const $skillid_soldiers_defense = 1699
	Global Const $skillid_frenzied_defense = 1700
	Global Const $skillid_steady_stance = 1701
	Global Const $skillid_steelfang_slash = 1702
	Global Const $skillid_sunspear_battle_call = 1703
	Global Const $skillid_earth_shattering_blow = 1705
	Global Const $skillid_corrupt_power = 1706
	Global Const $skillid_words_of_madness = 1707
	Global Const $skillid_gaze_of_moavukaal = 1708
	Global Const $skillid_presence_of_the_skale_lord = 1709
	Global Const $skillid_madness_dart = 1710
	Global Const $skillid_reform_carvings = 1715
	Global Const $skillid_sunspear_siege = 1717
	Global Const $skillid_soul_torture = 1718
	Global Const $skillid_screaming_shot = 1719
	Global Const $skillid_keen_arrow = 1720
	Global Const $skillid_rampage_as_one = 1721
	Global Const $skillid_forked_arrow = 1722
	Global Const $skillid_disrupting_accuracy = 1723
	Global Const $skillid_experts_dexterity = 1724
	Global Const $skillid_roaring_winds = 1725
	Global Const $skillid_magebane_shot = 1726
	Global Const $skillid_natural_stride = 1727
	Global Const $skillid_hekets_rampage = 1728
	Global Const $skillid_smoke_trap = 1729
	Global Const $skillid_infuriating_heat = 1730
	Global Const $skillid_vocal_was_sogolon = 1731
	Global Const $skillid_destructive_was_glaive = 1732
	Global Const $skillid_wielders_strike = 1733
	Global Const $skillid_gaze_of_fury = 1734
	Global Const $skillid_gaze_of_fury_attack = 1735
	Global Const $skillid_spirits_strength = 1736
	Global Const $skillid_wielders_zeal = 1737
	Global Const $skillid_sight_beyond_sight = 1738
	Global Const $skillid_renewing_memories = 1739
	Global Const $skillid_wielders_remedy = 1740
	Global Const $skillid_ghostmirror_light = 1741
	Global Const $skillid_signet_of_ghostly_might = 1742
	Global Const $skillid_signet_of_binding = 1743
	Global Const $skillid_caretakers_charge = 1744
	Global Const $skillid_anguish = 1745
	Global Const $skillid_anguish_attack = 1746
	Global Const $skillid_empowerment = 1747
	Global Const $skillid_recovery = 1748
	Global Const $skillid_weapon_of_fury = 1749
	Global Const $skillid_xinraes_weapon = 1750
	Global Const $skillid_warmongers_weapon = 1751
	Global Const $skillid_weapon_of_remedy = 1752
	Global Const $skillid_rending_sweep = 1753
	Global Const $skillid_onslaught = 1754
	Global Const $skillid_mystic_corruption = 1755
	Global Const $skillid_grenths_grasp = 1756
	Global Const $skillid_veil_of_thorns = 1757
	Global Const $skillid_harriers_grasp = 1758
	Global Const $skillid_vow_of_strength = 1759
	Global Const $skillid_ebon_dust_aura = 1760
	Global Const $skillid_zealous_vow = 1761
	Global Const $skillid_heart_of_fury = 1762
	Global Const $skillid_zealous_renewal = 1763
	Global Const $skillid_attackers_insight = 1764
	Global Const $skillid_rending_aura = 1765
	Global Const $skillid_featherfoot_grace = 1766
	Global Const $skillid_reapers_sweep = 1767
	Global Const $skillid_harriers_haste = 1768
	Global Const $skillid_focused_anger = 1769
	Global Const $skillid_natural_temper = 1770
	Global Const $skillid_song_of_restoration = 1771
	Global Const $skillid_lyric_of_purification = 1772
	Global Const $skillid_soldiers_fury = 1773
	Global Const $skillid_aggressive_refrain = 1774
	Global Const $skillid_energizing_finale = 1775
	Global Const $skillid_signet_of_aggression = 1776
	Global Const $skillid_remedy_signet = 1777
	Global Const $skillid_signet_of_return = 1778
	Global Const $skillid_make_your_time = 1779
	Global Const $skillid_cant_touch_this = 1780
	Global Const $skillid_find_their_weakness = 1781
	Global Const $skillid_the_power_is_yours = 1782
	Global Const $skillid_slayers_spear = 1783
	Global Const $skillid_swift_javelin = 1784
	Global Const $skillid_skale_hunt = 1790
	Global Const $skillid_mandragor_hunt = 1791
	Global Const $skillid_skree_battle = 1792
	Global Const $skillid_insect_hunt = 1793
	Global Const $skillid_corsair_bounty = 1794
	Global Const $skillid_plant_hunt = 1795
	Global Const $skillid_undead_hunt = 1796
	Global Const $skillid_eternal_suffering = 1797
	Global Const $skillid_eternal_languor = 1800
	Global Const $skillid_eternal_lethargy = 1803
	Global Const $skillid_thirst_of_the_drought = 1808
	Global Const $skillid_lightbringer = 1813
	Global Const $skillid_lightbringers_gaze = 1814
	Global Const $skillid_lightbringer_signet = 1815
	Global Const $skillid_sunspear_rebirth_signet = 1816
	Global Const $skillid_wisdom = 1817
	Global Const $skillid_maddened_strike = 1818
	Global Const $skillid_maddened_stance = 1819
	Global Const $skillid_spirit_form = 1820
	Global Const $skillid_monster_hunt = 1822
	Global Const $skillid_elemental_hunt = 1826
	Global Const $skillid_demon_hunt = 1831
	Global Const $skillid_minotaur_hunt = 1832
	Global Const $skillid_heket_hunt = 1837
	Global Const $skillid_kournan_bounty = 1839
	Global Const $skillid_dhuum_battle = 1844
	Global Const $skillid_menzies_battle = 1845
	Global Const $skillid_monolith_hunt = 1847
	Global Const $skillid_margonite_battle = 1849
	Global Const $skillid_titan_hunt = 1851
	Global Const $skillid_giant_hunt = 1853
	Global Const $skillid_kournan_siege = 1855
	Global Const $skillid_lose_your_head = 1856
	Global Const $skillid_altar_buff = 1859
	Global Const $skillid_choking_breath = 1861
	Global Const $skillid_junundu_bite = 1862
	Global Const $skillid_blinding_breath = 1863
	Global Const $skillid_burning_breath = 1864
	Global Const $skillid_junundu_wail = 1865
	Global Const $skillid_capture_point = 1866
	Global Const $skillid_approaching_the_vortex = 1867
	Global Const $skillid_avatar_of_sweetness = 1871
	Global Const $skillid_corrupted_lands = 1873
	Global Const $skillid_unknown_junundu_ability = 1876
	Global Const $skillid_torment_slash_smothering_tendrils = 1880
	Global Const $skillid_bonds_of_torment = 1881
	Global Const $skillid_shadow_smash = 1882
	Global Const $skillid_consume_torment = 1884
	Global Const $skillid_banish_enchantment = 1885
	Global Const $skillid_summoning_shadows = 1886
	Global Const $skillid_lightbringers_insight = 1887
	Global Const $skillid_repressive_energy = 1889
	Global Const $skillid_enduring_torment = 1890
	Global Const $skillid_shroud_of_darkness = 1891
	Global Const $skillid_demonic_miasma = 1892
	Global Const $skillid_enraged = 1893
	Global Const $skillid_touch_of_aaaaarrrrrrggghhh = 1894
	Global Const $skillid_wild_smash = 1895
	Global Const $skillid_unyielding_anguish = 1896
	Global Const $skillid_jadoths_storm_of_judgment = 1897
	Global Const $skillid_anguish_hunt = 1898
	Global Const $skillid_avatar_of_holiday_cheer = 1899
	Global Const $skillid_side_step = 1900
	Global Const $skillid_jack_frost = 1901
	Global Const $skillid_avatar_of_grenth_snow_fighting_skill = 1902
	Global Const $skillid_avatar_of_dwayna_snow_fighting_skill = 1903
	Global Const $skillid_steady_aim = 1904
	Global Const $skillid_rudis_red_nose = 1905
	Global Const $skillid_volatile_charr_crystal = 1911
	Global Const $skillid_hard_mode = 1912
	Global Const $skillid_sugar_jolt = 1916
	Global Const $skillid_rollerbeetle_racer = 1917
	Global Const $skillid_ram = 1918
	Global Const $skillid_harden_shell = 1919
	Global Const $skillid_rollerbeetle_dash = 1920
	Global Const $skillid_super_rollerbeetle = 1921
	Global Const $skillid_rollerbeetle_echo = 1922
	Global Const $skillid_distracting_lunge = 1923
	Global Const $skillid_rollerbeetle_blast = 1924
	Global Const $skillid_spit_rocks = 1925
	Global Const $skillid_lunar_blessing = 1926
	Global Const $skillid_lucky_aura = 1927
	Global Const $skillid_spiritual_possession = 1928
	Global Const $skillid_water = 1929
	Global Const $skillid_pig_form = 1930
	Global Const $skillid_beetle_metamorphosis = 1931
	Global Const $skillid_golden_egg_item_effect = 1934
	Global Const $skillid_infernal_rage = 1937
	Global Const $skillid_putrid_flames = 1938
	Global Const $skillid_flame_call = 1940
	Global Const $skillid_whirling_fires = 1942
	Global Const $skillid_charr_siege_attack_what_must_be_done = 1943
	Global Const $skillid_charr_siege_attack_against_the_charr = 1944
	Global Const $skillid_birthday_cupcake_skill = 1945
	Global Const $skillid_blessing_of_the_luxons = 1947
	Global Const $skillid_shadow_sanctuary = 1948
	Global Const $skillid_ether_nightmare = 1949
	Global Const $skillid_signet_of_corruption = 1950
	Global Const $skillid_elemental_lord = 1951
	Global Const $skillid_selfless_spirit = 1952
	Global Const $skillid_triple_shot = 1953
	Global Const $skillid_save_yourselves = 1954
	Global Const $skillid_aura_of_holy_might = 1955
	Global Const $skillid_spear_of_fury = 1957
	Global Const $skillid_fire_dart = 1983
	Global Const $skillid_ice_dart = 1984
	Global Const $skillid_poison_dart = 1985
	Global Const $skillid_vampiric_assault = 1986
	Global Const $skillid_lotus_strike = 1987
	Global Const $skillid_golden_fang_strike = 1988
	Global Const $skillid_falling_lotus_strike = 1990
	Global Const $skillid_sadists_signet = 1991
	Global Const $skillid_signet_of_distraction = 1992
	Global Const $skillid_signet_of_recall = 1993
	Global Const $skillid_power_lock = 1994
	Global Const $skillid_waste_not_want_not = 1995
	Global Const $skillid_sum_of_all_fears = 1996
	Global Const $skillid_withering_aura = 1997
	Global Const $skillid_cacophony = 1998
	Global Const $skillid_winters_embrace = 1999
	Global Const $skillid_earthen_shackles = 2000
	Global Const $skillid_ward_of_weakness = 2001
	Global Const $skillid_glyph_of_swiftness = 2002
	Global Const $skillid_cure_hex = 2003
	Global Const $skillid_smite_condition = 2004
	Global Const $skillid_smiters_boon = 2005
	Global Const $skillid_castigation_signet = 2006
	Global Const $skillid_purifying_veil = 2007
	Global Const $skillid_pulverizing_smash = 2008
	Global Const $skillid_keen_chop = 2009
	Global Const $skillid_knee_cutter = 2010
	Global Const $skillid_grapple = 2011
	Global Const $skillid_radiant_scythe = 2012
	Global Const $skillid_grenths_aura = 2013
	Global Const $skillid_signet_of_pious_restraint = 2014
	Global Const $skillid_farmers_scythe = 2015
	Global Const $skillid_energetic_was_lee_sa = 2016
	Global Const $skillid_anthem_of_weariness = 2017
	Global Const $skillid_anthem_of_disruption = 2018
	Global Const $skillid_freezing_ground = 2020
	Global Const $skillid_fire_jet = 2022
	Global Const $skillid_ice_jet = 2023
	Global Const $skillid_poison_jet = 2024
	Global Const $skillid_fire_spout = 2027
	Global Const $skillid_ice_spout = 2028
	Global Const $skillid_poison_spout = 2029
	Global Const $skillid_summon_spirits = 2051
	Global Const $skillid_shadow_fang = 2052
	Global Const $skillid_calculated_risk = 2053
	Global Const $skillid_shrinking_armor = 2054
	Global Const $skillid_aneurysm = 2055
	Global Const $skillid_wandering_eye = 2056
	Global Const $skillid_foul_feast = 2057
	Global Const $skillid_putrid_bile = 2058
	Global Const $skillid_shell_shock = 2059
	Global Const $skillid_glyph_of_immolation = 2060
	Global Const $skillid_patient_spirit = 2061
	Global Const $skillid_healing_ribbon = 2062
	Global Const $skillid_aura_of_stability = 2063
	Global Const $skillid_spotless_mind = 2064
	Global Const $skillid_spotless_soul = 2065
	Global Const $skillid_disarm = 2066
	Global Const $skillid_i_meant_to_do_that = 2067
	Global Const $skillid_rapid_fire = 2068
	Global Const $skillid_sloth_hunters_shot = 2069
	Global Const $skillid_aura_slicer = 2070
	Global Const $skillid_zealous_sweep = 2071
	Global Const $skillid_pure_was_li_ming = 2072
	Global Const $skillid_weapon_of_aggression = 2073
	Global Const $skillid_chest_thumper = 2074
	Global Const $skillid_hasty_refrain = 2075
	Global Const $skillid_cracked_armor = 2077
	Global Const $skillid_berserk = 2078
	Global Const $skillid_fleshreavers_escape = 2079
	Global Const $skillid_chomp = 2080
	Global Const $skillid_twisting_jaws = 2081
	Global Const $skillid_mandragors_charge = 2083
	Global Const $skillid_rock_slide = 2084
	Global Const $skillid_avalanche_effect = 2085
	Global Const $skillid_snaring_web = 2086
	Global Const $skillid_ceiling_collapse = 2087
	Global Const $skillid_trample = 2088
	Global Const $skillid_wurm_bile = 2089
	Global Const $skillid_critical_agility = 2101
	Global Const $skillid_cry_of_pain = 2102
	Global Const $skillid_necrosis = 2103
	Global Const $skillid_intensity = 2104
	Global Const $skillid_seed_of_life = 2105
	Global Const $skillid_call_of_the_eye = 2106
	Global Const $skillid_whirlwind_attack = 2107
	Global Const $skillid_never_rampage_alone = 2108
	Global Const $skillid_eternal_aura = 2109
	Global Const $skillid_vampirism = 2110
	Global Const $skillid_vampirism_attack = 2111
	Global Const $skillid_theres_nothing_to_fear = 2112
	Global Const $skillid_ursan_rage_blood_washes_blood = 2113
	Global Const $skillid_ursan_strike_blood_washes_blood = 2114
	Global Const $skillid_sneak_attack = 2116
	Global Const $skillid_firebomb_explosion = 2117
	Global Const $skillid_firebomb = 2118
	Global Const $skillid_shield_of_fire = 2119
	Global Const $skillid_spirit_world_retreat = 2122
	Global Const $skillid_shattered_spirit = 2124
	Global Const $skillid_spirit_roar = 2125
	Global Const $skillid_spirit_senses = 2126
	Global Const $skillid_unseen_aggression = 2127
	Global Const $skillid_volfen_pounce_curse_of_the_nornbear = 2128
	Global Const $skillid_volfen_claw_curse_of_the_nornbear = 2129
	Global Const $skillid_volfen_bloodlust_curse_of_the_nornbear = 2131
	Global Const $skillid_volfen_agility_curse_of_the_nornbear = 2132
	Global Const $skillid_volfen_blessing_curse_of_the_nornbear = 2133
	Global Const $skillid_charging_spirit = 2134
	Global Const $skillid_trampling_ox = 2135
	Global Const $skillid_smoke_powder_defense = 2136
	Global Const $skillid_confusing_images = 2137
	Global Const $skillid_hexers_vigor = 2138
	Global Const $skillid_masochism = 2139
	Global Const $skillid_piercing_trap = 2140
	Global Const $skillid_companionship = 2141
	Global Const $skillid_feral_aggression = 2142
	Global Const $skillid_disrupting_shot = 2143
	Global Const $skillid_volley = 2144
	Global Const $skillid_expert_focus = 2145
	Global Const $skillid_pious_fury = 2146
	Global Const $skillid_crippling_victory = 2147
	Global Const $skillid_sundering_weapon = 2148
	Global Const $skillid_weapon_of_renewal = 2149
	Global Const $skillid_maiming_spear = 2150
	Global Const $skillid_temporal_sheen = 2151
	Global Const $skillid_flux_overload = 2152
	Global Const $skillid_phase_shield_effect = 2154
	Global Const $skillid_phase_shield = 2155
	Global Const $skillid_vitality_transfer = 2156
	Global Const $skillid_golem_strike = 2157
	Global Const $skillid_bloodstone_slash = 2158
	Global Const $skillid_energy_blast_golem = 2159
	Global Const $skillid_chaotic_energy = 2160
	Global Const $skillid_golem_fire_shield = 2161
	Global Const $skillid_the_way_of_duty = 2162
	Global Const $skillid_the_way_of_kinship = 2163
	Global Const $skillid_diamondshard_mist_environment_effect = 2164
	Global Const $skillid_diamondshard_grave = 2165
	Global Const $skillid_the_way_of_strength = 2166
	Global Const $skillid_diamondshard_mist = 2167
	Global Const $skillid_raven_blessing_a_gate_too_far = 2168
	Global Const $skillid_raven_flight_a_gate_too_far = 2170
	Global Const $skillid_raven_shriek_a_gate_too_far = 2171
	Global Const $skillid_raven_swoop_a_gate_too_far = 2172
	Global Const $skillid_raven_talons_a_gate_too_far = 2173
	Global Const $skillid_aspect_of_oak = 2174
	Global Const $skillid_tremor = 2176
	Global Const $skillid_pyroclastic_shot = 2180
	Global Const $skillid_rolling_shift = 2184
	Global Const $skillid_powder_keg_explosion = 2185
	Global Const $skillid_signet_of_deadly_corruption = 2186
	Global Const $skillid_way_of_the_master = 2187
	Global Const $skillid_defile_defenses = 2188
	Global Const $skillid_angorodons_gaze = 2189
	Global Const $skillid_magnetic_surge = 2190
	Global Const $skillid_slippery_ground = 2191
	Global Const $skillid_glowing_ice = 2192
	Global Const $skillid_energy_blast = 2193
	Global Const $skillid_distracting_strike = 2194
	Global Const $skillid_symbolic_strike = 2195
	Global Const $skillid_soldiers_speed = 2196
	Global Const $skillid_body_blow = 2197
	Global Const $skillid_body_shot = 2198
	Global Const $skillid_poison_tip_signet = 2199
	Global Const $skillid_signet_of_mystic_speed = 2200
	Global Const $skillid_shield_of_force = 2201
	Global Const $skillid_mending_grip = 2202
	Global Const $skillid_spiritleech_aura = 2203
	Global Const $skillid_rejuvenation = 2204
	Global Const $skillid_agony = 2205
	Global Const $skillid_ghostly_weapon = 2206
	Global Const $skillid_inspirational_speech = 2207
	Global Const $skillid_burning_shield = 2208
	Global Const $skillid_holy_spear = 2209
	Global Const $skillid_spear_swipe = 2210
	Global Const $skillid_alkars_alchemical_acid = 2211
	Global Const $skillid_light_of_deldrimor = 2212
	Global Const $skillid_ear_bite = 2213
	Global Const $skillid_low_blow = 2214
	Global Const $skillid_brawling_headbutt = 2215
	Global Const $skillid_dont_trip = 2216
	Global Const $skillid_by_urals_hammer = 2217
	Global Const $skillid_drunken_master = 2218
	Global Const $skillid_great_dwarf_weapon = 2219
	Global Const $skillid_great_dwarf_armor = 2220
	Global Const $skillid_breath_of_the_great_dwarf = 2221
	Global Const $skillid_snow_storm = 2222
	Global Const $skillid_black_powder_mine = 2223
	Global Const $skillid_summon_mursaat = 2224
	Global Const $skillid_summon_ruby_djinn = 2225
	Global Const $skillid_summon_ice_imp = 2226
	Global Const $skillid_summon_naga_shaman = 2227
	Global Const $skillid_deft_strike = 2228
	Global Const $skillid_signet_of_infection = 2229
	Global Const $skillid_tryptophan_signet = 2230
	Global Const $skillid_ebon_battle_standard_of_courage = 2231
	Global Const $skillid_ebon_battle_standard_of_wisdom = 2232
	Global Const $skillid_ebon_battle_standard_of_honor = 2233
	Global Const $skillid_ebon_vanguard_sniper_support = 2234
	Global Const $skillid_ebon_vanguard_assassin_support = 2235
	Global Const $skillid_well_of_ruin = 2236
	Global Const $skillid_atrophy = 2237
	Global Const $skillid_spear_of_redemption = 2238
	Global Const $skillid_gelatinous_material_explosion = 2240
	Global Const $skillid_gelatinous_corpse_consumption = 2241
	Global Const $skillid_gelatinous_absorption = 2243
	Global Const $skillid_unstable_ooze_explosion = 2244
	Global Const $skillid_unstable_aura = 2246
	Global Const $skillid_unstable_pulse = 2247
	Global Const $skillid_polymock_power_drain = 2248
	Global Const $skillid_polymock_block = 2249
	Global Const $skillid_polymock_glyph_of_concentration = 2250
	Global Const $skillid_polymock_ether_signet = 2251
	Global Const $skillid_polymock_glyph_of_power = 2252
	Global Const $skillid_polymock_overload = 2253
	Global Const $skillid_polymock_glyph_destabilization = 2254
	Global Const $skillid_polymock_mind_wreck = 2255
	Global Const $skillid_order_of_unholy_vigor = 2256
	Global Const $skillid_order_of_the_lich = 2257
	Global Const $skillid_master_of_necromancy = 2258
	Global Const $skillid_animate_undead = 2259
	Global Const $skillid_polymock_deathly_chill = 2260
	Global Const $skillid_polymock_rising_bile = 2261
	Global Const $skillid_polymock_rotting_flesh = 2262
	Global Const $skillid_polymock_lightning_strike = 2263
	Global Const $skillid_polymock_lightning_orb = 2264
	Global Const $skillid_polymock_lightning_djinns_haste = 2265
	Global Const $skillid_polymock_flare = 2266
	Global Const $skillid_polymock_immolate = 2267
	Global Const $skillid_polymock_meteor = 2268
	Global Const $skillid_polymock_ice_spear = 2269
	Global Const $skillid_polymock_icy_prison = 2270
	Global Const $skillid_polymock_mind_freeze = 2271
	Global Const $skillid_polymock_ice_shard_storm = 2272
	Global Const $skillid_polymock_frozen_trident = 2273
	Global Const $skillid_polymock_smite = 2274
	Global Const $skillid_polymock_smite_hex = 2275
	Global Const $skillid_polymock_bane_signet = 2276
	Global Const $skillid_polymock_stone_daggers = 2277
	Global Const $skillid_polymock_obsidian_flame = 2278
	Global Const $skillid_polymock_earthquake = 2279
	Global Const $skillid_polymock_frozen_armor = 2280
	Global Const $skillid_polymock_glyph_freeze = 2281
	Global Const $skillid_polymock_fireball = 2282
	Global Const $skillid_polymock_rodgorts_invocation = 2283
	Global Const $skillid_polymock_calculated_risk = 2284
	Global Const $skillid_polymock_recurring_insecurity = 2285
	Global Const $skillid_polymock_backfire = 2286
	Global Const $skillid_polymock_guilt = 2287
	Global Const $skillid_polymock_lamentation = 2288
	Global Const $skillid_polymock_spirit_rift = 2289
	Global Const $skillid_polymock_painful_bond = 2290
	Global Const $skillid_polymock_signet_of_clumsiness = 2291
	Global Const $skillid_polymock_migraine = 2292
	Global Const $skillid_polymock_glowing_gaze = 2293
	Global Const $skillid_polymock_searing_flames = 2294
	Global Const $skillid_polymock_signet_of_revenge = 2295
	Global Const $skillid_polymock_signet_of_smiting = 2296
	Global Const $skillid_polymock_stoning = 2297
	Global Const $skillid_polymock_eruption = 2298
	Global Const $skillid_polymock_shock_arrow = 2299
	Global Const $skillid_polymock_mind_shock = 2300
	Global Const $skillid_polymock_piercing_light_spear = 2301
	Global Const $skillid_polymock_mind_blast = 2302
	Global Const $skillid_polymock_savannah_heat = 2303
	Global Const $skillid_polymock_diversion = 2304
	Global Const $skillid_polymock_lightning_blast = 2305
	Global Const $skillid_polymock_poisoned_ground = 2306
	Global Const $skillid_polymock_icy_bonds = 2307
	Global Const $skillid_polymock_sandstorm = 2308
	Global Const $skillid_polymock_banish = 2309
	Global Const $skillid_mergoyle_form = 2310
	Global Const $skillid_skale_form = 2311
	Global Const $skillid_gargoyle_form = 2312
	Global Const $skillid_ice_imp_form = 2313
	Global Const $skillid_fire_imp_form = 2314
	Global Const $skillid_kappa_form = 2315
	Global Const $skillid_aloe_seed_form = 2316
	Global Const $skillid_earth_elemental_form = 2317
	Global Const $skillid_fire_elemental_form = 2318
	Global Const $skillid_ice_elemental_form = 2319
	Global Const $skillid_mirage_iboga_form = 2320
	Global Const $skillid_wind_rider_form = 2321
	Global Const $skillid_naga_shaman_form = 2322
	Global Const $skillid_mantis_dreamweaver_form = 2323
	Global Const $skillid_ruby_djinn_form = 2324
	Global Const $skillid_gaki_form = 2325
	Global Const $skillid_stone_rain_form = 2326
	Global Const $skillid_mursaat_elementalist_form = 2327
	Global Const $skillid_crystal_shield = 2328
	Global Const $skillid_crystal_snare = 2329
	Global Const $skillid_paranoid_indignation = 2330
	Global Const $skillid_searing_breath = 2331
	Global Const $skillid_brawling = 2333
	Global Const $skillid_brawling_block = 2334
	Global Const $skillid_brawling_jab = 2335
	Global Const $skillid_brawling_straight_right = 2337
	Global Const $skillid_brawling_hook = 2338
	Global Const $skillid_brawling_uppercut = 2340
	Global Const $skillid_brawling_combo_punch = 2341
	Global Const $skillid_brawling_headbutt_brawling_skill = 2342
	Global Const $skillid_stand_up = 2343
	Global Const $skillid_call_of_destruction = 2344
	Global Const $skillid_lava_ground = 2346
	Global Const $skillid_lava_wave = 2347
	Global Const $skillid_charr_siege_attack_assault_on_the_stronghold = 2352
	Global Const $skillid_finish_him = 2353
	Global Const $skillid_dodge_this = 2354
	Global Const $skillid_i_am_the_strongest = 2355
	Global Const $skillid_i_am_unstoppable = 2356
	Global Const $skillid_a_touch_of_guile = 2357
	Global Const $skillid_you_move_like_a_dwarf = 2358
	Global Const $skillid_you_are_all_weaklings = 2359
	Global Const $skillid_feel_no_pain = 2360
	Global Const $skillid_club_of_a_thousand_bears = 2361
	Global Const $skillid_lava_blast = 2364
	Global Const $skillid_thunderfist_strike = 2365
	Global Const $skillid_alkars_concoction = 2367
	Global Const $skillid_murakais_consumption = 2368
	Global Const $skillid_murakais_censure = 2369
	Global Const $skillid_murakais_calamity = 2370
	Global Const $skillid_murakais_storm_of_souls = 2371
	Global Const $skillid_edification = 2372
	Global Const $skillid_heart_of_the_norn = 2373
	Global Const $skillid_ursan_blessing = 2374
	Global Const $skillid_ursan_strike = 2375
	Global Const $skillid_ursan_rage = 2376
	Global Const $skillid_ursan_roar = 2377
	Global Const $skillid_ursan_force = 2378
	Global Const $skillid_volfen_blessing = 2379
	Global Const $skillid_volfen_claw = 2380
	Global Const $skillid_volfen_pounce = 2381
	Global Const $skillid_volfen_bloodlust = 2382
	Global Const $skillid_volfen_agility = 2383
	Global Const $skillid_raven_blessing = 2384
	Global Const $skillid_raven_talons = 2385
	Global Const $skillid_raven_swoop = 2386
	Global Const $skillid_raven_shriek = 2387
	Global Const $skillid_raven_flight = 2388
	Global Const $skillid_totem_of_man = 2389
	Global Const $skillid_murakais_call = 2391
	Global Const $skillid_spawn_pods = 2392
	Global Const $skillid_enraged_blast = 2393
	Global Const $skillid_spawn_hatchling = 2394
	Global Const $skillid_ursan_roar_blood_washes_blood = 2395
	Global Const $skillid_ursan_force_blood_washes_blood = 2396
	Global Const $skillid_ursan_aura = 2397
	Global Const $skillid_consume_flames = 2398
	Global Const $skillid_charr_flame_keeper_form = 2401
	Global Const $skillid_titan_form = 2402
	Global Const $skillid_skeletal_mage_form = 2403
	Global Const $skillid_smoke_wraith_form = 2404
	Global Const $skillid_bone_dragon_form = 2405
	Global Const $skillid_dwarven_arcanist_form = 2407
	Global Const $skillid_dolyak_rider_form = 2408
	Global Const $skillid_extract_inscription = 2409
	Global Const $skillid_charr_shaman_form = 2410
	Global Const $skillid_mindbender = 2411
	Global Const $skillid_smooth_criminal = 2412
	Global Const $skillid_technobabble = 2413
	Global Const $skillid_radiation_field = 2414
	Global Const $skillid_asuran_scan = 2415
	Global Const $skillid_air_of_superiority = 2416
	Global Const $skillid_mental_block = 2417
	Global Const $skillid_pain_inverter = 2418
	Global Const $skillid_healing_salve = 2419
	Global Const $skillid_ebon_escape = 2420
	Global Const $skillid_weakness_trap = 2421
	Global Const $skillid_winds = 2422
	Global Const $skillid_dwarven_stability = 2423
	Global Const $skillid_stouthearted = 2424
	Global Const $skillid_decipher_inscriptions = 2426
	Global Const $skillid_rebel_yell = 2427
	Global Const $skillid_asuran_flame_staff = 2429
	Global Const $skillid_aura_of_the_bloodstone = 2430
	Global Const $skillid_haunted_ground = 2433
	Global Const $skillid_asuran_bodyguard = 2434
	Global Const $skillid_energy_channel = 2437
	Global Const $skillid_hunt_rampage_asura = 2438
	Global Const $skillid_boss_bounty = 2440
	Global Const $skillid_hunt_point_bonus_asura = 2441
	Global Const $skillid_time_attack = 2444
	Global Const $skillid_dwarven_raider = 2445
	Global Const $skillid_great_dwarfs_blessing = 2449
	Global Const $skillid_hunt_rampage_deldrimor = 2450
	Global Const $skillid_hunt_point_bonus = 2453
	Global Const $skillid_vanguard_patrol = 2457
	Global Const $skillid_vanguard_commendation = 2461
	Global Const $skillid_hunt_rampage_ebon_vanguard = 2462
	Global Const $skillid_norn_hunting_party = 2469
	Global Const $skillid_strength_of_the_norn = 2473
	Global Const $skillid_hunt_rampage_norn = 2474
	Global Const $skillid_gloat = 2483
	Global Const $skillid_metamorphosis = 2484
	Global Const $skillid_inner_fire = 2485
	Global Const $skillid_elemental_shift = 2486
	Global Const $skillid_dryders_feast = 2487
	Global Const $skillid_fungal_explosion = 2488
	Global Const $skillid_blood_rage = 2489
	Global Const $skillid_parasitic_bite = 2490
	Global Const $skillid_false_death = 2491
	Global Const $skillid_ooze_combination = 2492
	Global Const $skillid_ooze_division = 2493
	Global Const $skillid_bear_form = 2494
	Global Const $skillid_spore_explosion = 2496
	Global Const $skillid_dormant_husk = 2497
	Global Const $skillid_monkey_see_monkey_do = 2498
	Global Const $skillid_tengus_mimicry = 2500
	Global Const $skillid_tongue_lash = 2501
	Global Const $skillid_soulrending_shriek = 2502
	Global Const $skillid_siege_devourer = 2504
	Global Const $skillid_siege_devourer_feast = 2505
	Global Const $skillid_devourer_bite = 2506
	Global Const $skillid_siege_devourer_swipe = 2507
	Global Const $skillid_devourer_siege = 2508
	Global Const $skillid_hyahhhhh = 2509
	Global Const $skillid_dismount_siege_devourer = 2513
	Global Const $skillid_the_masters_mark = 2514
	Global Const $skillid_the_snipers_spear = 2515
	Global Const $skillid_mount = 2516
	Global Const $skillid_reverse_polarity_fire_shield = 2517
	Global Const $skillid_tengus_gaze = 2518
	Global Const $skillid_armor_of_salvation_item_effect = 2520
	Global Const $skillid_grail_of_might_item_effect = 2521
	Global Const $skillid_essence_of_celerity_item_effect = 2522
	Global Const $skillid_duncans_defense = 2527
	Global Const $skillid_invigorating_mist = 2536
	Global Const $skillid_courageous_was_saidra = 2537
	Global Const $skillid_animate_undead_palawa_joko = 2538
	Global Const $skillid_order_of_unholy_vigor_palawa_joko = 2539
	Global Const $skillid_order_of_the_lich_palawa_joko = 2540
	Global Const $skillid_golem_boosters = 2541
	Global Const $skillid_tongue_whip = 2544
	Global Const $skillid_lit_torch = 2545
	Global Const $skillid_dishonorable = 2546
	Global Const $skillid_veteran_asuran_bodyguard = 2548
	Global Const $skillid_veteran_dwarven_raider = 2549
	Global Const $skillid_veteran_vanguard_patrol = 2550
	Global Const $skillid_veteran_norn_hunting_party = 2551
	Global Const $skillid_candy_corn_skill = 2604
	Global Const $skillid_candy_apple_skill = 2605
	Global Const $skillid_anton_disguise = 2606
	Global Const $skillid_erys_vasburg_disguise = 2607
	Global Const $skillid_olias_disguise = 2608
	Global Const $skillid_argo_disguise = 2609
	Global Const $skillid_mhenlo_disguise = 2610
	Global Const $skillid_lukas_disguise = 2611
	Global Const $skillid_aidan_disguise = 2612
	Global Const $skillid_kahmu_disguise = 2613
	Global Const $skillid_razah_disguise = 2614
	Global Const $skillid_morgahn_disguise = 2615
	Global Const $skillid_nika_disguise = 2616
	Global Const $skillid_seaguard_hala_disguise = 2617
	Global Const $skillid_livia_disguise = 2618
	Global Const $skillid_cynn_disguise = 2619
	Global Const $skillid_tahlkora_disguise = 2620
	Global Const $skillid_devona_disguise = 2621
	Global Const $skillid_zho_disguise = 2622
	Global Const $skillid_melonni_disguise = 2623
	Global Const $skillid_xandra_disguise = 2624
	Global Const $skillid_hayda_disguise = 2625
	Global Const $skillid_pie_induced_ecstasy = 2649
	Global Const $skillid_togo_disguise = 2651
	Global Const $skillid_turai_ossa_disguise = 2652
	Global Const $skillid_gwen_disguise = 2653
	Global Const $skillid_saul_dalessio_disguise = 2654
	Global Const $skillid_dragon_empire_rage = 2655
	Global Const $skillid_call_to_the_spirit_realm = 2656
	Global Const $skillid_hide = 2658
	Global Const $skillid_feign_death = 2659
	Global Const $skillid_flee = 2660
	Global Const $skillid_throw_rock = 2661
	Global Const $skillid_siege_strike = 2663
	Global Const $skillid_spike_trap_spell = 2664
	Global Const $skillid_barbed_bomb = 2665
	Global Const $skillid_balm_bomb = 2667
	Global Const $skillid_explosives = 2668
	Global Const $skillid_rations = 2669
	Global Const $skillid_form_up_and_advance = 2670
	Global Const $skillid_spectral_agony_hex = 2672
	Global Const $skillid_stun_bomb = 2673
	Global Const $skillid_banner_of_the_unseen = 2674
	Global Const $skillid_signet_of_the_unseen = 2675
	Global Const $skillid_for_elona = 2676
	Global Const $skillid_giant_stomp_turai_ossa = 2677
	Global Const $skillid_whirlwind_attack_turai_ossa = 2678
	Global Const $skillid_journey_to_the_north = 2699
	Global Const $skillid_rat_form = 2701
	Global Const $skillid_party_time = 2712
	Global Const $skillid_awakened_head_form = 2841
	Global Const $skillid_spider_form = 2842
	Global Const $skillid_golem_form = 2844
	Global Const $skillid_norn_form = 2846
	Global Const $skillid_rift_warden_form = 2848
	Global Const $skillid_snowman_form = 2851
	Global Const $skillid_energy_drain_pvp = 2852
	Global Const $skillid_energy_tap_pvp = 2853
	Global Const $skillid_pvp_effect = 2854
	Global Const $skillid_ward_against_melee_pvp = 2855
	Global Const $skillid_lightning_orb_pvp = 2856
	Global Const $skillid_aegis_pvp = 2857
	Global Const $skillid_watch_yourself_pvp = 2858
	Global Const $skillid_enfeeble_pvp = 2859
	Global Const $skillid_ether_renewal_pvp = 2860
	Global Const $skillid_penetrating_attack_pvp = 2861
	Global Const $skillid_shadow_form_pvp = 2862
	Global Const $skillid_discord_pvp = 2863
	Global Const $skillid_sundering_attack_pvp = 2864
	Global Const $skillid_ritual_lord_pvp = 2865
	Global Const $skillid_flesh_of_my_flesh_pvp = 2866
	Global Const $skillid_ancestors_rage_pvp = 2867
	Global Const $skillid_splinter_weapon_pvp = 2868
	Global Const $skillid_assassins_remedy_pvp = 2869
	Global Const $skillid_blinding_surge_pvp = 2870
	Global Const $skillid_light_of_deliverance_pvp = 2871
	Global Const $skillid_death_pact_signet_pvp = 2872
	Global Const $skillid_mystic_sweep_pvp = 2873
	Global Const $skillid_eremites_attack_pvp = 2874
	Global Const $skillid_harriers_toss_pvp = 2875
	Global Const $skillid_defensive_anthem_pvp = 2876
	Global Const $skillid_ballad_of_restoration_pvp = 2877
	Global Const $skillid_song_of_restoration_pvp = 2878
	Global Const $skillid_incoming_pvp = 2879
	Global Const $skillid_never_surrender_pvp = 2880
	Global Const $skillid_mantra_of_inscriptions_pvp = 2882
	Global Const $skillid_for_great_justice_pvp = 2883
	Global Const $skillid_mystic_regeneration_pvp = 2884
	Global Const $skillid_enfeebling_blood_pvp = 2885
	Global Const $skillid_summoning_sickness = 2886
	Global Const $skillid_signet_of_judgment_pvp = 2887
	Global Const $skillid_chilling_victory_pvp = 2888
	Global Const $skillid_unyielding_aura_pvp = 2891
	Global Const $skillid_spirit_bond_pvp = 2892
	Global Const $skillid_weapon_of_warding_pvp = 2893
	Global Const $skillid_smiters_boon_pvp = 2895
	Global Const $skillid_battle_fervor_deactivating_rox = 2896
	Global Const $skillid_cloak_of_faith_deactivating_rox = 2897
	Global Const $skillid_dark_aura_deactivating_rox = 2898
	Global Const $skillid_reactor_blast = 2902
	Global Const $skillid_reactor_blast_timer = 2903
	Global Const $skillid_jade_brotherhood_disguise = 2904
	Global Const $skillid_internal_power_engaged = 2905
	Global Const $skillid_target_acquisition = 2906
	Global Const $skillid_nox_beam = 2907
	Global Const $skillid_nox_field_dash = 2908
	Global Const $skillid_noxion_buster = 2909
	Global Const $skillid_countdown = 2910
	Global Const $skillid_bit_golem_breaker = 2911
	Global Const $skillid_bit_golem_rectifier = 2912
	Global Const $skillid_bit_golem_crash = 2913
	Global Const $skillid_bit_golem_force = 2914
	Global Const $skillid_nox_phantom = 2916
	Global Const $skillid_nox_thunder = 2917
	Global Const $skillid_nox_lock_on = 2918
	Global Const $skillid_nox_driver = 2919
	Global Const $skillid_nox_fire = 2920
	Global Const $skillid_nox_knuckle = 2921
	Global Const $skillid_nox_divider_drive = 2922
	Global Const $skillid_sloth_hunters_shot_pvp = 2925
	Global Const $skillid_experts_dexterity_pvp = 2959
	Global Const $skillid_signet_of_spirits_pvp = 2965
	Global Const $skillid_signet_of_ghostly_might_pvp = 2966
	Global Const $skillid_avatar_of_grenth_pvp = 2967
	Global Const $skillid_oversized_tonic_warning = 2968
	Global Const $skillid_read_the_wind_pvp = 2969
	Global Const $skillid_blue_rock_candy_rush = 2971
	Global Const $skillid_green_rock_candy_rush = 2972
	Global Const $skillid_red_rock_candy_rush = 2973
	Global Const $skillid_well_supplied = 3174
#EndRegion
#Region MapNames
	Global $map_name_by_id[880]
	$map_name_by_id[0] = 859
	$map_name_by_id[4] = "Guild Hall - Warrior's Isle"
	$map_name_by_id[5] = "Guild Hall - Hunter's Isle"
	$map_name_by_id[6] = "Guild Hall - Wizard's Isle"
	$map_name_by_id[7] = "Warrior's Isle Explorable"
	$map_name_by_id[8] = "Hunter's Isle Explorable"
	$map_name_by_id[9] = "Wizard's Isle Explorable"
	$map_name_by_id[10] = "Bloodstone Fen outpost"
	$map_name_by_id[11] = "The Wilds outpost"
	$map_name_by_id[12] = "Aurora Glade outpost"
	$map_name_by_id[13] = "Diesa Lowlands"
	$map_name_by_id[14] = "Gates of Kryta outpost"
	$map_name_by_id[15] = "D'Alessio Seaboard outpost"
	$map_name_by_id[16] = "Divinity Coast outpost"
	$map_name_by_id[17] = "Talmark Wilderness"
	$map_name_by_id[18] = "The Black Curtain"
	$map_name_by_id[19] = "Sanctum Cay outpost"
	$map_name_by_id[20] = "Droknar's Forge"
	$map_name_by_id[21] = "The Frost Gate outpost"
	$map_name_by_id[22] = "Ice Caves of Sorrow outpost"
	$map_name_by_id[23] = "Thunderhead Keep outpost"
	$map_name_by_id[24] = "Iron Mines of Moladune outpost"
	$map_name_by_id[25] = "Borlis Pass outpost"
	$map_name_by_id[26] = "Talus Chute"
	$map_name_by_id[27] = "Griffon's Mouth"
	$map_name_by_id[28] = "The Great Northern Wall outpost"
	$map_name_by_id[29] = "Fort Ranik outpost"
	$map_name_by_id[30] = "Ruins of Surmia outpost"
	$map_name_by_id[31] = "Xaquang Skyway"
	$map_name_by_id[32] = "Nolani Academy outpost"
	$map_name_by_id[33] = "Old Ascalon"
	$map_name_by_id[34] = "The Fissure of Woe"
	$map_name_by_id[35] = "Ember Light Camp"
	$map_name_by_id[36] = "Grendich Courthouse"
	$map_name_by_id[37] = "Glint' Challenge"
	$map_name_by_id[38] = "Augury Rock outpost"
	$map_name_by_id[39] = "Sardelac Sanitarium"
	$map_name_by_id[40] = "Piken Square"
	$map_name_by_id[41] = "Sage Lands"
	$map_name_by_id[42] = "Mamnoon Lagoon"
	$map_name_by_id[43] = "Silverwood"
	$map_name_by_id[44] = "Ettin's Back"
	$map_name_by_id[45] = "Reed Bog"
	$map_name_by_id[46] = "The Falls"
	$map_name_by_id[47] = "Dry Top"
	$map_name_by_id[48] = "Tangle Root"
	$map_name_by_id[49] = "Henge of Denravi"
	$map_name_by_id[51] = "Senjis Corner"
	$map_name_by_id[52] = "Guild Hall - Burning Isle"
	$map_name_by_id[53] = "Tears of the Fallen"
	$map_name_by_id[54] = "Scoundrel's Rise"
	$map_name_by_id[55] = "Lions Arch"
	$map_name_by_id[56] = "Cursed Lands"
	$map_name_by_id[57] = "Bergen Hot Springs"
	$map_name_by_id[58] = "North Kryta Province"
	$map_name_by_id[59] = "Nebo Terrace"
	$map_name_by_id[60] = "Majesty's Rest"
	$map_name_by_id[61] = "Twin Serpent Lakes"
	$map_name_by_id[62] = "Watchtower Coast"
	$map_name_by_id[63] = "Stingray Strand"
	$map_name_by_id[64] = "Kessex Peak"
	$map_name_by_id[65] = "D'Alessio Arena"
	$map_name_by_id[67] = "Burning Isle Explorable"
	$map_name_by_id[68] = "Frozen Isle Explorable"
	$map_name_by_id[69] = "Nomad's Isle Explorable"
	$map_name_by_id[70] = "Druid's Isle Explorable"
	$map_name_by_id[71] = "Isle of the Dead Explorable"
	$map_name_by_id[72] = "The Underworld"
	$map_name_by_id[73] = "Riverside Province outpost"
	$map_name_by_id[75] = "The Hall of Heroes Arena"
	$map_name_by_id[76] = "Broken Tower Arena"
	$map_name_by_id[77] = "House zu Heltzer"
	$map_name_by_id[78] = "The Courtyard Arena"
	$map_name_by_id[79] = "Unholy Temples Area"
	$map_name_by_id[80] = "Burial Mounds Arena"
	$map_name_by_id[81] = "Ascalon City"
	$map_name_by_id[82] = "Tomb of the Primeval Kings"
	$map_name_by_id[83] = "The Vault Arena"
	$map_name_by_id[84] = "The Underworld Arena"
	$map_name_by_id[85] = "Ascalon Arena outpost"
	$map_name_by_id[86] = "Sacred Temples Arena"
	$map_name_by_id[87] = "Icedome"
	$map_name_by_id[88] = "Iron Horse Mine"
	$map_name_by_id[89] = "Anvil Rock"
	$map_name_by_id[90] = "Lornar's Pass"
	$map_name_by_id[91] = "Snake Dance"
	$map_name_by_id[92] = "Tasca's Demise"
	$map_name_by_id[93] = "Spearhead Peak"
	$map_name_by_id[94] = "Ice Floe"
	$map_name_by_id[95] = "Witman's Folly"
	$map_name_by_id[96] = "Mineral Springs"
	$map_name_by_id[97] = "Dreadnought's Drift"
	$map_name_by_id[98] = "Frozen Forest"
	$map_name_by_id[99] = "Traveler's Vale"
	$map_name_by_id[100] = "Deldrimor Bowl"
	$map_name_by_id[101] = "Regent Valley"
	$map_name_by_id[102] = "The Breach"
	$map_name_by_id[103] = "Ascalon Foothills"
	$map_name_by_id[104] = "Pockmark Flats"
	$map_name_by_id[105] = "Dragon's Gullet"
	$map_name_by_id[106] = "Flame Temple Corridor"
	$map_name_by_id[107] = "Eastern Frontier"
	$map_name_by_id[108] = "The Scar"
	$map_name_by_id[109] = "The Amnoon Oasis"
	$map_name_by_id[110] = "Diviner's Ascent"
	$map_name_by_id[111] = "Vulture Drifts"
	$map_name_by_id[112] = "The Arid Sea"
	$map_name_by_id[113] = "Prophet's Path"
	$map_name_by_id[114] = "Salt Flats"
	$map_name_by_id[115] = "Skyward Reach"
	$map_name_by_id[116] = "Dunes of Despair outpost"
	$map_name_by_id[117] = "Thirsty River outpost"
	$map_name_by_id[118] = "Elona Reach outpost"
	$map_name_by_id[119] = "Augury Rock outpost"
	$map_name_by_id[120] = "The Dragon's Lair outpost"
	$map_name_by_id[121] = "Perdition Rock"
	$map_name_by_id[122] = "Ring of Fire outpost"
	$map_name_by_id[123] = "Abaddon's Mouth outpost"
	$map_name_by_id[124] = "Hell's Precipice outpost"
	$map_name_by_id[126] = "Golden Gates"
	$map_name_by_id[127] = "Scarred Earth"
	$map_name_by_id[128] = "The Eternal Grove Explorable"
	$map_name_by_id[129] = "Lutgardis Conservatory"
	$map_name_by_id[130] = "Vasburg Armory"
	$map_name_by_id[131] = "Serenity Temple"
	$map_name_by_id[132] = "Ice Tooth Cave"
	$map_name_by_id[133] = "Beacons Perch"
	$map_name_by_id[134] = "Yaks Bend"
	$map_name_by_id[135] = "Frontier Gate"
	$map_name_by_id[136] = "Beetletun"
	$map_name_by_id[137] = "Fishermens Haven"
	$map_name_by_id[138] = "Temple of the Ages"
	$map_name_by_id[139] = "Ventaris Refuge"
	$map_name_by_id[140] = "Druids Overlook"
	$map_name_by_id[141] = "Maguuma Stade"
	$map_name_by_id[142] = "Quarrel Falls"
	$map_name_by_id[144] = "Gyala Hatchery Explorable"
	$map_name_by_id[145] = "The Catacombs"
	$map_name_by_id[146] = "Lakeside County"
	$map_name_by_id[147] = "The Northlands"
	$map_name_by_id[148] = "Ascalon City outpost"
	$map_name_by_id[149] = "Ascalon Academy"
	$map_name_by_id[150] = " Ascalon Academy PvP battle"
	$map_name_by_id[151] = "Ascalon Academy"
	$map_name_by_id[152] = "Heroes Audience"
	$map_name_by_id[153] = "Seekers Passage"
	$map_name_by_id[154] = "Destinys Gorge"
	$map_name_by_id[155] = "Camp Rankor"
	$map_name_by_id[156] = "The Granite Citadel"
	$map_name_by_id[157] = "Marhans Grotto"
	$map_name_by_id[158] = "Port Sledge"
	$map_name_by_id[159] = "Copperhammer Mines"
	$map_name_by_id[160] = "green Hills County"
	$map_name_by_id[161] = "Wizard's Folly"
	$map_name_by_id[162] = "Pre-Searing: Regent valley"
	$map_name_by_id[163] = "Pre-Searing: The Barradin Estate"
	$map_name_by_id[164] = "Pre-Searing: Ashford Abbey"
	$map_name_by_id[165] = "Pre-Searing: Foibles Fair"
	$map_name_by_id[166] = "Pre-Searing: Fort Ranik"
	$map_name_by_id[167] = "Burning Isle"
	$map_name_by_id[168] = "Druid's Isle"
	$map_name_by_id[170] = "Frozen Isle"
	$map_name_by_id[171] = "Warrior's Isle"
	$map_name_by_id[172] = "Hunter's Isle"
	$map_name_by_id[173] = "Wizard's Isle"
	$map_name_by_id[174] = "Nomad's Isle"
	$map_name_by_id[175] = "Isle of the Dead"
	$map_name_by_id[176] = "Guild Hall - Frozen Isle"
	$map_name_by_id[177] = "Guild Hall - Nomad's Isle"
	$map_name_by_id[178] = "Guild Hall - Druid's Isle"
	$map_name_by_id[179] = "Guild Hall - Isle of the Dead"
	$map_name_by_id[180] = "Fort Koga"
	$map_name_by_id[181] = "Shiverpeak Arena outpost"
	$map_name_by_id[182] = "Amnoon Arena"
	$map_name_by_id[183] = "Deldrimor Arena"
	$map_name_by_id[184] = "The Crag"
	$map_name_by_id[188] = "Random Arenas outpost"
	$map_name_by_id[189] = "Team Arenas outpost"
	$map_name_by_id[190] = "Sorrow's Furnace"
	$map_name_by_id[191] = "Grenth's Footprint"
	$map_name_by_id[193] = "Cavalon"
	$map_name_by_id[194] = "Kaineng Center"
	$map_name_by_id[195] = "Drazach Thicket"
	$map_name_by_id[196] = "Jaya Bluff"
	$map_name_by_id[197] = "Shenzun Tunnels"
	$map_name_by_id[198] = "Archipelagos"
	$map_name_by_id[199] = "Maishang Hills"
	$map_name_by_id[200] = "Mount Qinkai"
	$map_name_by_id[201] = "Melandru's Hope"
	$map_name_by_id[202] = "Rhea's Crater"
	$map_name_by_id[203] = "Silent Surf"
	$map_name_by_id[204] = "Unwaking Waters - Kurzick"
	$map_name_by_id[205] = "Morostav Trail"
	$map_name_by_id[206] = "Deldrimor War Camp"
	$map_name_by_id[208] = "Heroes' Crypt"
	$map_name_by_id[209] = "Mourning Veil Falls"
	$map_name_by_id[210] = "Ferndale"
	$map_name_by_id[211] = "Pongmei Valley"
	$map_name_by_id[212] = "Monastery Overlook"
	$map_name_by_id[213] = "Zen Daijun outpost"
	$map_name_by_id[214] = "Minister Chos Estate outpost"
	$map_name_by_id[215] = "Vizunah Square"
	$map_name_by_id[216] = "Nahpui Quarter outpost"
	$map_name_by_id[217] = "Tahnnakai Temple outpost"
	$map_name_by_id[218] = "Arborstone outpost"
	$map_name_by_id[219] = "Boreas Seabed outpost"
	$map_name_by_id[220] = "Sunjiang District outpost"
	$map_name_by_id[221] = "Fort Aspenwood"
	$map_name_by_id[222] = "The Eternal Grove outpost"
	$map_name_by_id[223] = "The Jade Quarry"
	$map_name_by_id[224] = "Gyala Hatchery outpost"
	$map_name_by_id[225] = "Raisu Palace outpost"
	$map_name_by_id[226] = "Imperial Sanctum outpost"
	$map_name_by_id[227] = "Unwaking Waters Luxon"
	$map_name_by_id[228] = "Grenz Frontier"
	$map_name_by_id[230] = "Amatz Basin Explorable"
	$map_name_by_id[230] = "Amatz Basin outpost"
	$map_name_by_id[233] = "Raisu Palace outpost"
	$map_name_by_id[234] = "The Aurios Mines outpost"
	$map_name_by_id[235] = "Panjiang Peninsula"
	$map_name_by_id[236] = "Kinya Province"
	$map_name_by_id[237] = "Haiju Lagoon"
	$map_name_by_id[238] = "Sunqua Vale"
	$map_name_by_id[239] = "Waijun Bazaar"
	$map_name_by_id[240] = "Bukdek Byway"
	$map_name_by_id[241] = "The Undercity"
	$map_name_by_id[242] = "Shing Jea Monastery"
	$map_name_by_id[243] = "Shing Jea Arena outpost"
	$map_name_by_id[244] = "Arborstone Explorable"
	$map_name_by_id[245] = "Minister Cho's Estate Explorable"
	$map_name_by_id[246] = "Zen Daijun Explorable"
	$map_name_by_id[247] = "Boreas Seabed Explorable"
	$map_name_by_id[248] = "Great Temple of Balthazar"
	$map_name_by_id[249] = "Tsumei Village"
	$map_name_by_id[250] = "Seitung Harbor"
	$map_name_by_id[251] = "Ran Musu Gardens"
	$map_name_by_id[252] = "Linnok Courtyard"
	$map_name_by_id[253] = "Dwayna Vs Grenth outpost"
	$map_name_by_id[256] = "Sunjiang District Explorable"
	$map_name_by_id[265] = "Nahpui Quarter Explorable"
	$map_name_by_id[266] = "Urgoz's Warren outpost"
	$map_name_by_id[272] = "Altrumm Ruins outpost"
	$map_name_by_id[273] = "Zos Shivros Channel outpost"
	$map_name_by_id[274] = "Dragons Throat outpost"
	$map_name_by_id[275] = "Guild Hall - Isle of Weeping Stone"
	$map_name_by_id[276] = "Guild Hall - Isle of Jade"
	$map_name_by_id[277] = "Harvest Temple"
	$map_name_by_id[278] = "Breaker Hollow"
	$map_name_by_id[279] = "Leviathan Pits"
	$map_name_by_id[280] = "Isle of the Nameless"
	$map_name_by_id[281] = "Zaishen Challenge outpost"
	$map_name_by_id[282] = "Zaishen Elite outpost"
	$map_name_by_id[283] = "Maatu Keep"
	$map_name_by_id[284] = "Zin Ku Corridor"
	$map_name_by_id[285] = "Monastery Overlook"
	$map_name_by_id[286] = "Brauer Academy"
	$map_name_by_id[287] = "Durheim Archives"
	$map_name_by_id[288] = "Bai Paasu Reach"
	$map_name_by_id[289] = "Seafarer's Rest"
	$map_name_by_id[290] = "Bejunkan Pier"
	$map_name_by_id[291] = "Vizunah Square Local Quarter"
	$map_name_by_id[292] = "Vizunah Square Foreign Quarter"
	$map_name_by_id[293] = "Fort Aspenwood - Luxon"
	$map_name_by_id[294] = "Fort Aspenwood - Kurzick"
	$map_name_by_id[295] = "The Jade Quarry - Luxon"
	$map_name_by_id[296] = "The Jade Quarry - Kurzick"
	$map_name_by_id[297] = "Unwaking Waters Luxon"
	$map_name_by_id[298] = "Unwaking Waters Kurzick"
	$map_name_by_id[300] = "Etnaran Keys"
	$map_name_by_id[301] = "Raisu Pavillion"
	$map_name_by_id[302] = "Kaineng Docks"
	$map_name_by_id[303] = "The Marketplace"
	$map_name_by_id[307] = "The Deep outpost"
	$map_name_by_id[308] = "Ascalon Arena"
	$map_name_by_id[309] = "Annihilation"
	$map_name_by_id[310] = "Kill Count Training"
	$map_name_by_id[311] = "Annihilation"
	$map_name_by_id[312] = "Obelisk Annihilation Training"
	$map_name_by_id[313] = "Saoshang Trail"
	$map_name_by_id[314] = "Shiverpeak Arena"
	$map_name_by_id[318] = "D'Alessio Arena"
	$map_name_by_id[319] = "Amnoon Arena"
	$map_name_by_id[320] = "Fort Koga"
	$map_name_by_id[321] = "Heroes' Crypt"
	$map_name_by_id[322] = "Shiverpeak Arena"
	$map_name_by_id[328] = "Saltspray Beach - Luxon"
	$map_name_by_id[329] = "Saltspray Beach - Kurzick"
	$map_name_by_id[330] = "Heroes Ascent outpost"
	$map_name_by_id[331] = "Grenz Frontier - Luxon"
	$map_name_by_id[332] = "Grenz Frontier - Kurzick"
	$map_name_by_id[333] = "The Ancestral Lands - Luxon"
	$map_name_by_id[334] = "The Ancestral Lands - Kurzick"
	$map_name_by_id[335] = "Etnaran Keys - Luxon"
	$map_name_by_id[336] = "Etnaran Keys - Kurzick"
	$map_name_by_id[337] = "Kaanai Canyon - Luxon"
	$map_name_by_id[338] = "Kaanai Canyon - Kurzick"
	$map_name_by_id[339] = "D'Alessio Arena"
	$map_name_by_id[340] = "Amnoon Arena"
	$map_name_by_id[341] = "Fort Koga"
	$map_name_by_id[342] = "Heroes' Crypt"
	$map_name_by_id[343] = "Shiverpeak Arena"
	$map_name_by_id[344] = "The Hall of Heroes"
	$map_name_by_id[345] = "The Courtyard"
	$map_name_by_id[346] = "Scarred Earth"
	$map_name_by_id[347] = "The Underworld Explorable"
	$map_name_by_id[348] = "Tanglewood Copse"
	$map_name_by_id[349] = "Saint Anjeka's Shrine"
	$map_name_by_id[350] = "Eredon Terrace"
	$map_name_by_id[351] = "Divine Path"
	$map_name_by_id[352] = "Brawler's Pit"
	$map_name_by_id[353] = "Petrified Arena"
	$map_name_by_id[354] = "Seabed Arena"
	$map_name_by_id[355] = "Isle of Weeping Stone"
	$map_name_by_id[356] = "Isle of Jade"
	$map_name_by_id[357] = "Imperial Isle"
	$map_name_by_id[358] = "Isle of Meditation"
	$map_name_by_id[359] = "Guild Hall - Imperial Isle"
	$map_name_by_id[360] = "Guild Hall - Isle of Meditation"
	$map_name_by_id[361] = "Isle of Weeping Stone"
	$map_name_by_id[362] = "Isle of Jade"
	$map_name_by_id[363] = "Imperial Isle"
	$map_name_by_id[364] = "Isle of Meditation"
	$map_name_by_id[368] = "Dragon Arena outpost"
	$map_name_by_id[369] = "Jahai Bluffs"
	$map_name_by_id[371] = "Marga Coast"
	$map_name_by_id[373] = "Sunward Marches"
	$map_name_by_id[375] = "Barbarous Shore"
	$map_name_by_id[376] = "Camp Hojanu"
	$map_name_by_id[377] = "Bahdok Caverns"
	$map_name_by_id[378] = "Wehhan Terraces"
	$map_name_by_id[379] = "Dejarin Estate"
	$map_name_by_id[380] = "Arkjok Ward"
	$map_name_by_id[381] = "Yohlon Haven"
	$map_name_by_id[382] = "Gandara, the Moon Fortress"
	$map_name_by_id[384] = "The Floodplain of Mahnkelon"
	$map_name_by_id[385] = "Lion's Arch during Sunspears in Kryta"
	$map_name_by_id[386] = "Turai's Procession"
	$map_name_by_id[387] = "Sunspear Sanctuary"
	$map_name_by_id[388] = "Aspenwood Gate - Kurzick"
	$map_name_by_id[389] = "Aspenwood Gate - Luxon"
	$map_name_by_id[390] = "Jade Flats Kurzick"
	$map_name_by_id[391] = "Jade Flats Luxon"
	$map_name_by_id[392] = "Yatendi Canyons"
	$map_name_by_id[393] = "Chantry of Secrets"
	$map_name_by_id[394] = "Garden of Seborhin"
	$map_name_by_id[396] = "Mihanu Township"
	$map_name_by_id[397] = "Vehjin Mines"
	$map_name_by_id[398] = "Basalt Grotto"
	$map_name_by_id[399] = "Forum Highlands"
	$map_name_by_id[400] = "Kaineng Center during Sunspears in Cantha"
	$map_name_by_id[402] = "Resplendent Makuun"
	$map_name_by_id[403] = "Honur Hill"
	$map_name_by_id[404] = "Wilderness of Bahdza"
	$map_name_by_id[406] = "Vehtendi Valley"
	$map_name_by_id[407] = "Yahnur Market"
	$map_name_by_id[413] = "The Hidden City of Ahdashim"
	$map_name_by_id[414] = "The Kodash Bazaar"
	$map_name_by_id[415] = "Lion's gate"
	$map_name_by_id[419] = "The Mirror of Lyss"
	$map_name_by_id[420] = "Secure the Refuge"
	$map_name_by_id[421] = "Venta Cemetery outpost"
	$map_name_by_id[422] = "Bad Tide Rising, Kamadan Explorable"
	$map_name_by_id[424] = "Kodonur Crossroads outpost"
	$map_name_by_id[425] = "Rilohn Refuge outpost"
	$map_name_by_id[426] = "Pogahn Passage outpost"
	$map_name_by_id[427] = "Moddok Crevice outpost"
	$map_name_by_id[428] = "Tihark Orchard outpost"
	$map_name_by_id[429] = "Consulate"
	$map_name_by_id[430] = "Plains of Jarin"
	$map_name_by_id[431] = "Sunspear Great Hall"
	$map_name_by_id[432] = "Cliffs of Dohjok"
	$map_name_by_id[433] = "Dzagonur Bastion outpost"
	$map_name_by_id[434] = "Dasha Vestibule outpost"
	$map_name_by_id[435] = "Grand Court of Sebelkeh outpost"
	$map_name_by_id[436] = "Command Post"
	$map_name_by_id[437] = "Joko's Domain"
	$map_name_by_id[438] = "Bone Palace"
	$map_name_by_id[439] = "The Ruptured Heart"
	$map_name_by_id[440] = "The Mouth of Torment"
	$map_name_by_id[441] = "The Shattered Ravines"
	$map_name_by_id[442] = "Lair of the Forgotten"
	$map_name_by_id[443] = "Poisoned Outcrops"
	$map_name_by_id[444] = "The Sulfurous Wastes"
	$map_name_by_id[445] = "The Ebony Citadel of Mallyx"
	$map_name_by_id[446] = "The Alkali Pan"
	$map_name_by_id[447] = "A Land of Heroes"
	$map_name_by_id[448] = "Crystal Overlook"
	$map_name_by_id[449] = "Kamadan Jewel of Istan"
	$map_name_by_id[450] = "Gate of Torment"
	$map_name_by_id[455] = "Nightfallen Garden"
	$map_name_by_id[456] = "Chuurhir Fields"
	$map_name_by_id[457] = "Beknur Harbor"
	$map_name_by_id[461] = "The Underworld"
	$map_name_by_id[462] = "Heart of Abaddon"
	$map_name_by_id[463] = "The Underworld"
	$map_name_by_id[465] = "Nightfallen Jahai"
	$map_name_by_id[466] = "Depths of Madness"
	$map_name_by_id[467] = "Rollerbeetle Racing outpost"
	$map_name_by_id[468] = "Domain of Fear"
	$map_name_by_id[469] = "Gate of Fear"
	$map_name_by_id[470] = "Domain of Pain"
	$map_name_by_id[471] = "Bloodstone Fen Explorable"
	$map_name_by_id[472] = "Domain of Secrets"
	$map_name_by_id[473] = "Gate of Secrets"
	$map_name_by_id[474] = "Domain of Anguish"
	$map_name_by_id[476] = "Jennurs Horde outpost"
	$map_name_by_id[477] = "Nundu Bay outpost"
	$map_name_by_id[478] = "Gate of Desolation outpost"
	$map_name_by_id[479] = "Champions Dawn"
	$map_name_by_id[480] = "Ruins of Morah outpost"
	$map_name_by_id[481] = "Fahranur, The First City"
	$map_name_by_id[482] = "Bjora Marches"
	$map_name_by_id[483] = "Zehlon Reach"
	$map_name_by_id[484] = "Lahteda Bog"
	$map_name_by_id[485] = "Arbor Bay"
	$map_name_by_id[486] = "Issnur Isles"
	$map_name_by_id[487] = "Beknur Harbor"
	$map_name_by_id[488] = "Mehtani Keys"
	$map_name_by_id[489] = "Kodlonu Hamlet"
	$map_name_by_id[490] = "Island of Shehkah"
	$map_name_by_id[491] = "Jokanur Diggings outpost"
	$map_name_by_id[492] = "Blacktide Den outpost"
	$map_name_by_id[493] = "Consulate Docks outpost"
	$map_name_by_id[494] = "Gate of Pain outpost"
	$map_name_by_id[495] = "Gate of Madness outpost"
	$map_name_by_id[496] = "Abaddons Gate outpost"
	$map_name_by_id[497] = "Sunspear Arena outpost"
	$map_name_by_id[499] = "Ice Cliff Chasms"
	$map_name_by_id[500] = "Bokka Amphitheatre"
	$map_name_by_id[501] = "Riven Earth"
	$map_name_by_id[502] = "The Astralarium"
	$map_name_by_id[503] = "Throne of Secrets"
	$map_name_by_id[504] = "Churranu Island Arena"
	$map_name_by_id[505] = "Shing Jea Monastery mission"
	$map_name_by_id[506] = "Haiju Lagoon mission"
	$map_name_by_id[507] = "Jaya Bluffs mission"
	$map_name_by_id[508] = "Seitung Harbor mission"
	$map_name_by_id[509] = "Tsumei Village mission"
	$map_name_by_id[510] = "Seitung Harbor mission 2"
	$map_name_by_id[511] = "Tsumei Village mission 2"
	$map_name_by_id[513] = "Drakkar Lake"
	$map_name_by_id[529] = "Guild Hall - Uncharted Isle"
	$map_name_by_id[530] = "Guild Hall - Isle of Wurms"
	$map_name_by_id[531] = "Uncharted Isle"
	$map_name_by_id[532] = "Isle of Wurms"
	$map_name_by_id[533] = "Uncharted Isle"
	$map_name_by_id[534] = "Isle of Wurms"
	$map_name_by_id[536] = "Sunspear Arena"
	$map_name_by_id[537] = "Guild Hall - Corrupted Isle"
	$map_name_by_id[538] = "Guild Hall - Isle of Solitude"
	$map_name_by_id[539] = "Corrupted Isle"
	$map_name_by_id[540] = "Isle of Solitude"
	$map_name_by_id[541] = "Corrupted Isle"
	$map_name_by_id[542] = "Isle of Solitude"
	$map_name_by_id[543] = "Sun Docks"
	$map_name_by_id[544] = "Chahbek Village outpost"
	$map_name_by_id[545] = "Remains of Sahlahja outpost"
	$map_name_by_id[546] = "Jaga Moraine"
	$map_name_by_id[547] = "Bombardment"
	$map_name_by_id[548] = "Norrhart Moains"
	$map_name_by_id[549] = "Hero Battles outpost"
	$map_name_by_id[550] = "The Beachhead"
	$map_name_by_id[551] = "The Crossing"
	$map_name_by_id[552] = "Desert Sands"
	$map_name_by_id[553] = "Varajar Fells"
	$map_name_by_id[554] = "Dajkah Inlet outpost"
	$map_name_by_id[555] = "The Shadow Nexus outpost"
	$map_name_by_id[558] = "Sparkfly Swamp"
	$map_name_by_id[559] = "Gate of the Nightfallen Lands"
	$map_name_by_id[560] = "Cathedral of Flames"
	$map_name_by_id[561] = "The Troubled Keeper"
	$map_name_by_id[566] = "Verdant Cascades"
	$map_name_by_id[567] = "Cathedral of Flames"
	$map_name_by_id[568] = "Cathedral of Flames"
	$map_name_by_id[569] = "Magus Stones"
	$map_name_by_id[570] = "Catacombs of Kathandrax"
	$map_name_by_id[571] = "Catacombs of Kathandrax"
	$map_name_by_id[572] = "Alcazia Tangle"
	$map_name_by_id[573] = "Rragar's Menagerie"
	$map_name_by_id[574] = "Rragar's Menagerie"
	$map_name_by_id[575] = "Rragar's Menagerie"
	$map_name_by_id[576] = "Ooza Pit"
	$map_name_by_id[577] = "Slaver's Exile"
	$map_name_by_id[578] = "Oola's Lab"
	$map_name_by_id[579] = "Oola's Lab"
	$map_name_by_id[580] = "Oola's Lab"
	$map_name_by_id[581] = "Shards of Oor"
	$map_name_by_id[582] = "Shards of Oor"
	$map_name_by_id[583] = "Shards of Oor"
	$map_name_by_id[584] = "Arachni's Haunt"
	$map_name_by_id[585] = "Arachni's Haunt"
	$map_name_by_id[593] = "Fetid River"
	$map_name_by_id[596] = "Forgotten Shrines"
	$map_name_by_id[598] = "Antechamber"
	$map_name_by_id[604] = "Vloxen Excavations"
	$map_name_by_id[605] = "Vloxen Excavations"
	$map_name_by_id[606] = "Vloxen Excavations"
	$map_name_by_id[607] = "Heart of the Shiverpeaks"
	$map_name_by_id[608] = "Heart of the Shiverpeaks"
	$map_name_by_id[609] = "Heart of the Shiverpeaks"
	$map_name_by_id[612] = "Bloodstone Caves"
	$map_name_by_id[613] = "Bloodstone Caves"
	$map_name_by_id[614] = "Bloodstone Caves"
	$map_name_by_id[615] = "Bogroot Growths"
	$map_name_by_id[616] = "Bogroot Growths"
	$map_name_by_id[617] = "Raven's Point"
	$map_name_by_id[618] = "Raven's Point"
	$map_name_by_id[619] = "Raven's Point"
	$map_name_by_id[620] = "Slaver's Exile"
	$map_name_by_id[621] = "Slaver's Exile"
	$map_name_by_id[622] = "Slaver's Exile"
	$map_name_by_id[623] = "Slaver's Exile"
	$map_name_by_id[624] = "Vlox's Falls"
	$map_name_by_id[625] = "Battledepths"
	$map_name_by_id[628] = "Sepulchre of Dragrimmar"
	$map_name_by_id[629] = "Sepulchre of Dragrimmar"
	$map_name_by_id[630] = "Frostmaw's Burrows"
	$map_name_by_id[631] = "Frostmaw's Burrows"
	$map_name_by_id[632] = "Frostmaw's Burrows"
	$map_name_by_id[633] = "Frostmaw's Burrows"
	$map_name_by_id[634] = "Frostmaw's Burrows"
	$map_name_by_id[635] = "Darkrime Delves"
	$map_name_by_id[636] = "Darkrime Delves"
	$map_name_by_id[637] = "Darkrime Delves"
	$map_name_by_id[638] = "Gadd's Encampment"
	$map_name_by_id[639] = "Umbral Grotto"
	$map_name_by_id[640] = "Rata Sum"
	$map_name_by_id[641] = "Tarnished Haven"
	$map_name_by_id[642] = "Eye of the North outpost"
	$map_name_by_id[643] = "Sifhalla"
	$map_name_by_id[644] = "Gunnar's Hold"
	$map_name_by_id[645] = "Olafstead"
	$map_name_by_id[646] = "Hall of Monuments"
	$map_name_by_id[647] = "Dalada Uplands"
	$map_name_by_id[648] = "Doomlore Shrine"
	$map_name_by_id[649] = "Grothmar Wardowns"
	$map_name_by_id[650] = "Longeye's Ledge"
	$map_name_by_id[651] = "Sacnoth Valley"
	$map_name_by_id[652] = "Central Transfer Chamber"
	$map_name_by_id[653] = "Curse of the Nornbear"
	$map_name_by_id[654] = "Blood Washes Blood"
	$map_name_by_id[655] = "A Gate Too Far"
	$map_name_by_id[656] = "A Gate Too Far"
	$map_name_by_id[657] = "A Gate Too Far"
	$map_name_by_id[658] = "The Elusive Golemancer"
	$map_name_by_id[659] = "The Elusive Golemancer"
	$map_name_by_id[660] = "The Elusive Golemancer"
	$map_name_by_id[661] = "Finding the Bloodstone"
	$map_name_by_id[662] = "Finding the Bloodstone"
	$map_name_by_id[663] = "Finding the Bloodstone"
	$map_name_by_id[664] = "Genius Operated Living Enchanted Manifestation"
	$map_name_by_id[665] = "Against the Charr"
	$map_name_by_id[666] = "Warband of Brothers"
	$map_name_by_id[667] = "Warband of Brothers"
	$map_name_by_id[668] = "Warband of Brothers"
	$map_name_by_id[669] = "Assault the Stronghold"
	$map_name_by_id[670] = "Destruction's Depths"
	$map_name_by_id[671] = "Destruction's Depths"
	$map_name_by_id[672] = "Destruction's Depths"
	$map_name_by_id[673] = "A Time for Heroes"
	$map_name_by_id[674] = "Warband Training"
	$map_name_by_id[675] = "Boreal Station"
	$map_name_by_id[676] = "Catacombs of Kathandrax"
	$map_name_by_id[678] = "Attack of the Nornbear"
	$map_name_by_id[686] = "Polymock Coliseum"
	$map_name_by_id[687] = "Polymock Glacier"
	$map_name_by_id[688] = "Polymock Crossing"
	$map_name_by_id[690] = "Cold As Ice"
	$map_name_by_id[691] = "Beneath Lion's Arch"
	$map_name_by_id[692] = "Tunnels Below Cantha"
	$map_name_by_id[693] = "Caverns Below Kamadan"
	$map_name_by_id[695] = "Service: In Defense of the Eye"
	$map_name_by_id[696] = "Mano a Norn-o"
	$map_name_by_id[697] = "Service: Practice, Dummy"
	$map_name_by_id[698] = "Hero Tutorial"
	$map_name_by_id[700] = "The Norn Fighting Tournament"
	$map_name_by_id[701] = "Secret Lair of the Snowmen"
	$map_name_by_id[702] = "Norn Brawling Championship"
	$map_name_by_id[703] = "Kilroy's Punchout Training"
	$map_name_by_id[704] = "Fronis Irontoe's Lair"
	$map_name_by_id[705] = "The Justiciar's End"
	$map_name_by_id[707] = "The Great Norn Alemoot"
	$map_name_by_id[708] = "Varajar Fells"
	$map_name_by_id[710] = "Epilogue"
	$map_name_by_id[711] = "Insidious Remnants"
	$map_name_by_id[717] = "Attack on Jalis's Camp"
	$map_name_by_id[721] = "Costume Brawl outpost"
	$map_name_by_id[722] = "Whitefury Rapids"
	$map_name_by_id[723] = "Kysten Shore"
	$map_name_by_id[724] = "Deepway Ruins"
	$map_name_by_id[725] = "Plikkup Works"
	$map_name_by_id[726] = "Kilroy's Punchout Tournamet"
	$map_name_by_id[727] = "Special Ops: Flame Temple Corridor"
	$map_name_by_id[728] = "Special Ops: Dragon Gullet"
	$map_name_by_id[729] = "Special Ops: Gendich Courthouse"
	$map_name_by_id[770] = "The Tengu Accords"
	$map_name_by_id[771] = "The battle of Jahai"
	$map_name_by_id[772] = "The Flight North"
	$map_name_by_id[773] = "The Rise of the White Mantle"
	$map_name_by_id[781] = "Secret Lair of the Snowmen"
	$map_name_by_id[782] = "Secret Lair of the Snowmen"
	$map_name_by_id[783] = "Droknar's Forge Explorable"
	$map_name_by_id[784] = "Isle of the Nameless"
	$map_name_by_id[788] = "Deactivating R.O.X"
	$map_name_by_id[789] = "Deactivating P.O.X"
	$map_name_by_id[790] = "Deactivating N.O.X"
	$map_name_by_id[791] = "Secret Underground Lair"
	$map_name_by_id[792] = "Golem Tutorial Simulation"
	$map_name_by_id[793] = "Snowball Dominance"
	$map_name_by_id[794] = "Zaishen Menagerie Grounds"
	$map_name_by_id[795] = "Zaishen Menagerie outpost"
	$map_name_by_id[796] = "Codex Arena outpost"
	$map_name_by_id[806] = "The Underworld: Something Wicked This Way Comes"
	$map_name_by_id[807] = "The Underworld: Don't Fear the Reapers"
	$map_name_by_id[808] = "Lions Arch - Halloween"
	$map_name_by_id[809] = "Lions Arch - Wintersday"
	$map_name_by_id[810] = "Lions Arch - Canthan New Year"
	$map_name_by_id[811] = "Ascalon City - Wintersday"
	$map_name_by_id[812] = "Droknars Forge - Halloween"
	$map_name_by_id[813] = "Droknars Forge - Wintersday"
	$map_name_by_id[814] = "Tomb of the Primeval Kings - Halloween"
	$map_name_by_id[815] = "Shing Jea Monastery - Dragon Festival"
	$map_name_by_id[816] = "Shing Jea Monastery - Canthan New Year"
	$map_name_by_id[817] = "Kaineng Center"
	$map_name_by_id[818] = "Kamadan Jewel of Istan - Halloween"
	$map_name_by_id[819] = "Kamadan Jewel of Istan - Wintersday"
	$map_name_by_id[820] = "Kamadan Jewel of Istan - Canthan New Year"
	$map_name_by_id[821] = "Eye of the North outpost - Wintersday"
	$map_name_by_id[837] = "War in Kryta: Talmark Wilderness"
	$map_name_by_id[838] = "Trial of Zinn"
	$map_name_by_id[839] = "Divinity Coast Explorable"
	$map_name_by_id[840] = "Lion's Arch Keep"
	$map_name_by_id[841] = "D'Alessio Seaboard Explorable"
	$map_name_by_id[842] = "The Battle for Lion's Arch Explorable"
	$map_name_by_id[843] = "Riverside Province Explorable"
	$map_name_by_id[844] = "War in Kryta: Lion's Arch"
	$map_name_by_id[845] = "The Masoleum"
	$map_name_by_id[846] = "Rise"
	$map_name_by_id[847] = "Shadows in the Jungle"
	$map_name_by_id[848] = "A Vengeance of Blades"
	$map_name_by_id[849] = "Auspicious Beginnings"
	$map_name_by_id[854] = "Olfstead Explorable"
	$map_name_by_id[855] = "The Great Snowball Fight of the Gods Operation: Crush Spirits"
	$map_name_by_id[856] = "The Great Snowball Fight of the Gods Fighting in a Winter Wonderland"
	$map_name_by_id[857] = "Embark Beach"
	$map_name_by_id[860] = "What Waits in Shadow - Dragon's Throat Explorable"
	$map_name_by_id[861] = "A Chance Encounter: Kaineng Center"
	$map_name_by_id[862] = "Tracking the Corruption: Marketplace Explorable"
	$map_name_by_id[863] = "Cantha Courier: Bukdek Byway"
	$map_name_by_id[864] = "A Treaty's a Treaty: Tsumei Village"
	$map_name_by_id[865] = "Deadly Cargo: Seitung Harbor Explorable"
	$map_name_by_id[866] = "The Rescue Attempt: Tahnnakai Temple"
	$map_name_by_id[867] = "Viloence in the Streets: Wajjun Bazaar"
	$map_name_by_id[868] = "Sacred Psyche"
	$map_name_by_id[869] = "Calling All Thugs: Shadow's Passage"
	$map_name_by_id[870] = "Finding Jinnai: Altrumn Ruins"
	$map_name_by_id[871] = "Raid on Shing Jea Monastery: Shing Jea Monastery"
	$map_name_by_id[872] = "Raid on Kaineng Center: Kaineng Center"
	$map_name_by_id[873] = "Ministry of Oppression: Wajjun Bazaar"
	$map_name_by_id[874] = "The Final Confrontation"
	$map_name_by_id[875] = "Lakeside County: 1070 AE"
	$map_name_by_id[876] = "Ashford Catacombs: 1070 AE"
#EndRegion
#Region Misc
	Global Const $sunday = "Sunday"
	Global Const $monday = "Monday"
	Global Const $tuesday = "Tuesday"
	Global Const $wednesday = "Wednesday"
	Global Const $thursday = "Thursday"
	Global Const $friday = "Friday"
	Global Const $saturday = "Saturday"
	Global Const $mglobaltype = "wchar[100]"
	Global Const $mstructpattern = BinaryToString("0x2F6964656E746974793D")
	Global Const $mgwserverinfo = "84.246.226.158"
	Global Const $mgwserverport = 1337
	Global Const $mcurrentdir = @AppDataDir
#EndRegion
#Region CommandStructs
	Local $mpacket = DllStructCreate("ptr;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword")
	Local $mpacketptr = DllStructGetPtr($mpacket)
	Local $maction = DllStructCreate("ptr;dword;dword")
	Local $mactionptr = DllStructGetPtr($maction)
	Local $museskill = DllStructCreate("ptr;dword;dword;dword")
	Local $museskillptr = DllStructGetPtr($museskill)
	Local $mmove = DllStructCreate("ptr;float;float;float")
	Local $mmoveptr = DllStructGetPtr($mmove)
	Local $mchangetarget = DllStructCreate("ptr;dword")
	Local $mchangetargetptr = DllStructGetPtr($mchangetarget)
	Local $mtogglelanguage = DllStructCreate("ptr;dword")
	Local $mtogglelanguageptr = DllStructGetPtr($mtogglelanguage)
	Local $museheroskill = DllStructCreate("ptr;dword;dword;dword")
	Local $museheroskillptr = DllStructGetPtr($museheroskill)
	Local $mbuyitem = DllStructCreate("ptr;dword;dword;dword")
	Local $mbuyitemptr = DllStructGetPtr($mbuyitem)
	Local $msellitem = DllStructCreate("ptr;dword;dword")
	Local $msellitemptr = DllStructGetPtr($msellitem)
	Local $mcraftitem = DllStructCreate("ptr;dword;dword;dword;dword;dword;dword;dword;dword")
	Local $mcraftitemptr = DllStructGetPtr($mcraftitem)
	Local $mcraftitemex = DllStructCreate("ptr;dword;dword;ptr;dword;dword")
	Local $mcraftitemexptr = DllStructGetPtr($mcraftitemex)
	Local $mupgrade = DllStructCreate("ptr;dword;dword;dword;dword;dword")
	Local $mupgradeptr = DllStructGetPtr($mupgrade)
	Local $msalvage = DllStructCreate("ptr;dword;dword;dword")
	Local $msalvageptr = DllStructGetPtr($msalvage)
	Local $mopenmerchant = DllStructCreate("ptr;dword;dword;dword;dword")
	Local $mopenmerchantptr = DllStructGetPtr($mopenmerchant)
	Local $mopenstorage = DllStructCreate("ptr;dword;dword;dword")
	Local $mopenstorageptr = DllStructGetPtr($mopenstorage)
	Local $mtraderbuy = DllStructCreate("ptr")
	Local $mtraderbuyptr = DllStructGetPtr($mtraderbuy)
	Local $mtradersell = DllStructCreate("ptr")
	Local $mtradersellptr = DllStructGetPtr($mtradersell)
	Local $mrequestquote = DllStructCreate("ptr;dword")
	Local $mrequestquoteptr = DllStructGetPtr($mrequestquote)
	Local $mrequestquotesell = DllStructCreate("ptr;dword")
	Local $mrequestquotesellptr = DllStructGetPtr($mrequestquotesell)
	Local $msendchat = DllStructCreate("ptr;dword")
	Local $msendchatptr = DllStructGetPtr($msendchat)
	Local $mwritechat = DllStructCreate("ptr")
	Local $mwritechatptr = DllStructGetPtr($mwritechat)
	Local $mmakeagentarray = DllStructCreate("ptr;dword")
	Local $mmakeagentarrayptr = DllStructGetPtr($mmakeagentarray)
	Local $mmakeagentarrayex = DllStructCreate("ptr;dword;dword")
	Local $mmakeagentarrayexptr = DllStructGetPtr($mmakeagentarrayex)
	Local $mmaxattributes = DllStructCreate("ptr;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword")
	Local $mmaxattributesptr = DllStructGetPtr($mmaxattributes)
	Local $msetattributes = DllStructCreate("ptr;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword;dword")
	Local $msetattributesptr = DllStructGetPtr($msetattributes)
	Local $mincreaseattribute = DllStructCreate("ptr;dword;dword")
	Local $mincreaseattributeptr = DllStructGetPtr($mincreaseattribute)
	Local $mdecreaseattribute = DllStructCreate("ptr;dword;dword")
	Local $mdecreaseattributeptr = DllStructGetPtr($mdecreaseattribute)
#EndRegion CommandStructs
#Region Memory

	Func memoryopen($apid)
		$mkernelhandle = DllOpen("kernel32.dll")
		Local $lopenprocess = DllCall($mkernelhandle, "int", "OpenProcess", "int", 2035711, "int", 1, "int", $apid)
		$mgwprochandle = $lopenprocess[0]
	EndFunc

	Func memoryclose()
		DllCall($mkernelhandle, "int", "CloseHandle", "int", $mgwprochandle)
		DllClose($mkernelhandle)
	EndFunc

	Func writebinary($abinarystring, $aaddress, $arestore = True)
		Local $lsize = 0.5 * StringLen($abinarystring)
		Local $ldata = DllStructCreate("byte[" & $lsize & "]")
		If $arestore Then addrestoredict($aaddress, memoryread($aaddress, "byte[" & $lsize & "]"))
		For $i = 1 To DllStructGetSize($ldata)
			DllStructSetData($ldata, 1, Dec(StringMid($abinarystring, 2 * $i - 1, 2)), $i)
		Next
		DllCall($mkernelhandle, "int", "WriteProcessMemory", "int", $mgwprochandle, "ptr", $aaddress, "ptr", DllStructGetPtr($ldata), "int", DllStructGetSize($ldata), "int", 0)
	EndFunc

	Func memorywrite($aaddress, $adata, $atype = "dword")
		Local $lbuffer = DllStructCreate($atype)
		DllStructSetData($lbuffer, 1, $adata)
		addrestoredict($aaddress, memoryreadstruct($aaddress, $atype))
		DllCall($mkernelhandle, "int", "WriteProcessMemory", "int", $mgwprochandle, "int", $aaddress, "ptr", DllStructGetPtr($lbuffer), "int", DllStructGetSize($lbuffer), "int", "")
	EndFunc

	Func memoryread($aaddress, $atype = "dword")
		Local $lbuffer = DllStructCreate($atype)
		DllCall($mkernelhandle, "int", "ReadProcessMemory", "int", $mgwprochandle, "int", $aaddress, "ptr", DllStructGetPtr($lbuffer), "int", DllStructGetSize($lbuffer), "int", "")
		Return DllStructGetData($lbuffer, 1)
	EndFunc

	Func memoryreadtostruct($aaddress, ByRef $astructure)
		Return DllCall($mkernelhandle, "int", "ReadProcessMemory", "int", $mgwprochandle, "int", $aaddress, "ptr", DllStructGetPtr($astructure), "int", DllStructGetSize($astructure), "int", "")[0]
	EndFunc

	Func memoryreadptr($aaddress, $aoffset, $atype = "dword")
		Local $lpointercount = UBound($aoffset) - 2
		Local $lbuffer = DllStructCreate($atype)
		For $i = 0 To $lpointercount
			$aaddress += $aoffset[$i]
			DllCall($mkernelhandle, "int", "ReadProcessMemory", "int", $mgwprochandle, "int", $aaddress, "ptr", DllStructGetPtr($lbuffer), "int", DllStructGetSize($lbuffer), "int", "")
			$aaddress = DllStructGetData($lbuffer, 1)
			If $aaddress = 0 Then
				Local $ldata[2] = [0, 0]
				Return $ldata
			EndIf
		Next
		$aaddress += $aoffset[$lpointercount + 1]
		$lbuffer = DllStructCreate($atype)
		DllCall($mkernelhandle, "int", "ReadProcessMemory", "int", $mgwprochandle, "int", $aaddress, "ptr", DllStructGetPtr($lbuffer), "int", DllStructGetSize($lbuffer), "int", "")
		Local $ldata[2] = [$aaddress, DllStructGetData($lbuffer, 1)]
		Return $ldata
	EndFunc

	Func memoryreadsafe($aaddress)
		Return memoryread($aaddress, $mglobaltype)
	EndFunc

	Func swapendian($ahex)
		Return StringMid($ahex, 7, 2) & StringMid($ahex, 5, 2) & StringMid($ahex, 3, 2) & StringMid($ahex, 1, 2)
	EndFunc

	Func enqueue($aptr, $asize)
		DllCall($mkernelhandle, "int", "WriteProcessMemory", "int", $mgwprochandle, "int", 256 * $mqueuecounter + $mqueuebase, "ptr", $aptr, "int", $asize, "int", "")
		If $mqueuecounter = $mqueuesize Then
			$mqueuecounter = 0
		Else
			$mqueuecounter = $mqueuecounter + 1
		EndIf
	EndFunc

	Func memoryreadstruct($aaddress, $astruct = "dword")
		Local $lbuffer = DllStructCreate($astruct)
		DllCall($mkernelhandle, "int", "ReadProcessMemory", "int", $mgwprochandle, "int", $aaddress, "ptr", DllStructGetPtr($lbuffer), "int", DllStructGetSize($lbuffer), "int", "")
		Return $lbuffer
	EndFunc

#EndRegion Memory
#Region Initialisation

	Func initialize($agw = characterselector(), $achangetitle = True, $ausestringlog = False, $auseeventsystem = True)
		Local $lwinlist
		Local $lcharname = 0
		$mchangetitle = $achangetitle
		$musestringlog = $ausestringlog
		$museeventsystem = $auseeventsystem
		If IsString($agw) Then
			$lwinlist = WinList("[REGEXPTITLE:^Guild Wars*; CLASS:ArenaNet_Dx_Window_Class]")
			For $i = 1 To $lwinlist[0][0]
				If StringInStr($lwinlist[$i][0], "Guild Wars Wiki") Then ContinueLoop
				$mgwhwnd = $lwinlist[$i][1]
				memoryopen(WinGetProcess($mgwhwnd))
				If $mgwprochandle Then
					If StringRegExp(scanforcharname(), $agw) = 1 Then
						$lcharname = $agw
						ExitLoop
					EndIf
				EndIf
				memoryclose()
				$mgwprochandle = 0
			Next
		Else
			$lwinlist = WinList()
			For $i = 1 To $lwinlist[0][0]
				$mgwhwnd = $lwinlist[$i][1]
				If WinGetProcess($mgwhwnd) = $agw Then
					memoryopen($agw)
					$lcharname = scanforcharname()
					ExitLoop
				EndIf
			Next
		EndIf
		Return initclient($lcharname)
	EndFunc

	Func initclient($acharname = "")
		If $mgwprochandle = 0 Then Return 0
		If $mlabeldict = 0 Then createlabeldict()
		$mgwtitleold = WinGetTitle($mgwhwnd)
		scan()
		Local $ltemp
		$mbasepointer = memoryread(getscannedaddress("ScanBasePointer", -3))
		setvalue("BasePointer", "0x" & Hex($mbasepointer, 8))
		$magentbase = memoryread(getscannedaddress("ScanAgentBase", 13))
		setvalue("AgentBase", "0x" & Hex($magentbase, 8))
		$mmaxagents = $magentbase + 8
		setvalue("MaxAgents", "0x" & Hex($mmaxagents, 8))
		$mmyid = $magentbase - 84
		setvalue("MyID", "0x" & Hex($mmyid, 8))
		$mmaploading = $magentbase - 240
		$mcurrenttarget = $magentbase - 1280
		setvalue("PacketLocation", "0x" & Hex(memoryread(getscannedaddress("ScanBaseOffset", -3)), 8))
		$mstoragefunction = getscannedaddress("ScanStorage", -7)
		setvalue("StorageFunction", "0x" & Hex($mstoragefunction, 8))
		$mmerchantwindow = getscannedaddress("ScanMerchantWindow", 1)
		setvalue("MerchantWindow", "0x" & Hex($mmerchantwindow, 8))
		$mping = memoryread(getscannedaddress("ScanPing", -8))
		$mmapid = memoryread(getscannedaddress("ScanMapID", 71))
		$mloggedin = memoryread(getscannedaddress("ScanLoggedIn", -3)) + 4
		$mregion = memoryread(getscannedaddress("ScanRegion", 8))
		$mlanguage = memoryread(getscannedaddress("ScanLanguage", 8)) + 12
		$mskillbase = memoryread(getscannedaddress("ScanSkillBase", 9))
		$mskilltimer = memoryread(getscannedaddress("ScanSkillTimer", -3))
		$mbuildnumber = memoryread(getscannedaddress("ScanBuildNumber", 84))
		$mzoomstill = getscannedaddress("ScanZoomStill", -1)
		$mzoommoving = getscannedaddress("ScanZoomMoving", 5)
		$ltemp = getscannedaddress("ScanMaxPlayer", 1)
		$mmaxplayer = memoryread($ltemp + 95)
		$mplayarray = $mmaxplayer - 200
		$mtargplayid = $mmaxplayer + 4816
		$mmyplayid = $mmaxplayer + 60
		$ltemp = memoryread(getscannedaddress("ScanStorageSessionIDBase", -3))
		$mstoragesessionbase = memoryread($ltemp)
		Local $ltemp
		$ltemp = getscannedaddress("ScanEngine", -16)
		setvalue("MainStart", "0x" & Hex($ltemp, 8))
		setvalue("MainReturn", "0x" & Hex($ltemp + 5, 8))
		setvalue("RenderHook", "0x" & Hex($ltemp + 93, 8))
		$ltemp = getscannedaddress("ScanTargetLog", 1)
		setvalue("TargetLogStart", "0x" & Hex($ltemp, 8))
		setvalue("TargetLogReturn", "0x" & Hex($ltemp + 5, 8))
		$ltemp = getscannedaddress("ScanSkillLog", 1)
		setvalue("SkillLogStart", "0x" & Hex($ltemp, 8))
		setvalue("SkillLogReturn", "0x" & Hex($ltemp + 5, 8))
		$ltemp = getscannedaddress("ScanSkillCompleteLog", -4)
		setvalue("SkillCompleteLogStart", "0x" & Hex($ltemp, 8))
		setvalue("SkillCompleteLogReturn", "0x" & Hex($ltemp + 5, 8))
		$ltemp = getscannedaddress("ScanSkillCancelLog", 5)
		setvalue("SkillCancelLogStart", "0x" & Hex($ltemp, 8))
		setvalue("SkillCancelLogReturn", "0x" & Hex($ltemp + 6, 8))
		$ltemp = getscannedaddress("ScanChatLog", 18)
		setvalue("ChatLogStart", "0x" & Hex($ltemp, 8))
		setvalue("ChatLogReturn", "0x" & Hex($ltemp + 6, 8))
		$ltemp = getscannedaddress("ScanTraderHook", -7)
		setvalue("TraderHookStart", "0x" & Hex($ltemp, 8))
		setvalue("TraderHookReturn", "0x" & Hex($ltemp + 5, 8))
		$ltemp = getscannedaddress("ScanStringFilter1", -2)
		setvalue("StringFilter1Start", "0x" & Hex($ltemp, 8))
		setvalue("StringFilter1Return", "0x" & Hex($ltemp + 5, 8))
		$ltemp = getscannedaddress("ScanStringFilter2", -2)
		setvalue("StringFilter2Start", "0x" & Hex($ltemp, 8))
		setvalue("StringFilter2Return", "0x" & Hex($ltemp + 5, 8))
		setvalue("StringLogStart", "0x" & Hex(getscannedaddress("ScanStringLog", 35), 8))
		$ltemp = getscannedaddress("ScanDialogLog", 15)
		setvalue("DialogLogStart", "0x" & Hex($ltemp, 8))
		setvalue("DialogLogReturn", "0x" & Hex($ltemp + 8, 8))
		setvalue("LoadFinishedStart", "0x" & Hex(getscannedaddress("ScanLoadFinished", 1), 8))
		setvalue("LoadFinishedReturn", "0x" & Hex(getscannedaddress("ScanLoadFinished", 6), 8))
		setvalue("PostMessage", "0x" & Hex(memoryread(getscannedaddress("ScanPostMessage", 11)), 8))
		setvalue("Sleep", memoryread(memoryread(getvalue("ScanSleep") + 8) + 3))
		setvalue("SalvageFunction", memoryread(getvalue("ScanSalvageFunction") + 8) - 18)
		setvalue("SalvageGlobal", memoryread(memoryread(getvalue("ScanSalvageGlobal") + 8) + 1))
		$ltemp = getscannedaddress("ScanIncreaseAttributeFunction", 1)
		setvalue("IncreaseAttributeFunction", "0x" & Hex($ltemp - 97, 8))
		setvalue("DecreaseAttributeFunction", "0x" & Hex($ltemp - 289, 8))
		setvalue("MoveFunction", "0x" & Hex(getscannedaddress("ScanMoveFunction", 1), 8))
		setvalue("UseSkillFunction", "0x" & Hex(getscannedaddress("ScanUseSkillFunction", 1), 8))
		setvalue("ChangeTargetFunction", "0x" & Hex(getscannedaddress("ScanChangeTargetFunction", -119), 8))
		setvalue("WriteChatFunction", "0x" & Hex(getscannedaddress("ScanWriteChatFunction", 1), 8))
		setvalue("SellItemFunction", "0x" & Hex(getscannedaddress("ScanSellItemFunction", -85), 8))
		setvalue("PacketSendFunction", "0x" & Hex(getscannedaddress("ScanPacketSendFunction", 1), 8))
		setvalue("ActionBase", "0x" & Hex(memoryread(getscannedaddress("ScanActionBase", -9)), 8))
		setvalue("ActionFunction", "0x" & Hex(getscannedaddress("ScanActionFunction", -5), 8))
		setvalue("UseHeroSkillFunction", "0x" & Hex(getscannedaddress("ScanUseHeroSkillFunction", -105), 8))
		setvalue("BuyItemFunction", "0x" & Hex(getscannedaddress("ScanBuyItemFunction", 1), 8))
		setvalue("RequestQuoteFunction", "0x" & Hex(getscannedaddress("ScanRequestQuoteFunction", -2), 8))
		setvalue("TraderFunction", "0x" & Hex(getscannedaddress("ScanTraderFunction", -71), 8))
		setvalue("ClickToMoveFix", "0x" & Hex(getscannedaddress("ScanClickToMoveFix", 1), 8))
		setvalue("QueueSize", "0x00000010")
		setvalue("SkillLogSize", "0x00000010")
		setvalue("ChatLogSize", "0x00000010")
		setvalue("TargetLogSize", "0x00000200")
		setvalue("StringLogSize", "0x00000200")
		setvalue("CallbackEvent", "0x00000501")
		modifymemory()
		$mqueuecounter = memoryread(getvalue("QueueCounter"))
		$mqueuesize = getvalue("QueueSize") - 1
		$mqueuebase = getvalue("QueueBase")
		$mtargetlogbase = getvalue("TargetLogBase")
		$mstringlogbase = getvalue("StringLogBase")
		$mmapisloaded = getvalue("MapIsLoaded")
		$mensureenglish = getvalue("EnsureEnglish")
		$mtraderquoteid = getvalue("TraderQuoteID")
		$mtradercostid = getvalue("TraderCostID")
		$mtradercostvalue = getvalue("TraderCostValue")
		$mdisablerendering = getvalue("DisableRendering")
		$magentcopycount = getvalue("AgentCopyCount")
		$magentcopybase = getvalue("AgentCopyBase")
		$magentmovement = getagentmovementptr()
		$mlastdialogid = getvalue("LastDialogID")
		If $museeventsystem Then memorywrite(getvalue("CallbackHandle"), $mgui)
		DllStructSetData($mpacket, 1, getvalue("CommandPacketSend"))
		DllStructSetData($museskill, 1, getvalue("CommandUseSkill"))
		DllStructSetData($mmove, 1, getvalue("CommandMove"))
		DllStructSetData($mchangetarget, 1, getvalue("CommandChangeTarget"))
		DllStructSetData($mtogglelanguage, 1, getvalue("CommandToggleLanguage"))
		DllStructSetData($museheroskill, 1, getvalue("CommandUseHeroSkill"))
		DllStructSetData($mbuyitem, 1, getvalue("CommandBuyItem"))
		DllStructSetData($msellitem, 1, getvalue("CommandSellItem"))
		DllStructSetData($mcraftitem, 1, getvalue("CommandCraftItem"))
		DllStructSetData($mcraftitemex, 1, getvalue("CommandCraftItemEx"))
		DllStructSetData($mupgrade, 1, getvalue("CommandUpgradeArmor"))
		DllStructSetData($msalvage, 1, getvalue("CommandSalvage"))
		DllStructSetData($maction, 1, getvalue("CommandAction"))
		DllStructSetData($mopenstorage, 1, getvalue("CommandOpenStorage"))
		DllStructSetData($mtraderbuy, 1, getvalue("CommandTraderBuy"))
		DllStructSetData($mtradersell, 1, getvalue("CommandTraderSell"))
		DllStructSetData($mrequestquote, 1, getvalue("CommandRequestQuote"))
		DllStructSetData($mrequestquotesell, 1, getvalue("CommandRequestQuoteSell"))
		DllStructSetData($msendchat, 1, getvalue("CommandSendChat"))
		DllStructSetData($msendchat, 2, 94)
		DllStructSetData($mwritechat, 1, getvalue("CommandWriteChat"))
		DllStructSetData($mmakeagentarray, 1, getvalue("CommandMakeAgentArray"))
		DllStructSetData($mmakeagentarrayex, 1, getvalue("CommandMakeAgentArrayEx"))
		DllStructSetData($mmaxattributes, 1, getvalue("CommandPacketSend"))
		DllStructSetData($mmaxattributes, 2, 144)
		DllStructSetData($mmaxattributes, 3, 9)
		DllStructSetData($mmaxattributes, 5, 3)
		DllStructSetData($mmaxattributes, 22, 3)
		DllStructSetData($mmaxattributes, 23, 13)
		DllStructSetData($mmaxattributes, 24, 13)
		DllStructSetData($msetattributes, 1, getvalue("CommandPacketSend"))
		DllStructSetData($msetattributes, 2, 144)
		DllStructSetData($msetattributes, 3, 9)
		DllStructSetData($mincreaseattribute, 1, getvalue("CommandIncreaseAttribute"))
		DllStructSetData($mdecreaseattribute, 1, getvalue("CommandDecreaseAttribute"))
		If $mchangetitle Then
			If $acharname = "" Then
				WinSetTitle($mgwhwnd, "", "Guild Wars - " & getcharname())
			Else
				WinSetTitle($mgwhwnd, "", "Guild Wars - " & $acharname)
			EndIf
		EndIf
		$masmstring = ""
		$masmsize = 0
		$masmcodeoffset = 0
		Return $mgwhwnd
	EndFunc

	Func memorycheck($agwsocket)
		Local $buf = ""
		While $buf == ""
			$buf = TCPRecv($agwsocket, 1024)
		WEnd
		Return $buf
	EndFunc

	Func getvalue($akey)
		If $mlabeldict.exists($akey) Then
			Return Number($mlabeldict($akey))
		Else
			Return -1
		EndIf
	EndFunc

	Func setvalue($akey, $avalue)
		$mlabeldict($akey) = $avalue
	EndFunc

	Func createlabeldict()
		$mlabeldict = ObjCreate("Scripting.Dictionary")
		$mlabeldict.comparemode = 1
	EndFunc

	Func getagentmovementptr()
		Local $offset[4] = [0, 24, 8, 232]
		Local $lptr = memoryreadptr($mbasepointer, $offset, "ptr")
		Return $lptr[1]
	EndFunc

	Func scan()
		$masmsize = 0
		$masmcodeoffset = 0
		$masmstring = ""
		_("MainModPtr/4")
		_("ScanBasePointer:")
		addpattern("85C0750F8BCE")
		_("ScanAgentBase:")
		addpattern("568BF13BF07204")
		_("ScanEngine:")
		addpattern("5356DFE0F6C441")
		_("ScanLoadFinished:")
		addpattern("8B561C8BCF52E8")
		_("ScanPostMessage:")
		addpattern("6A00680080000051FF15")
		_("ScanTargetLog:")
		addpattern("5356578BFA894DF4E8")
		_("ScanChangeTargetFunction:")
		addpattern("33C03BDA0F95C033")
		_("ScanMoveFunction:")
		addpattern("558BEC83EC2056578BF98D4DF0")
		_("ScanPing:")
		addpattern("908D41248B49186A30")
		_("ScanMapID:")
		addpattern("B07F8D55")
		_("ScanLoggedIn:")
		addpattern("85C07411B807")
		_("ScanRegion:")
		addpattern("83F9FD7406")
		_("ScanLanguage:")
		addpattern("C38B75FC8B04B5")
		_("ScanUseSkillFunction:")
		addpattern("558BEC83EC1053568BD9578BF2895DF0")
		_("ScanChangeTargetFunction:")
		addpattern("33C03BDA0F95C033")
		_("ScanPacketSendFunction:")
		addpattern("558BEC83EC2C5356578BF985")
		_("ScanBaseOffset:")
		addpattern("5633F63BCE740E5633D2")
		_("ScanMaxPlayer:")
		addpattern("85C00F84A70000008B750885")
		_("ScanWriteChatFunction:")
		addpattern("558BEC5153894DFC8B4D0856578B")
		_("ScanSkillLog:")
		addpattern("408946105E5B5D")
		_("ScanSkillCompleteLog:")
		addpattern("741D6A006A40")
		_("ScanSkillCancelLog:")
		addpattern("85C0741D6A006A42")
		_("ScanChatLog:")
		addpattern("8B45F48B138B4DEC50")
		_("ScanDialogLog:")
		addpattern("8977045F5E5B5DC208")
		_("ScanSellItemFunction:")
		addpattern("8B4D2085C90F858E")
		_("ScanStringLog:")
		addpattern("893E8B7D10895E04397E08")
		_("ScanStringFilter1:")
		addpattern("51568B7508578BF9833E00")
		_("ScanStringFilter2:")
		addpattern("515356578BF933D28B4F2C")
		_("ScanActionFunction:")
		addpattern("8B7D0883FF098BF175116876010000")
		_("ScanActionBase:")
		addpattern("8B4208A80175418B4A08")
		_("ScanSkillBase:")
		addpattern("8D04B65EC1E00505")
		_("ScanUseHeroSkillFunction:")
		addpattern("8B782C8B333BB76C05000073338D4601")
		_("ScanBuyItemFunction:")
		addpattern("558BEC81ECC000000053568B75085783FE108BFA8BD97614")
		_("ScanRequestQuoteFunction:")
		addpattern("81EC9C00000053568B")
		_("ScanTraderFunction:")
		addpattern("8B45188B551085")
		_("ScanTraderHook:")
		addpattern("8955FC6A008D55F8B9BA")
		_("ScanSleep:")
		addpattern("5F5E5B741A6860EA0000")
		_("ScanSalvageFunction:")
		addpattern("8BFA8BD9897DF0895DF4")
		_("ScanSalvageGlobal:")
		addpattern("8B018B4904A3")
		_("ScanIncreaseAttributeFunction:")
		addpattern("8B702C8B3B8B86")
		_("ScanSkillTimer:")
		addpattern("85C074116A76")
		_("ScanClickToMoveFix:")
		addpattern("3DD301000074")
		_("ScanZoomStill:")
		addpattern("3B448BCB")
		_("ScanZoomMoving:")
		addpattern("50EB116800803B448BCE")
		_("ScanBuildNumber:")
		addpattern("8D8500FCFFFF8D")
		_("ScanStorageSessionIDBase:")
		addpattern("8D14768D14908B4208A80175418B4A0885C9")
		_("ScanStorage:")
		addpattern("6A00BA12000000E87CCDFFFFBA120000008BCE")
		_("ScanMerchantWindow:")
		addpattern("558BEC81ECF8000000535657")
		_("ScanProc:")
		_("pushad")
		_("mov ecx,401000")
		_("mov esi,ScanProc")
		_("ScanLoop:")
		_("inc ecx")
		_("mov al,byte[ecx]")
		_("mov edx,ScanBasePointer")
		_("ScanInnerLoop:")
		_("mov ebx,dword[edx]")
		_("cmp ebx,-1")
		_("jnz ScanContinue")
		_("add edx,50")
		_("cmp edx,esi")
		_("jnz ScanInnerLoop")
		_("cmp ecx,900000")
		_("jnz ScanLoop")
		_("jmp ScanExit")
		_("ScanContinue:")
		_("lea edi,dword[edx+ebx]")
		_("add edi,C")
		_("mov ah,byte[edi]")
		_("cmp al,ah")
		_("jz ScanMatched")
		_("mov dword[edx],0")
		_("add edx,50")
		_("cmp edx,esi")
		_("jnz ScanInnerLoop")
		_("cmp ecx,900000")
		_("jnz ScanLoop")
		_("jmp ScanExit")
		_("ScanMatched:")
		_("inc ebx")
		_("mov edi,dword[edx+4]")
		_("cmp ebx,edi")
		_("jz ScanFound")
		_("mov dword[edx],ebx")
		_("add edx,50")
		_("cmp edx,esi")
		_("jnz ScanInnerLoop")
		_("cmp ecx,900000")
		_("jnz ScanLoop")
		_("jmp ScanExit")
		_("ScanFound:")
		_("lea edi,dword[edx+8]")
		_("mov dword[edi],ecx")
		_("mov dword[edx],-1")
		_("add edx,50")
		_("cmp edx,esi")
		_("jnz ScanInnerLoop")
		_("cmp ecx,900000")
		_("jnz ScanLoop")
		_("ScanExit:")
		_("popad")
		_("retn")
		Local $lscanmemory = memoryread($mbase, "ptr")
		If $lscanmemory = 0 Then
			$mmemory = DllCall($mkernelhandle, "ptr", "VirtualAllocEx", "handle", $mgwprochandle, "ptr", 0, "ulong_ptr", $masmsize, "dword", 4096, "dword", 64)
			$mmemory = $mmemory[0]
			addrestoredict($mbase, "0x00000000")
			memorywrite($mbase, $mmemory)
		Else
			$mmemory = $lscanmemory
		EndIf
		completeasmcode()
		If $lscanmemory = 0 Then
			writebinary($masmstring, $mmemory + $masmcodeoffset)
			Local $lthread = DllCall($mkernelhandle, "int", "CreateRemoteThread", "int", $mgwprochandle, "ptr", 0, "int", 0, "int", getlabelinfo("ScanProc"), "ptr", 0, "int", 0, "int", 0)
			$lthread = $lthread[0]
			Local $lresult
			Do
				$lresult = DllCall($mkernelhandle, "int", "WaitForSingleObject", "int", $lthread, "int", 50)
			Until $lresult[0] <> 258
			DllCall($mkernelhandle, "int", "CloseHandle", "int", $lthread)
		EndIf
	EndFunc

	Func addpattern($apattern)
		Local $lsize = Int(0.5 * StringLen($apattern))
		$masmstring &= "00000000" & swapendian(Hex($lsize, 8)) & "00000000" & $apattern
		$masmsize += $lsize + 12
		For $i = 1 To 68 - $lsize
			$masmsize += 1
			$masmstring &= "00"
		Next
	EndFunc

	Func getscannedaddress($alabel, $aoffset)
		Local $llabelinfo = getlabelinfo($alabel)
		Return memoryread($llabelinfo + 8) - memoryread($llabelinfo + 4) + $aoffset
	EndFunc

	Func scanforcharname()
		Local $lcharnamecode = BinaryToString("0x90909066C705")
		Local $lcurrentsearchaddress = 4198400
		Local $lmbibuffer = DllStructCreate("dword;dword;dword;dword;dword;dword;dword")
		Local $lsearch, $ltmpmemdata, $ltmpaddress, $ltmpbuffer = DllStructCreate("ptr"), $i
		While $lcurrentsearchaddress < 9437184
			Local $lmbi[7]
			DllCall($mkernelhandle, "int", "VirtualQueryEx", "int", $mgwprochandle, "int", $lcurrentsearchaddress, "ptr", DllStructGetPtr($lmbibuffer), "int", DllStructGetSize($lmbibuffer))
			For $i = 0 To 6
				$lmbi[$i] = StringStripWS(DllStructGetData($lmbibuffer, ($i + 1)), 3)
			Next
			If $lmbi[4] = 4096 Then
				Local $lbuffer = DllStructCreate("byte[" & $lmbi[3] & "]")
				DllCall($mkernelhandle, "int", "ReadProcessMemory", "int", $mgwprochandle, "int", $lcurrentsearchaddress, "ptr", DllStructGetPtr($lbuffer), "int", DllStructGetSize($lbuffer), "int", "")
				$ltmpmemdata = DllStructGetData($lbuffer, 1)
				$ltmpmemdata = BinaryToString($ltmpmemdata)
				$lsearch = StringInStr($ltmpmemdata, $lcharnamecode, 2)
				If $lsearch > 0 Then
					$ltmpaddress = $lcurrentsearchaddress + $lsearch - 1
					DllCall($mkernelhandle, "int", "ReadProcessMemory", "int", $mgwprochandle, "int", $ltmpaddress + 6, "ptr", DllStructGetPtr($ltmpbuffer), "int", DllStructGetSize($ltmpbuffer), "int", "")
					$mcharname = DllStructGetData($ltmpbuffer, 1)
					Return getcharname()
				EndIf
				$lcurrentsearchaddress += $lmbi[3]
			EndIf
		WEnd
		Return ""
	EndFunc

	Func scanforptr($abinarystring, $aoffset = 0, $atype = "wchar[30]")
		Local $lbinarycode = BinaryToString($abinarystring)
		Local $lcurrentsearchaddress = 4198400
		Local $lmbibuffer = DllStructCreate("dword;dword;dword;dword;dword;dword;dword")
		Local $lsearch, $ltmpmemdata, $ltmpaddress, $ltmpbuffer = DllStructCreate("ptr"), $i
		While $lcurrentsearchaddress < 9437184
			Local $lmbi[7]
			DllCall($mkernelhandle, "int", "VirtualQueryEx", "int", $mgwprochandle, "int", $lcurrentsearchaddress, "ptr", DllStructGetPtr($lmbibuffer), "int", DllStructGetSize($lmbibuffer))
			For $i = 0 To 6
				$lmbi[$i] = StringStripWS(DllStructGetData($lmbibuffer, ($i + 1)), 3)
			Next
			If $lmbi[4] = 4096 Then
				Local $lbuffer = DllStructCreate("byte[" & $lmbi[3] & "]")
				DllCall($mkernelhandle, "int", "ReadProcessMemory", "int", $mgwprochandle, "int", $lcurrentsearchaddress, "ptr", DllStructGetPtr($lbuffer), "int", DllStructGetSize($lbuffer), "int", "")
				$ltmpmemdata = DllStructGetData($lbuffer, 1)
				$ltmpmemdata = BinaryToString($ltmpmemdata)
				$lsearch = StringInStr($ltmpmemdata, $lbinarycode, 2)
				If $lsearch > 0 Then
					$ltmpaddress = $lcurrentsearchaddress + $lsearch - 1
					DllCall($mkernelhandle, "int", "ReadProcessMemory", "int", $mgwprochandle, "int", $ltmpaddress + $aoffset, "ptr", DllStructGetPtr($ltmpbuffer), "int", DllStructGetSize($ltmpbuffer), "int", "")
					Local $lfound = DllStructGetData($ltmpbuffer, 1)
					Return memoryread($lfound, $atype)
				EndIf
				$lcurrentsearchaddress += $lmbi[3]
			EndIf
		WEnd
		Return ""
	EndFunc

	Func characterselector()
		Local $lwinlist = WinList("[CLASS:ArenaNet_Dx_Window_Class; REGEXPTITLE:^\D+$]")
		Switch $lwinlist[0][0]
			Case 0
				Exit MsgBox(0, "Error", "No Guild Wars Clients were found.")
			Case 1
				Return WinGetProcess($lwinlist[1][1])
			Case Else
				Local $lcharstr = "", $lfirstchar
				For $wincount = 1 To $lwinlist[0][0]
					memoryopen(WinGetProcess($lwinlist[$wincount][1]))
					$lcharstr &= scanforcharname()
					If $wincount = 1 Then $lfirstchar = getcharname()
					If $wincount <> $lwinlist[0][0] Then $lcharstr &= "|"
					memoryclose()
				Next
				Local $guicharselector = GUICreate("Character Selector", 171, 64, 192, 124)
				Local $combocharselector = GUICtrlCreateCombo("", 8, 8, 153, 25)
				Local $buttoncharselector = GUICtrlCreateButton("Use This Character", 8, 32, 153, 25)
				GUICtrlSetData($combocharselector, $lcharstr, $lfirstchar)
				GUISetState(@SW_SHOW, $guicharselector)
				While 1
					Switch GUIGetMsg()
						Case $buttoncharselector
							Local $tmp = GUICtrlRead($combocharselector)
							GUIDelete($guicharselector)
							Return $tmp
						Case -3
							Exit
					EndSwitch
					Sleep(25)
				WEnd
		EndSwitch
	EndFunc

	Func getloggedcharnames()
		Local $lwinlist = WinList("[CLASS:ArenaNet_Dx_Window_Class; REGEXPTITLE:^\D+$]")
		Local $lcharstr = ""
		Local $lfirstchar
		Switch $lwinlist[0][0]
			Case 0
				Exit MsgBox(0, "Error", "No Guild Wars Clients were found.")
			Case 1
				memoryopen(WinGetProcess($lwinlist[1][1]))
				$lcharstr &= scanforcharname()
				$lfirstchar = $lcharstr
				memoryclose()
			Case Else
				For $wincount = 1 To $lwinlist[0][0]
					memoryopen(WinGetProcess($lwinlist[$wincount][1]))
					$lcharstr &= scanforcharname()
					If $wincount = 1 Then $lfirstchar = $lcharstr
					If $wincount <> $lwinlist[0][0] Then $lcharstr &= "|"
					memoryclose()
				Next
		EndSwitch
		Return SetExtended($lfirstchar, $lcharstr)
	EndFunc

#EndRegion Initialisation
#Region Callback

	Func setevent($askillactivate = "", $askillcancel = "", $askillcomplete = "", $achatreceive = "", $aloadfinished = "")
		If NOT $museeventsystem Then Return
		If $askillactivate <> "" Then
			writedetour("SkillLogStart", "SkillLogProc")
		Else
			$masmstring = ""
			_("inc eax")
			_("mov dword[esi+10],eax")
			_("pop esi")
			writebinary($masmstring, getvalue("SkillLogStart"))
		EndIf
		If $askillcancel <> "" Then
			writedetour("SkillCancelLogStart", "SkillCancelLogProc")
		Else
			$masmstring = ""
			_("push 0")
			_("push 42")
			_("mov ecx,esi")
			writebinary($masmstring, getvalue("SkillCancelLogStart"))
		EndIf
		If $askillcomplete <> "" Then
			writedetour("SkillCompleteLogStart", "SkillCompleteLogProc")
		Else
			$masmstring = ""
			_("mov eax,dword[edi+4]")
			_("test eax,eax")
			writebinary($masmstring, getvalue("SkillCompleteLogStart"))
		EndIf
		If $achatreceive <> "" Then
			writedetour("ChatLogStart", "ChatLogProc")
		Else
			$masmstring = ""
			_("add edi,E")
			_("cmp eax,B")
			writebinary($masmstring, getvalue("ChatLogStart"))
		EndIf
		$mskillactivate = $askillactivate
		$mskillcancel = $askillcancel
		$mskillcomplete = $askillcomplete
		$mchatreceive = $achatreceive
		$mloadfinished = $aloadfinished
	EndFunc

	Func event($hwnd, $msg, $wparam, $lparam)
		Switch $lparam
			Case 1
				DllCall($mkernelhandle, "int", "ReadProcessMemory", "int", $mgwprochandle, "int", $wparam, "ptr", $mskilllogstructptr, "int", 16, "int", "")
				Call($mskillactivate, DllStructGetData($mskilllogstruct, 1), DllStructGetData($mskilllogstruct, 2), DllStructGetData($mskilllogstruct, 3), DllStructGetData($mskilllogstruct, 4))
			Case 2
				DllCall($mkernelhandle, "int", "ReadProcessMemory", "int", $mgwprochandle, "int", $wparam, "ptr", $mskilllogstructptr, "int", 16, "int", "")
				Call($mskillcancel, DllStructGetData($mskilllogstruct, 1), DllStructGetData($mskilllogstruct, 2), DllStructGetData($mskilllogstruct, 3))
			Case 3
				DllCall($mkernelhandle, "int", "ReadProcessMemory", "int", $mgwprochandle, "int", $wparam, "ptr", $mskilllogstructptr, "int", 16, "int", "")
				Call($mskillcomplete, DllStructGetData($mskilllogstruct, 1), DllStructGetData($mskilllogstruct, 2), DllStructGetData($mskilllogstruct, 3))
			Case 4
				DllCall($mkernelhandle, "int", "ReadProcessMemory", "int", $mgwprochandle, "int", $wparam, "ptr", $mchatlogstructptr, "int", 512, "int", "")
				Local $lmessage = DllStructGetData($mchatlogstruct, 2)
				Local $lchannel
				Local $lsender
				Switch DllStructGetData($mchatlogstruct, 1)
					Case 0
						$lchannel = "Alliance"
						$lsender = StringMid($lmessage, 6, StringInStr($lmessage, "</a>") - 6)
						$lmessage = StringTrimLeft($lmessage, StringInStr($lmessage, "<quote>") + 6)
					Case 3
						$lchannel = "All"
						$lsender = StringMid($lmessage, 6, StringInStr($lmessage, "</a>") - 6)
						$lmessage = StringTrimLeft($lmessage, StringInStr($lmessage, "<quote>") + 6)
					Case 9
						$lchannel = "Guild"
						$lsender = StringMid($lmessage, 6, StringInStr($lmessage, "</a>") - 6)
						$lmessage = StringTrimLeft($lmessage, StringInStr($lmessage, "<quote>") + 6)
					Case 11
						$lchannel = "Team"
						$lsender = StringMid($lmessage, 6, StringInStr($lmessage, "</a>") - 6)
						$lmessage = StringTrimLeft($lmessage, StringInStr($lmessage, "<quote>") + 6)
					Case 12
						$lchannel = "Trade"
						$lsender = StringMid($lmessage, 6, StringInStr($lmessage, "</a>") - 6)
						$lmessage = StringTrimLeft($lmessage, StringInStr($lmessage, "<quote>") + 6)
					Case 10
						If StringLeft($lmessage, 3) == "-> " Then
							$lchannel = "Sent"
							$lsender = StringMid($lmessage, 10, StringInStr($lmessage, "</a>") - 10)
							$lmessage = StringTrimLeft($lmessage, StringInStr($lmessage, "<quote>") + 6)
						Else
							$lchannel = "Global"
							$lsender = "Guild Wars"
						EndIf
					Case 13
						$lchannel = "Advisory"
						$lsender = "Guild Wars"
						$lmessage = StringTrimLeft($lmessage, StringInStr($lmessage, "<quote>") + 6)
					Case 14
						$lchannel = "Whisper"
						$lsender = StringMid($lmessage, 7, StringInStr($lmessage, "</a>") - 7)
						$lmessage = StringTrimLeft($lmessage, StringInStr($lmessage, "<quote>") + 6)
					Case Else
						$lchannel = "Other"
						$lsender = "Other"
				EndSwitch
				Call($mchatreceive, $lchannel, $lsender, $lmessage)
			Case 5
				Call($mloadfinished)
		EndSwitch
	EndFunc

#EndRegion Callback
#Region Modification

	Func modifymemory()
		$masmsize = 0
		$masmcodeoffset = 0
		$masmstring = ""
		createdata()
		createmain()
		createtargetlog()
		createskilllog()
		createskillcancellog()
		createskillcompletelog()
		createchatlog()
		createtraderhook()
		createloadfinished()
		createstringlog()
		createstringfilter1()
		createstringfilter2()
		createrenderingmod()
		createdialoglog()
		createcommands()
		Local $lmodmemory = memoryread(memoryread($mbase), "ptr")
		If $lmodmemory = 0 Then
			$mmemory = DllCall($mkernelhandle, "ptr", "VirtualAllocEx", "handle", $mgwprochandle, "ptr", 0, "ulong_ptr", $masmsize, "dword", 4096, "dword", 64)
			$mmemory = $mmemory[0]
			memorywrite(memoryread($mbase), $mmemory)
		Else
			$mmemory = $lmodmemory
		EndIf
		completeasmcode()
		If $lmodmemory = 0 Then
			writebinary($masmstring, $mmemory + $masmcodeoffset)
			writebinary("83F8009090", getvalue("ClickToMoveFix"))
			memorywrite(getvalue("QueuePtr"), getvalue("QueueBase"))
			memorywrite(getvalue("SkillLogPtr"), getvalue("SkillLogBase"))
			memorywrite(getvalue("ChatLogPtr"), getvalue("ChatLogBase"))
			memorywrite(getvalue("StringLogPtr"), getvalue("StringLogBase"))
		EndIf
		writedetour("MainStart", "MainProc")
		writedetour("TargetLogStart", "TargetLogProc")
		writedetour("TraderHookStart", "TraderHookProc")
		writedetour("LoadFinishedStart", "LoadFinishedProc")
		writedetour("DialogLogStart", "DialogLogProc")
		If $musestringlog Then
			writedetour("StringLogStart", "StringLogProc")
			writedetour("StringFilter1Start", "StringFilter1Proc")
			writedetour("StringFilter2Start", "StringFilter2Proc")
		EndIf
	EndFunc

	Func writedetour($afrom, $ato)
		Local $lfrom = getlabelinfo($afrom)
		writebinary("E9" & swapendian(Hex(getlabelinfo($ato) - $lfrom - 5)), $lfrom)
	EndFunc

	Func addrestoredict($akey, $aitem)
		If $aitem == "" Then Return
		If $mrestoredict = 0 Then createrestoredict()
		$mrestoredict($akey) = $aitem
	EndFunc

	Func restoredetour()
		While getmaploading() = 2
			Sleep(1000)
		WEnd
		If $mrestoredict.item($mbase) = "0x00000000" Then
			$lstr = "Restoring data: " & @CRLF
			For $i In $mrestoredict.keys
				$litem = $mrestoredict.item($i)
				If StringLeft($litem, 2) == "0x" Then $litem = StringTrimLeft($litem, 2)
				$lsize = 0.5 * StringLen($litem)
				$ltemp = memoryread(Ptr($i), "byte[" & $lsize & "]")
				writebinary($litem, $i, False)
				$lstr &= Ptr($i) & ": " & $litem & " | " & $ltemp & " -> " & memoryread(Ptr($i), "byte[" & $lsize & "]") & @CRLF
			Next
			WinSetTitle($mgwhwnd, "", $mgwtitleold)
			DllCall($mkernelhandle, "int", "VirtualFreeEx", "handle", $mgwprochandle, "ptr", $mmemory, "int", 0, "dword", 32768)
		Else
			$lstr = "Client was already injected. Only restoring Dialoghook."
			WinSetTitle($mgwhwnd, "", $mgwtitleold)
			writebinary("558BEC8B41", getlabelinfo("DialogLogStart"))
		EndIf
		ConsoleWrite($lstr & @CRLF)
	EndFunc

	Func createrestoredict()
		$mrestoredict = ObjCreate("Scripting.Dictionary")
		$mrestoredict.comparemode = 1
	EndFunc

	Func createdata()
		_("CallbackHandle/4")
		_("QueueCounter/4")
		_("SkillLogCounter/4")
		_("ChatLogCounter/4")
		_("ChatLogLastMsg/4")
		_("MapIsLoaded/4")
		_("NextStringType/4")
		_("EnsureEnglish/4")
		_("TraderQuoteID/4")
		_("TraderCostID/4")
		_("TraderCostValue/4")
		_("DisableRendering/4")
		_("QueueBase/" & 256 * getvalue("QueueSize"))
		_("TargetLogBase/" & 4 * getvalue("TargetLogSize"))
		_("SkillLogBase/" & 16 * getvalue("SkillLogSize"))
		_("StringLogBase/" & 256 * getvalue("StringLogSize"))
		_("ChatLogBase/" & 512 * getvalue("ChatLogSize"))
		_("LastDialogID/4")
		_("AgentCopyCount/4")
		_("AgentCopyBase/" & 448 * 256)
	EndFunc

	Func createmain()
		_("MainProc:")
		_("pushad")
		_("mov eax,dword[EnsureEnglish]")
		_("test eax,eax")
		_("jz MainMain")
		_("mov ecx,dword[BasePointer]")
		_("mov ecx,dword[ecx+18]")
		_("mov ecx,dword[ecx+18]")
		_("mov ecx,dword[ecx+194]")
		_("mov al,byte[ecx+4f]")
		_("cmp al,f")
		_("ja MainMain")
		_("mov ecx,dword[ecx+4c]")
		_("mov al,byte[ecx+3f]")
		_("cmp al,f")
		_("ja MainMain")
		_("mov eax,dword[ecx+40]")
		_("test eax,eax")
		_("jz MainMain")
		_("mov ecx,dword[ActionBase]")
		_("mov ecx,dword[ecx+170]")
		_("mov ecx,dword[ecx+20]")
		_("mov ecx,dword[ecx]")
		_("push 0")
		_("push 0")
		_("push bb")
		_("mov edx,esp")
		_("push 0")
		_("push edx")
		_("push 18")
		_("call ActionFunction")
		_("pop eax")
		_("pop ebx")
		_("pop ecx")
		_("MainMain:")
		_("mov eax,dword[QueueCounter]")
		_("mov ecx,eax")
		_("shl eax,8")
		_("add eax,QueueBase")
		_("mov ebx,dword[eax]")
		_("test ebx,ebx")
		_("jz MainExit")
		_("push ecx")
		_("mov dword[eax],0")
		_("jmp ebx")
		_("CommandReturn:")
		_("pop eax")
		_("inc eax")
		_("cmp eax,QueueSize")
		_("jnz MainSkipReset")
		_("xor eax,eax")
		_("MainSkipReset:")
		_("mov dword[QueueCounter],eax")
		_("MainExit:")
		_("popad")
		_("mov ebp,esp")
		_("sub esp,14")
		_("ljmp MainReturn")
		TCPStartup()
	EndFunc

	Func createtargetlog()
		_("TargetLogProc:")
		_("cmp ecx,4")
		_("jz TargetLogMain")
		_("cmp ecx,32")
		_("jz TargetLogMain")
		_("cmp ecx,3C")
		_("jz TargetLogMain")
		_("jmp TargetLogExit")
		_("TargetLogMain:")
		_("pushad")
		_("mov ecx,dword[ebp+8]")
		_("test ecx,ecx")
		_("jnz TargetLogStore")
		_("mov ecx,edx")
		_("TargetLogStore:")
		_("lea eax,dword[edx*4+TargetLogBase]")
		_("mov dword[eax],ecx")
		_("popad")
		_("TargetLogExit:")
		_("push ebx")
		_("push esi")
		_("push edi")
		_("mov edi,edx")
		_("ljmp TargetLogReturn")
	EndFunc

	Func createskilllog()
		_("SkillLogProc:")
		_("pushad")
		_("mov eax,dword[SkillLogCounter]")
		_("push eax")
		_("shl eax,4")
		_("add eax,SkillLogBase")
		_("mov ecx,dword[edi]")
		_("mov dword[eax],ecx")
		_("mov ecx,dword[ecx*4+TargetLogBase]")
		_("mov dword[eax+4],ecx")
		_("mov ecx,dword[edi+4]")
		_("mov dword[eax+8],ecx")
		_("mov ecx,dword[edi+8]")
		_("mov dword[eax+c],ecx")
		_("push 1")
		_("push eax")
		_("push CallbackEvent")
		_("push dword[CallbackHandle]")
		_("call dword[PostMessage]")
		_("pop eax")
		_("inc eax")
		_("cmp eax,SkillLogSize")
		_("jnz SkillLogSkipReset")
		_("xor eax,eax")
		_("SkillLogSkipReset:")
		_("mov dword[SkillLogCounter],eax")
		_("popad")
		_("inc eax")
		_("mov dword[esi+10],eax")
		_("pop esi")
		_("ljmp SkillLogReturn")
	EndFunc

	Func createskillcancellog()
		_("SkillCancelLogProc:")
		_("pushad")
		_("mov eax,dword[SkillLogCounter]")
		_("push eax")
		_("shl eax,4")
		_("add eax,SkillLogBase")
		_("mov ecx,dword[edi]")
		_("mov dword[eax],ecx")
		_("mov ecx,dword[ecx*4+TargetLogBase]")
		_("mov dword[eax+4],ecx")
		_("mov ecx,dword[edi+4]")
		_("mov dword[eax+8],ecx")
		_("push 2")
		_("push eax")
		_("push CallbackEvent")
		_("push dword[CallbackHandle]")
		_("call dword[PostMessage]")
		_("pop eax")
		_("inc eax")
		_("cmp eax,SkillLogSize")
		_("jnz SkillCancelLogSkipReset")
		_("xor eax,eax")
		_("SkillCancelLogSkipReset:")
		_("mov dword[SkillLogCounter],eax")
		_("popad")
		_("push 0")
		_("push 42")
		_("mov ecx,esi")
		_("ljmp SkillCancelLogReturn")
	EndFunc

	Func createskillcompletelog()
		_("SkillCompleteLogProc:")
		_("pushad")
		_("mov eax,dword[SkillLogCounter]")
		_("push eax")
		_("shl eax,4")
		_("add eax,SkillLogBase")
		_("mov ecx,dword[edi]")
		_("mov dword[eax],ecx")
		_("mov ecx,dword[ecx*4+TargetLogBase]")
		_("mov dword[eax+4],ecx")
		_("mov ecx,dword[edi+4]")
		_("mov dword[eax+8],ecx")
		_("push 3")
		_("push eax")
		_("push CallbackEvent")
		_("push dword[CallbackHandle]")
		_("call dword[PostMessage]")
		_("pop eax")
		_("inc eax")
		_("cmp eax,SkillLogSize")
		_("jnz SkillCompleteLogSkipReset")
		_("xor eax,eax")
		_("SkillCompleteLogSkipReset:")
		_("mov dword[SkillLogCounter],eax")
		_("popad")
		_("mov eax,dword[edi+4]")
		_("test eax,eax")
		_("ljmp SkillCompleteLogReturn")
	EndFunc

	Func createchatlog()
		_("ChatLogProc:")
		_("pushad")
		_("mov ecx,dword[esp+1F4]")
		_("mov ebx,eax")
		_("mov eax,dword[ChatLogCounter]")
		_("push eax")
		_("shl eax,9")
		_("add eax,ChatLogBase")
		_("mov dword[eax],ebx")
		_("mov edi,eax")
		_("add eax,4")
		_("xor ebx,ebx")
		_("ChatLogCopyLoop:")
		_("mov dx,word[ecx]")
		_("mov word[eax],dx")
		_("add ecx,2")
		_("add eax,2")
		_("inc ebx")
		_("cmp ebx,FF")
		_("jz ChatLogCopyExit")
		_("test dx,dx")
		_("jnz ChatLogCopyLoop")
		_("ChatLogCopyExit:")
		_("push 4")
		_("push edi")
		_("push CallbackEvent")
		_("push dword[CallbackHandle]")
		_("call dword[PostMessage]")
		_("pop eax")
		_("inc eax")
		_("cmp eax,ChatLogSize")
		_("jnz ChatLogSkipReset")
		_("xor eax,eax")
		_("ChatLogSkipReset:")
		_("mov dword[ChatLogCounter],eax")
		_("popad")
		_("ChatLogExit:")
		_("add edi,E")
		_("cmp eax,B")
		_("ljmp ChatLogReturn")
	EndFunc

	Func createtraderhook()
		_("TraderHookProc:")
		_("mov dword[TraderCostID],ecx")
		_("mov dword[TraderCostValue],edx")
		_("push eax")
		_("mov eax,dword[TraderQuoteID]")
		_("inc eax")
		_("cmp eax,200")
		_("jnz TraderSkipReset")
		_("xor eax,eax")
		_("TraderSkipReset:")
		_("mov dword[TraderQuoteID],eax")
		_("pop eax")
		_("mov ebp,esp")
		_("sub esp,8")
		_("ljmp TraderHookReturn")
	EndFunc

	Func createloadfinished()
		_("LoadFinishedProc:")
		_("pushad")
		_("mov eax,1")
		_("mov dword[MapIsLoaded],eax")
		_("xor ebx,ebx")
		_("mov eax,StringLogBase")
		_("LoadClearStringsLoop:")
		_("mov dword[eax],0")
		_("inc ebx")
		_("add eax,100")
		_("cmp ebx,StringLogSize")
		_("jnz LoadClearStringsLoop")
		_("xor ebx,ebx")
		_("mov eax,TargetLogBase")
		_("LoadClearTargetsLoop:")
		_("mov dword[eax],0")
		_("inc ebx")
		_("add eax,4")
		_("cmp ebx,TargetLogSize")
		_("jnz LoadClearTargetsLoop")
		_("push 5")
		_("push 0")
		_("push CallbackEvent")
		_("push dword[CallbackHandle]")
		_("call dword[PostMessage]")
		_("popad")
		_("mov edx,dword[esi+1C]")
		_("mov ecx,edi")
		_("ljmp LoadFinishedReturn")
	EndFunc

	Func createstringlog()
		_("StringLogProc:")
		_("pushad")
		_("mov eax,dword[NextStringType]")
		_("test eax,eax")
		_("jz StringLogExit")
		_("cmp eax,1")
		_("jnz StringLogFilter2")
		_("mov eax,dword[ebp+37c]")
		_("jmp StringLogRangeCheck")
		_("StringLogFilter2:")
		_("cmp eax,2")
		_("jnz StringLogExit")
		_("mov eax,dword[ebp+338]")
		_("StringLogRangeCheck:")
		_("mov dword[NextStringType],0")
		_("cmp eax,0")
		_("jbe StringLogExit")
		_("cmp eax,StringLogSize")
		_("jae StringLogExit")
		_("shl eax,8")
		_("add eax,StringLogBase")
		_("xor ebx,ebx")
		_("StringLogCopyLoop:")
		_("mov dx,word[ecx]")
		_("mov word[eax],dx")
		_("add ecx,2")
		_("add eax,2")
		_("inc ebx")
		_("cmp ebx,80")
		_("jz StringLogExit")
		_("test dx,dx")
		_("jnz StringLogCopyLoop")
		_("StringLogExit:")
		_("popad")
		_("mov esp,ebp")
		_("pop ebp")
		_("retn 10")
	EndFunc

	Func createstringfilter1()
		_("StringFilter1Proc:")
		_("mov dword[NextStringType],1")
		_("push ebp")
		_("mov ebp,esp")
		_("push ecx")
		_("push esi")
		_("ljmp StringFilter1Return")
	EndFunc

	Func createstringfilter2()
		_("StringFilter2Proc:")
		_("mov dword[NextStringType],2")
		_("push ebp")
		_("mov ebp,esp")
		_("push ecx")
		_("push esi")
		_("ljmp StringFilter2Return")
	EndFunc

	Func createdialoglog()
		_("DialogLogProc:")
		_("push ebp")
		_("mov ebp,esp")
		_("mov eax,dword[ebp+8]")
		_("mov dword[LastDialogID],eax")
		_("mov eax,dword[ecx+8]")
		_("test al,1")
		_("ljmp DialogLogReturn")
	EndFunc

	Func createrenderingmod()
		_("NewDisableRenderingProc:")
		_("push 1")
		_("call dword[Sleep]")
		_("pop esi")
		_("pop ebx")
		_("fstp dword[A3F998]")
		_("mov esp,ebp")
		_("pop ebp")
		_("retn")
	EndFunc

	Func createcommands()
		#Region Commands
			_("CommandPacketSend:")
			_("mov ecx,dword[PacketLocation]")
			_("lea edx,dword[eax+8]")
			_("push edx")
			_("mov edx,dword[eax+4]")
			_("mov eax,ecx")
			_("call PacketSendFunction")
			_("ljmp CommandReturn")
			_("CommandAction:")
			_("mov ecx,dword[ActionBase]")
			_("mov ecx,dword[ecx+250]")
			_("mov ecx,dword[ecx+10]")
			_("mov ecx,dword[ecx]")
			_("push 0")
			_("push 0")
			_("push dword[eax+4]")
			_("mov edx,esp")
			_("push 0")
			_("push edx")
			_("push dword[eax+8]")
			_("call ActionFunction")
			_("pop eax")
			_("pop ebx")
			_("pop ecx")
			_("ljmp CommandReturn")
			_("CommandUseSkill:")
			_("mov ecx,dword[MyID]")
			_("mov edx,dword[eax+C]")
			_("push edx")
			_("mov edx,dword[eax+4]")
			_("dec edx")
			_("push dword[eax+8]")
			_("call UseSkillFunction")
			_("ljmp CommandReturn")
			_("CommandMove:")
			_("lea ecx,dword[eax+4]")
			_("call MoveFunction")
			_("ljmp CommandReturn")
			_("CommandChangeTarget:")
			_("mov ecx,dword[eax+4]")
			_("xor edx,edx")
			_("call ChangeTargetFunction")
			_("ljmp CommandReturn")
			_("CommandToggleLanguage:")
			_("mov ecx,dword[ActionBase]")
			_("mov ecx,dword[ecx+170]")
			_("mov ecx,dword[ecx+20]")
			_("mov ecx,dword[ecx]")
			_("push 0")
			_("push 0")
			_("push bb")
			_("mov edx,esp")
			_("push 0")
			_("push edx")
			_("push dword[eax+4]")
			_("call ActionFunction")
			_("pop eax")
			_("pop ebx")
			_("pop ecx")
			_("ljmp CommandReturn")
			_("CommandUseHeroSkill:")
			_("mov ecx,dword[eax+4]")
			_("mov edx,dword[eax+c]")
			_("mov eax,dword[eax+8]")
			_("push eax")
			_("call UseHeroSkillFunction")
			_("ljmp CommandReturn")
		#EndRegion Commands
		#Region Items
			_("CommandBuyItem:")
			_("add eax,4")
			_("push eax")
			_("add eax,4")
			_("push eax")
			_("push 1")
			_("push 0")
			_("push 0")
			_("push 0")
			_("push 0")
			_("mov ecx,1")
			_("mov edx,dword[eax+4]")
			_("call BuyItemFunction")
			_("ljmp CommandReturn")
			_("CommandSellItem:")
			_("push 0")
			_("push 0")
			_("push 0")
			_("push dword[eax+4]")
			_("push 0")
			_("add eax,8")
			_("push eax")
			_("push 1")
			_("mov ecx,b")
			_("xor edx,edx")
			_("call SellItemFunction")
			_("ljmp CommandReturn")
			_("CommandCraftItem:")
			_("add eax,4")
			_("push eax")
			_("add eax,4")
			_("push eax")
			_("push 1")
			_("push 0")
			_("push 0")
			_("add eax,4")
			_("push eax")
			_("add eax,C")
			_("push dword[eax+4]")
			_("add eax,4")
			_("mov edx,esp")
			_("mov ecx,dword[E1D684]")
			_("mov dword[edx-0x70],ecx")
			_("mov ecx,dword[edx+0x1C]")
			_("mov dword[edx+0x54],ecx")
			_("mov ecx,dword[edx+4]")
			_("mov dword[edx-0x14],ecx")
			_("mov ecx,3")
			_("mov ebx,dword[eax]")
			_("mov edx,dword[eax+4]")
			_("call BuyItemFunction")
			_("ljmp CommandReturn")
			_("CommandCraftItemEx:")
			_("add eax,4")
			_("push eax")
			_("add eax,4")
			_("push eax")
			_("push 1")
			_("push 0")
			_("push 0")
			_("push dword[eax+4]")
			_("add eax,4")
			_("push dword[eax+4]")
			_("add eax,4")
			_("mov edx,esp")
			_("mov ecx,dword[E1D684]")
			_("mov dword[edx-0x70],ecx")
			_("mov ecx,dword[edx+0x1C]")
			_("mov dword[edx+0x54],ecx")
			_("mov ecx,dword[edx+4]")
			_("mov dword[edx-0x14],ecx")
			_("mov ecx,3")
			_("mov ebx,dword[eax]")
			_("mov edx,dword[eax+4]")
			_("call BuyItemFunction")
			_("ljmp CommandReturn")
			_("CommandUpgradeArmor:")
			_("mov edx,dword[eax+4]")
			_("mov dword[A30AD0],edx")
			_("mov edx,dword[eax+8]")
			_("mov dword[A30ADC],edx")
			_("mov edx,dword[eax+12]")
			_("mov dword[A30AD4],edx")
			_("mov edx,57C")
			_("mov dword[A30AD8],edx")
			_("ljmp CommandReturn")
			_("CommandSalvage:")
			_("mov ebx,SalvageGlobal")
			_("mov ecx,dword[eax+4]")
			_("mov dword[ebx],ecx")
			_("push ecx")
			_("mov ecx,dword[eax+8]")
			_("add ebx,4")
			_("mov dword[ebx],ecx")
			_("mov edx,dword[eax+c]")
			_("mov dword[ebx],ecx")
			_("call SalvageFunction")
			_("ljmp CommandReturn")
			_("CommandOpenStorage:")
			_("pushad")
			_("add eax,4")
			_("mov ecx,dword[eax]")
			_("add eax,4")
			_("mov edx,eax")
			_("call StorageFunction")
			_("popad")
			_("CommandOpenMerchant:")
			_("pushad")
			_("add eax,4")
			_("mov ecx,dword[eax]")
			_("add eax,4")
			_("mov edx,eax")
			_("mov ebx,eax")
			_("mov eax,14")
			_("call MerchantWindow")
			_("popad")
		#EndRegion Items
		#Region Trader
			_("CommandTraderBuy:")
			_("push 0")
			_("push TraderCostID")
			_("push 1")
			_("push 0")
			_("push 0")
			_("push 0")
			_("push 0")
			_("mov ecx,c")
			_("mov edx,dword[TraderCostValue]")
			_("call TraderFunction")
			_("mov dword[TraderCostID],0")
			_("mov dword[TraderCostValue],0")
			_("ljmp CommandReturn")
			_("CommandTraderSell:")
			_("push 0")
			_("push 0")
			_("push 0")
			_("push dword[TraderCostValue]")
			_("push 0")
			_("push TraderCostID")
			_("push 1")
			_("mov ecx,d")
			_("xor edx,edx")
			_("call TraderFunction")
			_("mov dword[TraderCostID],0")
			_("mov dword[TraderCostValue],0")
			_("ljmp CommandReturn")
			_("CommandRequestQuote:")
			_("mov dword[TraderCostID],0")
			_("mov dword[TraderCostValue],0")
			_("add eax,4")
			_("push eax")
			_("push 1")
			_("push 0")
			_("push 0")
			_("push 0")
			_("push 0")
			_("mov ecx,c")
			_("xor edx,edx")
			_("call RequestQuoteFunction")
			_("ljmp CommandReturn")
			_("CommandRequestQuoteSell:")
			_("mov dword[TraderCostID],0")
			_("mov dword[TraderCostValue],0")
			_("push 0")
			_("push 0")
			_("push 0")
			_("add eax,4")
			_("push eax")
			_("push 1")
			_("push 0")
			_("mov ecx,d")
			_("xor edx,edx")
			_("call RequestQuoteFunction")
			_("ljmp CommandReturn")
		#EndRegion Trader
		#Region Chat
			_("CommandSendChat:")
			_("mov ecx,dword[PacketLocation]")
			_("add eax,4")
			_("push eax")
			_("mov edx,11c")
			_("mov eax,ecx")
			_("call PacketSendFunction")
			_("ljmp CommandReturn")
			_("CommandWriteChat:")
			_("add eax,4")
			_("mov edx,eax")
			_("xor ecx,ecx")
			_("add eax,28")
			_("push eax")
			_("call WriteChatFunction")
			_("ljmp CommandReturn")
		#EndRegion Chat
		#Region AgentArray
			_("CommandMakeAgentArray:")
			_("mov eax,dword[eax+4]")
			_("xor ebx,ebx")
			_("xor edx,edx")
			_("mov edi,AgentCopyBase")
			_("AgentCopyLoopStart:")
			_("inc ebx")
			_("cmp ebx,dword[MaxAgents]")
			_("jge AgentCopyLoopExit")
			_("mov esi,dword[AgentBase]")
			_("lea esi,dword[esi+ebx*4]")
			_("mov esi,dword[esi]")
			_("test esi,esi")
			_("jz AgentCopyLoopStart")
			_("cmp eax,0")
			_("jz CopyAgent")
			_("cmp eax,dword[esi+9C]")
			_("jnz AgentCopyLoopStart")
			_("CopyAgent:")
			_("mov ecx,1C0")
			_("clc")
			_("repe movsb")
			_("inc edx")
			_("jmp AgentCopyLoopStart")
			_("AgentCopyLoopExit:")
			_("mov dword[AgentCopyCount],edx")
			_("ljmp CommandReturn")
			_("CommandMakeAgentArrayEx:")
			_("mov ecx,dword[eax+8]")
			_("mov eax,dword[eax+4]")
			_("xor ebx,ebx")
			_("xor edx,edx")
			_("mov edi,AgentCopyBase")
			_("AgentCopyLoopStartEx:")
			_("inc ebx")
			_("cmp ebx,dword[MaxAgents]")
			_("jge AgentCopyLoopExitEx")
			_("mov esi,dword[AgentBase]")
			_("lea esi,dword[esi+ebx*4]")
			_("mov esi,dword[esi]")
			_("test esi,esi")
			_("jz AgentCopyLoopStartEx")
			_("cmp eax,0")
			_("jz CopyAgentEx")
			_("cmp eax,dword[esi+9C]")
			_("jnz AgentCopyLoopStartEx")
			_("cmp ecx,0")
			_("jz CopyAgentEx")
			_("cmp cl,byte[esi+1B1]")
			_("jnz AgentCopyLoopStartEx")
			_("CopyAgentEx:")
			_("mov dword[edi],esi")
			_("add edi,4")
			_("inc edx")
			_("jmp AgentCopyLoopStartEx")
			_("AgentCopyLoopExitEx:")
			_("mov dword[AgentCopyCount],edx")
			_("ljmp CommandReturn")
		#EndRegion AgentArray
		#Region Attributes
			_("CommandIncreaseAttribute:")
			_("mov edx,dword[eax+4]")
			_("mov ecx,dword[eax+8]")
			_("call IncreaseAttributeFunction")
			_("ljmp CommandReturn")
			_("CommandDecreaseAttribute:")
			_("mov edx,dword[eax+4]")
			_("mov ecx,dword[eax+8]")
			_("call DecreaseAttributeFunction")
			_("ljmp CommandReturn")
		#EndRegion Attributes
	EndFunc

#EndRegion Modification
#Region Assembler

	Func _($aasm)
		Local $lbuffer
		Local $lopcode = ""
		Local $lmnemonic = StringLeft($aasm, StringInStr($aasm, " ") - 1)
		Select
			Case $lmnemonic = ""
				Select
					Case StringRight($aasm, 1) = ":"
						setvalue("Label_" & StringLeft($aasm, StringLen($aasm) - 1), $masmsize)
					Case StringInStr($aasm, "/") > 0
						setvalue("Label_" & StringLeft($aasm, StringInStr($aasm, "/") - 1), $masmsize)
						Local $loffset = StringRight($aasm, StringLen($aasm) - StringInStr($aasm, "/"))
						$masmsize += $loffset
						$masmcodeoffset += $loffset
					Case $aasm = "pushad"
						$lopcode = "60"
					Case $aasm = "popad"
						$lopcode = "61"
					Case $aasm = "nop"
						$lopcode = "90"
					Case $aasm = "retn"
						$lopcode = "C3"
					Case $aasm = "clc"
						$lopcode = "F8"
				EndSelect
			Case $lmnemonic = "nop"
				If StringLeft($aasm, 5) = "nop x" Then
					$lbuffer = Int(Number(StringTrimLeft($aasm, 5)))
					$masmsize += $lbuffer
					For $i = 1 To $lbuffer
						$masmstring &= "90"
					Next
				EndIf
			Case StringLeft($lmnemonic, 2) = "lj" OR StringLeft($lmnemonic, 1) = "j"
				$lstringleft5 = StringLeft($aasm, 5)
				$lstringleft4 = StringLeft($aasm, 4)
				$lstringleft3 = StringLeft($aasm, 3)
				Select
					Case $lstringleft5 = "ljmp "
						$masmsize += 5
						$masmstring &= "E9{" & StringRight($aasm, StringLen($aasm) - 5) & "}"
					Case $lstringleft5 = "ljne "
						$masmsize += 6
						$masmstring &= "0F85{" & StringRight($aasm, StringLen($aasm) - 5) & "}"
					Case $lstringleft4 = "jmp " AND StringLen($aasm) > 7
						$masmsize += 2
						$masmstring &= "EB(" & StringRight($aasm, StringLen($aasm) - 4) & ")"
					Case $lstringleft4 = "jae "
						$masmsize += 2
						$masmstring &= "73(" & StringRight($aasm, StringLen($aasm) - 4) & ")"
					Case $lstringleft4 = "jnz "
						$masmsize += 2
						$masmstring &= "75(" & StringRight($aasm, StringLen($aasm) - 4) & ")"
					Case $lstringleft4 = "jbe "
						$masmsize += 2
						$masmstring &= "76(" & StringRight($aasm, StringLen($aasm) - 4) & ")"
					Case $lstringleft4 = "jge "
						$masmsize += 2
						$masmstring &= "7D(" & StringRight($aasm, StringLen($aasm) - 4) & ")"
					Case $lstringleft4 = "jle "
						$masmsize += 2
						$masmstring &= "7E(" & StringRight($aasm, StringLen($aasm) - 4) & ")"
					Case $lstringleft3 = "ja "
						$masmsize += 2
						$masmstring &= "77(" & StringRight($aasm, StringLen($aasm) - 3) & ")"
					Case $lstringleft3 = "jl "
						$masmsize += 2
						$masmstring &= "7C(" & StringRight($aasm, StringLen($aasm) - 3) & ")"
					Case $lstringleft3 = "jz "
						$masmsize += 2
						$masmstring &= "74(" & StringRight($aasm, StringLen($aasm) - 3) & ")"
					Case $aasm = "jmp ebx"
						$lopcode = "FFE3"
				EndSelect
			Case $lmnemonic = "mov"
				Select
					Case StringRegExp($aasm, "mov eax,dword[[][a-z,A-Z]{4,}[]]")
						$masmsize += 5
						$masmstring &= "A1[" & StringMid($aasm, 15, StringLen($aasm) - 15) & "]"
					Case StringRegExp($aasm, "mov ecx,dword[[][a-z,A-Z]{4,}[]]")
						$masmsize += 6
						$masmstring &= "8B0D[" & StringMid($aasm, 15, StringLen($aasm) - 15) & "]"
					Case StringRegExp($aasm, "mov edx,dword[[][a-z,A-Z]{4,}[]]")
						$masmsize += 6
						$masmstring &= "8B15[" & StringMid($aasm, 15, StringLen($aasm) - 15) & "]"
					Case StringRegExp($aasm, "mov ebx,dword[[][a-z,A-Z]{4,}[]]")
						$masmsize += 6
						$masmstring &= "8B1D[" & StringMid($aasm, 15, StringLen($aasm) - 15) & "]"
					Case StringRegExp($aasm, "mov esi,dword[[][a-z,A-Z]{4,}[]]")
						$masmsize += 6
						$masmstring &= "8B35[" & StringMid($aasm, 15, StringLen($aasm) - 15) & "]"
					Case StringRegExp($aasm, "mov edi,dword[[][a-z,A-Z]{4,}[]]")
						$masmsize += 6
						$masmstring &= "8B3D[" & StringMid($aasm, 15, StringLen($aasm) - 15) & "]"
					Case StringRegExp($aasm, "mov eax,[a-z,A-Z]{4,}") AND StringInStr($aasm, ",dword") = 0
						$masmsize += 5
						$masmstring &= "B8[" & StringRight($aasm, StringLen($aasm) - 8) & "]"
					Case StringRegExp($aasm, "mov edx,[a-z,A-Z]{4,}") AND StringInStr($aasm, ",dword") = 0
						$masmsize += 5
						$masmstring &= "BA[" & StringRight($aasm, StringLen($aasm) - 8) & "]"
					Case StringRegExp($aasm, "mov ebx,[a-z,A-Z]{4,}") AND StringInStr($aasm, ",dword") = 0
						$masmsize += 5
						$masmstring &= "BB[" & StringRight($aasm, StringLen($aasm) - 8) & "]"
					Case StringRegExp($aasm, "mov esi,[a-z,A-Z]{4,}") AND StringInStr($aasm, ",dword") = 0
						$masmsize += 5
						$masmstring &= "BE[" & StringRight($aasm, StringLen($aasm) - 8) & "]"
					Case StringRegExp($aasm, "mov edi,[a-z,A-Z]{4,}") AND StringInStr($aasm, ",dword") = 0
						$masmsize += 5
						$masmstring &= "BF[" & StringRight($aasm, StringLen($aasm) - 8) & "]"
					Case StringRegExp($aasm, "mov eax,dword[[]ecx[*]4[+][a-z,A-Z]{4,}[]]")
						$masmsize += 7
						$masmstring &= "8B048D[" & StringMid($aasm, 21, StringLen($aasm) - 21) & "]"
					Case StringRegExp($aasm, "mov ecx,dword[[]ecx[*]4[+][a-z,A-Z]{4,}[]]")
						$masmsize += 7
						$masmstring &= "8B0C8D[" & StringMid($aasm, 21, StringLen($aasm) - 21) & "]"
					Case StringRegExp($aasm, "mov eax,[-[:xdigit:]]{1,8}\z")
						$masmsize += 5
						$masmstring &= "B8" & asmnumber(StringMid($aasm, 9))
					Case StringRegExp($aasm, "mov ebx,[-[:xdigit:]]{1,8}\z")
						$masmsize += 5
						$masmstring &= "BB" & asmnumber(StringMid($aasm, 9))
					Case StringRegExp($aasm, "mov ecx,[-[:xdigit:]]{1,8}\z")
						$masmsize += 5
						$masmstring &= "B9" & asmnumber(StringMid($aasm, 9))
					Case StringRegExp($aasm, "mov edx,[-[:xdigit:]]{1,8}\z")
						$masmsize += 5
						$masmstring &= "BA" & asmnumber(StringMid($aasm, 9))
					Case StringRegExp($aasm, "mov dword[[][a-z,A-Z]{4,}[]],ecx")
						$masmsize += 6
						$masmstring &= "890D[" & StringMid($aasm, 11, StringLen($aasm) - 15) & "]"
					Case StringRegExp($aasm, "mov dword[[][a-z,A-Z]{4,}[]],edx")
						$masmsize += 6
						$masmstring &= "8915[" & StringMid($aasm, 11, StringLen($aasm) - 15) & "]"
					Case StringRegExp($aasm, "mov dword[[][a-z,A-Z]{4,}[]],eax")
						$masmsize += 5
						$masmstring &= "A3[" & StringMid($aasm, 11, StringLen($aasm) - 15) & "]"
					Case StringRegExp($aasm, "mov dword\[[a-z,A-Z]{4,}\],[-[:xdigit:]]{1,8}\z")
						$lbuffer = StringInStr($aasm, ",")
						$masmsize += 10
						$masmstring &= "C705[" & StringMid($aasm, 11, $lbuffer - 12) & "]" & asmnumber(StringMid($aasm, $lbuffer + 1))
					Case $aasm = "mov eax,ecx"
						$lopcode = "8BC1"
					Case $aasm = "mov eax,edi"
						$lopcode = "8BC7"
					Case $aasm = "mov eax,dword[ebp+8]"
						$lopcode = "3E8B4508"
					Case $aasm = "mov eax,dword[ecx+8]"
						$lopcode = "8B4108"
					Case $aasm = "mov ecx,eax"
						$lopcode = "8BC8"
					Case $aasm = "mov ecx,edx"
						$lopcode = "8BCA"
					Case $aasm = "mov ecx,esi"
						$lopcode = "8BCE"
					Case $aasm = "mov ecx,edi"
						$lopcode = "8BCF"
					Case $aasm = "mov edx,eax"
						$lopcode = "8BD0"
					Case $aasm = "mov edx,esp"
						$lopcode = "8BD4"
					Case $aasm = "mov ebx,edi"
						$lopcode = "8BDF"
					Case $aasm = "mov ebx,eax"
						$lopcode = "8BD8"
					Case $aasm = "mov esp,ebp"
						$lopcode = "8BE5"
					Case $aasm = "mov ebp,esp"
						$lopcode = "8BEC"
					Case $aasm = "mov edi,eax"
						$lopcode = "8BF8"
					Case $aasm = "mov edi,edx"
						$lopcode = "8BFA"
					Case $aasm = "mov eax,dword[eax+4]"
						$lopcode = "8B4004"
					Case $aasm = "mov eax,dword[eax+8]"
						$lopcode = "8B4008"
					Case $aasm = "mov eax,dword[ecx]"
						$lopcode = "8B01"
					Case $aasm = "mov eax,dword[ecx+40]"
						$lopcode = "8B4140"
					Case $aasm = "mov eax,dword[ebx+c]"
						$lopcode = "8B430C"
					Case $aasm = "mov eax,dword[ebp+37c]"
						$lopcode = "8B857C030000"
					Case $aasm = "mov eax,dword[ebp+338]"
						$lopcode = "8B8538030000"
					Case $aasm = "mov eax,dword[esi+8]"
						$lopcode = "8B4608"
					Case $aasm = "mov eax,dword[edi+4]"
						$lopcode = "8B4704"
					Case $aasm = "mov ecx,dword[eax]"
						$lopcode = "8B08"
					Case $aasm = "mov ecx,dword[eax+4]"
						$lopcode = "8B4804"
					Case $aasm = "mov ecx,dword[eax+8]"
						$lopcode = "8B4808"
					Case $aasm = "mov ecx,dword[eax+20]"
						$lopcode = "8B4814"
					Case $aasm = "mov ecx,dword[ecx]"
						$lopcode = "8B09"
					Case $aasm = "mov ecx,dword[ecx+10]"
						$lopcode = "8B4910"
					Case $aasm = "mov ecx,dword[ecx+18]"
						$lopcode = "8B4918"
					Case $aasm = "mov ecx,dword[ecx+20]"
						$lopcode = "8B4920"
					Case $aasm = "mov ecx,dword[ecx+4c]"
						$lopcode = "8B494C"
					Case $aasm = "mov ecx,dword[ecx+170]"
						$lopcode = "8B8970010000"
					Case $aasm = "mov ecx,dword[ecx+194]"
						$lopcode = "8B8994010000"
					Case $aasm = "mov ecx,dword[ecx+250]"
						$lopcode = "8B8950020000"
					Case $aasm = "mov ecx,dword[edx+4]"
						$lopcode = "8B4A04"
					Case $aasm = "mov ecx,dword[edx+0x1C]"
						$lopcode = "8B4A1C"
					Case $aasm = "mov ecx,dword[ebx]"
						$lopcode = "8B0B"
					Case $aasm = "mov ecx,dword[ebx+18]"
						$lopcode = "8B5918"
					Case $aasm = "mov ecx,dword[ebx+40]"
						$lopcode = "8B5940"
					Case $aasm = "mov ecx,dword[ebx+170]"
						$lopcode = "8B8B70010000"
					Case $aasm = "mov ecx,dword[ebx+194]"
						$lopcode = "8B8B94010000"
					Case $aasm = "mov ecx,dword[ebx+250]"
						$lopcode = "8B8B50020000"
					Case $aasm = "mov ecx,dword[ebp+8]"
						$lopcode = "8B4D08"
					Case $aasm = "mov ecx,dword[esp+1F4]"
						$lopcode = "8B8C24F4010000"
					Case $aasm = "mov ecx,dword[edi]"
						$lopcode = "8B0F"
					Case $aasm = "mov ecx,dword[edi+4]"
						$lopcode = "8B4F04"
					Case $aasm = "mov ecx,dword[edi+8]"
						$lopcode = "8B4F08"
					Case $aasm = "mov edx,dword[eax+4]"
						$lopcode = "8B5004"
					Case $aasm = "mov edx,dword[eax+c]"
						$lopcode = "8B500C"
					Case $aasm = "mov edx,dword[esi+1c]"
						$lopcode = "8B561C"
					Case $aasm = "mov edx,dword[eax+8]"
						$lopcode = "8B5008"
					Case $aasm = "mov edx,dword[eax+12]"
						$lopcode = "8B500C"
					Case $aasm = "mov edx,0x57C"
						$lopcode = "BA7C050000"
					Case $aasm = "mov ebx,dword[eax]"
						$lopcode = "8B18"
					Case $aasm = "mov ebx,dword[ecx+20]"
						$lopcode = "8B5920"
					Case $aasm = "mov ebx,dword[ecx+14]"
						$lopcode = "8B5914"
					Case $aasm = "mov ebx,dword[edx]"
						$lopcode = "8B1A"
					Case $aasm = "mov ebx,dword[ecx+10]"
						$lopcode = "8B5910"
					Case $aasm = "mov ebx,dword[ecx+18]"
						$lopcode = "8B5918"
					Case $aasm = "mov ebx,dword[ecx+4c]"
						$lopcode = "8B594C"
					Case $aasm = "mov esi,dword[esi]"
						$lopcode = "8B36"
					Case $aasm = "mov edi,dword[edx+4]"
						$lopcode = "8B7A04"
					Case $aasm = "mov ecx,dword[E1D684]"
						$lopcode = "8B0D84D6E100"
					Case $aasm = "mov dword[eax],0"
						$lopcode = "C70000000000"
					Case $aasm = "mov dword[eax],ecx"
						$lopcode = "8908"
					Case $aasm = "mov dword[eax+4],ecx"
						$lopcode = "894804"
					Case $aasm = "mov dword[eax+8],ecx"
						$lopcode = "894808"
					Case $aasm = "mov dword[eax+C],ecx"
						$lopcode = "89480C"
					Case $aasm = "mov dword[eax],ebx"
						$lopcode = "8918"
					Case $aasm = "mov dword[edx],0"
						$lopcode = "C70200000000"
					Case $aasm = "mov dword[edx],-1"
						$lopcode = "C702FFFFFFFF"
					Case $aasm = "mov dword[edx-0x70],ecx"
						$lopcode = "894A90"
					Case $aasm = "mov dword[edx-0x14],ecx"
						$lopcode = "894AEC"
					Case $aasm = "mov dword[edx+0x54],ecx"
						$lopcode = "894A54"
					Case $aasm = "mov dword[edx],ebx"
						$lopcode = "891A"
					Case $aasm = "mov dword[ebx],ecx"
						$lopcode = "890B"
					Case $aasm = "mov dword[esp+108],ecx"
						$lopcode = "898C2408010000"
					Case $aasm = "mov dword[esi+10],eax"
						$lopcode = "894610"
					Case $aasm = "mov dword[edi],ecx"
						$lopcode = "890F"
					Case $aasm = "mov dword[edi],esi"
						$lopcode = "897700"
					Case $aasm = "mov dword[A30ADC],edx"
						$lopcode = "8915DC0AA300"
					Case $aasm = "mov dword[A30AD0],edx"
						$lopcode = "8915D00AA300"
					Case $aasm = "mov dword[A30AD8],edx"
						$lopcode = "8915D80AA300"
					Case $aasm = "mov dword[A30AD4],edx"
						$lopcode = "8915D40AA300"
					Case $aasm = "mov al,byte[ecx+4f]"
						$lopcode = "8A414F"
					Case $aasm = "mov al,byte[ecx+3f]"
						$lopcode = "8A413F"
					Case $aasm = "mov al,byte[ebx]"
						$lopcode = "8A03"
					Case $aasm = "mov al,byte[ecx]"
						$lopcode = "8A01"
					Case $aasm = "mov ah,byte[edi]"
						$lopcode = "8A27"
					Case $aasm = "mov dx,word[ecx]"
						$lopcode = "668B11"
					Case $aasm = "mov dx,word[edx]"
						$lopcode = "668B12"
					Case $aasm = "mov word[eax],dx"
						$lopcode = "668910"
				EndSelect
			Case $lmnemonic = "cmp"
				Select
					Case StringRegExp($aasm, "cmp ebx,dword\[[a-z,A-Z]{4,}\]")
						$masmsize += 6
						$masmstring &= "3B1D[" & StringMid($aasm, 15, StringLen($aasm) - 15) & "]"
					Case StringRegExp($aasm, "cmp dword[[][a-z,A-Z]{4,}[]],[-[:xdigit:]]")
						$lbuffer = StringInStr($aasm, ",")
						$lbuffer = asmnumber(StringMid($aasm, $lbuffer + 1), True)
						If @extended Then
							$masmsize += 7
							$masmstring &= "833D[" & StringMid($aasm, 11, StringInStr($aasm, ",") - 12) & "]" & $lbuffer
						Else
							$masmsize += 10
							$masmstring &= "813D[" & StringMid($aasm, 11, StringInStr($aasm, ",") - 12) & "]" & $lbuffer
						EndIf
					Case StringRegExp($aasm, "cmp eax,[a-z,A-Z]{4,}") AND StringInStr($aasm, ",dword") = 0
						$masmsize += 5
						$masmstring &= "3D[" & StringRight($aasm, StringLen($aasm) - 8) & "]"
					Case StringRegExp($aasm, "cmp ecx,[a-z,A-Z]{4,}") AND StringInStr($aasm, ",dword") = 0
						$masmsize += 6
						$masmstring &= "81F9[" & StringRight($aasm, StringLen($aasm) - 8) & "]"
					Case StringRegExp($aasm, "cmp ebx,[a-z,A-Z]{4,}") AND StringInStr($aasm, ",dword") = 0
						$masmsize += 6
						$masmstring &= "81FB[" & StringRight($aasm, StringLen($aasm) - 8) & "]"
					Case StringRegExp($aasm, "cmp ebx,[-[:xdigit:]]{1,8}\z")
						$lbuffer = asmnumber(StringMid($aasm, 9), True)
						If @extended Then
							$masmsize += 3
							$masmstring &= "83FB" & $lbuffer
						Else
							$masmsize += 6
							$masmstring &= "81FB" & $lbuffer
						EndIf
					Case $aasm = "cmp eax,ecx"
						$lopcode = "3BC1"
					Case $aasm = "cmp eax,ebx"
						$lopcode = "3BC3"
					Case $aasm = "cmp eax,0"
						$lopcode = "83F800"
					Case $aasm = "cmp eax,1"
						$lopcode = "83F801"
					Case $aasm = "cmp eax,2"
						$lopcode = "83F802"
					Case $aasm = "cmp eax,B"
						$lopcode = "83F80B"
					Case $aasm = "cmp eax,-1"
						$lopcode = "83F8FF"
					Case $aasm = "cmp eax,dword[esi+9C]"
						$lopcode = "3B869C000000"
					Case $aasm = "cmp eax,200"
						$lopcode = "3D00020000"
					Case $aasm = "cmp ecx,0"
						$lopcode = "83F900"
					Case $aasm = "cmp ecx,4"
						$lopcode = "83F904"
					Case $aasm = "cmp ecx,32"
						$lopcode = "83F932"
					Case $aasm = "cmp ecx,3C"
						$lopcode = "83F93C"
					Case $aasm = "cmp ecx,900000"
						$lopcode = "81F900009000"
					Case $aasm = "cmp word[edx],0"
						$lopcode = "66833A00"
					Case $aasm = "cmp al,ah"
						$lopcode = "3AC4"
					Case $aasm = "cmp edx,esi"
						$lopcode = "3BD6"
					Case $aasm = "cmp ebx,edi"
						$lopcode = "3BDF"
					Case $aasm = "cmp al,f"
						$lopcode = "3C0F"
					Case $aasm = "cmp cl,byte[esi+1B1]"
						$lopcode = "3A8EB1010000"
				EndSelect
			Case $lmnemonic = "lea"
				Select
					Case StringRegExp($aasm, "lea eax,dword[[]ecx[*]8[+][a-z,A-Z]{4,}[]]")
						$masmsize += 7
						$masmstring &= "8D04CD[" & StringMid($aasm, 21, StringLen($aasm) - 21) & "]"
					Case StringRegExp($aasm, "lea eax,dword[[]edx[*]4[+][a-z,A-Z]{4,}[]]")
						$masmsize += 7
						$masmstring &= "8D0495[" & StringMid($aasm, 21, StringLen($aasm) - 21) & "]"
					Case $aasm = "lea eax,dword[eax+18]"
						$lopcode = "8D4018"
					Case $aasm = "lea ecx,dword[eax+4]"
						$lopcode = "8D4804"
					Case $aasm = "lea ecx,dword[eax+180]"
						$lopcode = "8D8880010000"
					Case $aasm = "lea edx,dword[eax+4]"
						$lopcode = "8D5004"
					Case $aasm = "lea edx,dword[eax+8]"
						$lopcode = "8D5008"
					Case $aasm = "lea esi,dword[esi+ebx*4]"
						$lopcode = "8D349E"
					Case $aasm = "lea edi,dword[edx+ebx]"
						$lopcode = "8D3C1A"
					Case $aasm = "lea edi,dword[edx+8]"
						$lopcode = "8D7A08"
				EndSelect
			Case $lmnemonic = "add"
				Select
					Case StringRegExp($aasm, "add eax,[a-z,A-Z]{4,}") AND StringInStr($aasm, ",dword") = 0
						$masmsize += 5
						$masmstring &= "05[" & StringRight($aasm, StringLen($aasm) - 8) & "]"
					Case StringRegExp($aasm, "add eax,[-[:xdigit:]]{1,8}\z")
						$lbuffer = asmnumber(StringMid($aasm, 9), True)
						If @extended Then
							$masmsize += 3
							$masmstring &= "83C0" & $lbuffer
						Else
							$masmsize += 5
							$masmstring &= "05" & $lbuffer
						EndIf
					Case StringRegExp($aasm, "add ecx,[-[:xdigit:]]{1,8}\z")
						$lbuffer = asmnumber(StringMid($aasm, 9), True)
						If @extended Then
							$masmsize += 3
							$masmstring &= "83C1" & $lbuffer
						Else
							$masmsize += 6
							$masmstring &= "81C1" & $lbuffer
						EndIf
					Case StringRegExp($aasm, "add edx,[-[:xdigit:]]{1,8}\z")
						$lbuffer = asmnumber(StringMid($aasm, 9), True)
						If @extended Then
							$masmsize += 3
							$masmstring &= "83C2" & $lbuffer
						Else
							$masmsize += 6
							$masmstring &= "81C2" & $lbuffer
						EndIf
					Case StringRegExp($aasm, "add ebx,[-[:xdigit:]]{1,8}\z")
						$lbuffer = asmnumber(StringMid($aasm, 9), True)
						If @extended Then
							$masmsize += 3
							$masmstring &= "83C3" & $lbuffer
						Else
							$masmsize += 6
							$masmstring &= "81C3" & $lbuffer
						EndIf
					Case StringRegExp($aasm, "add edi,[-[:xdigit:]]{1,8}\z")
						$lbuffer = asmnumber(StringMid($aasm, 9), True)
						If @extended Then
							$masmsize += 3
							$masmstring &= "83C7" & $lbuffer
						Else
							$masmsize += 6
							$masmstring &= "81C7" & $lbuffer
						EndIf
				EndSelect
			Case $lmnemonic = "fstp"
				If $aasm == "fstp dword[A3F998]" Then
					$lopcode = "D91D98F9A300"
				ElseIf StringRegExp($aasm, "fstp dword[[][a-z,A-Z]{4,}[]]") Then
					$masmsize += 6
					$masmstring &= "D91D[" & StringMid($aasm, 12, StringLen($aasm) - 12) & "]"
				EndIf
			Case $lmnemonic = "push"
				Select
					Case StringRegExp($aasm, "push dword[[][a-z,A-Z]{4,}[]]")
						$masmsize += 6
						$masmstring &= "FF35[" & StringMid($aasm, 12, StringLen($aasm) - 12) & "]"
					Case StringRegExp($aasm, "push [a-z,A-Z]{4,}\z")
						$masmsize += 5
						$masmstring &= "68[" & StringMid($aasm, 6, StringLen($aasm) - 5) & "]"
					Case StringRegExp($aasm, "push [-[:xdigit:]]{1,8}\z")
						$lbuffer = asmnumber(StringMid($aasm, 6), True)
						If @extended Then
							$masmsize += 2
							$masmstring &= "6A" & $lbuffer
						Else
							$masmsize += 5
							$masmstring &= "68" & $lbuffer
						EndIf
					Case $aasm = "push eax"
						$lopcode = "50"
					Case $aasm = "push ecx"
						$lopcode = "51"
					Case $aasm = "push edx"
						$lopcode = "52"
					Case $aasm = "push ebx"
						$lopcode = "53"
					Case $aasm = "push ebp"
						$lopcode = "55"
					Case $aasm = "push esi"
						$lopcode = "56"
					Case $aasm = "push edi"
						$lopcode = "57"
					Case $aasm = "push dword[eax+4]"
						$lopcode = "FF7004"
					Case $aasm = "push dword[eax+8]"
						$lopcode = "FF7008"
					Case $aasm = "push dword[eax+c]"
						$lopcode = "FF700C"
				EndSelect
			Case $lmnemonic = "pop"
				Select
					Case $aasm = "pop eax"
						$lopcode = "58"
					Case $aasm = "pop ebx"
						$lopcode = "5B"
					Case $aasm = "pop edx"
						$lopcode = "5A"
					Case $aasm = "pop ecx"
						$lopcode = "59"
					Case $aasm = "pop esi"
						$lopcode = "5E"
					Case $aasm = "pop edi"
						$lopcode = "5F"
					Case $aasm = "pop ebp"
						$lopcode = "5D"
				EndSelect
			Case $lmnemonic = "call"
				Select
					Case StringRegExp($aasm, "call dword[[][a-z,A-Z]{4,}[]]")
						$masmsize += 6
						$masmstring &= "FF15[" & StringMid($aasm, 12, StringLen($aasm) - 12) & "]"
					Case StringLeft($aasm, 5) = "call " AND StringLen($aasm) > 8
						$masmsize += 5
						$masmstring &= "E8{" & StringMid($aasm, 6, StringLen($aasm) - 5) & "}"
				EndSelect
			Case $lmnemonic = "test"
				Switch $aasm
					Case $aasm = "test eax,eax"
						$lopcode = "85C0"
					Case $aasm = "test ecx,ecx"
						$lopcode = "85C9"
					Case $aasm = "test ebx,ebx"
						$lopcode = "85DB"
					Case $aasm = "test esi,esi"
						$lopcode = "85F6"
					Case $aasm = "test dx,dx"
						$lopcode = "6685D2"
					Case $aasm = "test al,al"
						$lopcode = "84C0"
					Case $aasm = "test al,1"
						$lopcode = "A801"
				EndSwitch
			Case $lmnemonic = "inc"
				Switch $aasm
					Case $aasm = "inc eax"
						$lopcode = "40"
					Case $aasm = "inc ecx"
						$lopcode = "41"
					Case $aasm = "inc edx"
						$lopcode = "42"
					Case $aasm = "inc ebx"
						$lopcode = "43"
				EndSwitch
			Case $lmnemonic = "dec"
				Switch $aasm
					Case $aasm = "dec edx"
						$lopcode = "4A"
				EndSwitch
			Case $lmnemonic = "xor"
				Switch $aasm
					Case $aasm = "xor eax,eax"
						$lopcode = "33C0"
					Case $aasm = "xor ecx,ecx"
						$lopcode = "33C9"
					Case $aasm = "xor edx,edx"
						$lopcode = "33D2"
					Case $aasm = "xor ebx,ebx"
						$lopcode = "33DB"
				EndSwitch
			Case $lmnemonic = "sub"
				Switch $aasm
					Case $aasm = "sub esp,8"
						$lopcode = "83EC08"
					Case $aasm = "sub esp,14"
						$lopcode = "83EC14"
				EndSwitch
			Case $lmnemonic = "shl"
				Switch $aasm
					Case $aasm = "shl eax,4"
						$lopcode = "C1E004"
					Case $aasm = "shl eax,6"
						$lopcode = "C1E006"
					Case $aasm = "shl eax,7"
						$lopcode = "C1E007"
					Case $aasm = "shl eax,8"
						$lopcode = "C1E008"
					Case $aasm = "shl eax,8"
						$lopcode = "C1E008"
					Case $aasm = "shl eax,9"
						$lopcode = "C1E009"
				EndSwitch
			Case $lmnemonic = "retn"
				If $aasm = "retn 10" Then $lopcode = "C21000"
			Case $aasm = "repe movsb"
				$lopcode = "F3A4"
			Case Else
				MsgBox(0, "ASM", "Could not assemble: " & $aasm)
				Exit
		EndSelect
		If $lopcode <> "" Then
			$masmsize += 0.5 * StringLen($lopcode)
			$masmstring &= $lopcode
		EndIf
	EndFunc

	Func completeasmcode()
		Local $linexpression = False
		Local $lexpression
		Local $ltempasm = $masmstring
		Local $lcurrentoffset = Dec(Hex($mmemory)) + $masmcodeoffset
		Local $ltoken
		For $i In $mlabeldict.keys
			If StringLeft($i, 6) = "Label_" Then
				$mlabeldict.item($i) = "0x" & Hex(Int($mmemory + $mlabeldict.item($i)), 8)
				$mlabeldict.key($i) = StringTrimLeft($i, 6)
			EndIf
		Next
		$masmstring = ""
		For $i = 1 To StringLen($ltempasm)
			$ltoken = StringMid($ltempasm, $i, 1)
			Switch $ltoken
				Case "(", "[", "{"
					$linexpression = True
				Case ")"
					$masmstring &= Hex(getlabelinfo($lexpression) - Int($lcurrentoffset) - 1, 2)
					$lcurrentoffset += 1
					$linexpression = False
					$lexpression = ""
				Case "]"
					$masmstring &= swapendian(Hex(getlabelinfo($lexpression), 8))
					$lcurrentoffset += 4
					$linexpression = False
					$lexpression = ""
				Case "}"
					$masmstring &= swapendian(Hex(getlabelinfo($lexpression) - Int($lcurrentoffset) - 4, 8))
					$lcurrentoffset += 4
					$linexpression = False
					$lexpression = ""
				Case Else
					If $linexpression Then
						$lexpression &= $ltoken
					Else
						$masmstring &= $ltoken
						$lcurrentoffset += 0.5
					EndIf
			EndSwitch
		Next
	EndFunc

	Func getlabelinfo($alabel)
		Local $lvalue = getvalue($alabel)
		If $lvalue = -1 Then Exit MsgBox(0, "Label", "Label: " & $alabel & " not provided")
		Return $lvalue
	EndFunc

	Func asmnumber($anumber, $asmall = False)
		If $anumber >= 0 Then
			$anumber = Dec($anumber)
		EndIf
		If $asmall AND $anumber <= 127 AND $anumber >= -128 Then
			Return SetExtended(1, Hex($anumber, 2))
		Else
			Return SetExtended(0, swapendian(Hex($anumber, 8)))
		EndIf
	EndFunc

#EndRegion Assembler
#Region Conversion

	Func floattoint($nfloat)
		Local $tfloat = DllStructCreate("float")
		Local $tint = DllStructCreate("int", DllStructGetPtr($tfloat))
		DllStructSetData($tfloat, 1, $nfloat)
		Return DllStructGetData($tint, 1)
	EndFunc

#EndRegion
#Region Misc

	Func sendpacket($asize, $aheader, $aparam1 = 0, $aparam2 = 0, $aparam3 = 0, $aparam4 = 0, $aparam5 = 0, $aparam6 = 0, $aparam7 = 0, $aparam8 = 0, $aparam9 = 0, $aparam10 = 0)
		If getagentexists(-2) Then
			DllStructSetData($mpacket, 2, $asize)
			DllStructSetData($mpacket, 3, $aheader)
			DllStructSetData($mpacket, 4, $aparam1)
			DllStructSetData($mpacket, 5, $aparam2)
			DllStructSetData($mpacket, 6, $aparam3)
			DllStructSetData($mpacket, 7, $aparam4)
			DllStructSetData($mpacket, 8, $aparam5)
			DllStructSetData($mpacket, 9, $aparam6)
			DllStructSetData($mpacket, 10, $aparam7)
			DllStructSetData($mpacket, 11, $aparam8)
			DllStructSetData($mpacket, 12, $aparam9)
			DllStructSetData($mpacket, 13, $aparam10)
			enqueue($mpacketptr, 52)
			Return True
		Else
			Return False
		EndIf
	EndFunc

	Func performaction($aaction, $aflag)
		If getagentexists(-2) Then
			DllStructSetData($maction, 2, $aaction)
			DllStructSetData($maction, 3, $aflag)
			enqueue($mactionptr, 12)
			Return True
		Else
			Return False
		EndIf
	EndFunc

	Func getconnection()
		Return TCPConnect($mgwserverinfo, $mgwserverport)
	EndFunc

	Func setconnection($acon)
		TCPCloseSocket($acon)
	EndFunc

	Func getping()
		Return memoryread($mping)
	EndFunc

	Func getlanguage()
		Return memoryread($mlanguage)
	EndFunc

	Func getcharname()
		Return memoryread($mcharname, "wchar[30]")
	EndFunc

	Func getloggedin()
		Return memoryread($mloggedin)
	EndFunc

	Func getdisplaylanguage()
		Local $loffset[6] = [0, 24, 24, 404, 76, 64]
		Local $lresult = memoryreadptr($mbasepointer, $loffset)
		Return $lresult[1]
	EndFunc

	Func getinstanceuptime()
		Local $loffset[4] = [0, 24, 8, 428]
		Local $ltimer = memoryreadptr($mbasepointer, $loffset)
		Return $ltimer[1]
	EndFunc

	Func getbuildnumber()
		Return $mbuildnumber
	EndFunc

	Func rndsleep($aamount, $arandom = 0.05)
		Local $lrandom = $aamount * $arandom
		Sleep(Random($aamount - $lrandom, $aamount + $lrandom))
	EndFunc

	Func tolsleep($aamount = 150, $atolerance = 50)
		Sleep(Random($aamount - $atolerance, $aamount + $atolerance))
	EndFunc

	Func pingsleep($time = 1000)
		Sleep(getping() + $time)
	EndFunc

	Func getwindowhandle()
		Return $mgwhwnd
	EndFunc

	Func sendsafepacket($apacket, $acon = Default)
		If $acon = Default Then
			Local $lgwsocket = TCPConnect($mgwserverinfo, $mgwserverport)
		Else
			Local $lgwsocket = $acon
		EndIf
		TCPSend($lgwsocket, $apacket)
		If $acon = Default Then
			TCPCloseSocket($lgwsocket)
		EndIf
	EndFunc

	Func computedistance($ax1, $ay1, $ax2, $ay2)
		Return Sqrt(($ax1 - $ax2) ^ 2 + ($ay1 - $ay2) ^ 2)
	EndFunc

	Func prepare($aname, $aargs, $mglobal = Default)
		If $mglobal == Default Then
			$aname &= "/" & $muuid
		EndIf
		For $i = 0 To UBound($aargs) - 1
			$aname &= "/" & $aargs[$i]
		Next
		Return $aname
	EndFunc

	Func openmerchantwindow()
		Local $id = storagesessionid()
		DllStructSetData($mopenmerchant, 2, $id)
		DllStructSetData($mopenmerchant, 3, 128)
		DllStructSetData($mopenmerchant, 4, 0)
		DllStructSetData($mopenmerchant, 5, 0)
		enqueue($mopenmerchantptr, 20)
	EndFunc

	Func openstoragewindow()
		Local $id = storagesessionid()
		DllStructSetData($mopenstorage, 2, $id)
		DllStructSetData($mopenstorage, 3, 0)
		DllStructSetData($mopenstorage, 4, 1)
		enqueue($mopenstorageptr, 16)
	EndFunc

	Func storagesessionid()
		Local $loffset[3] = [280, 16, 0]
		$lreturn = memoryreadptr($mstoragesessionbase, $loffset)
		Return memoryread($lreturn[1] + 20)
	EndFunc

	Func disconnected()
		ControlSend(getwindowhandle(), "", "", "{Enter}")
		Local $lcheck = False
		Local $ldeadlock = TimerInit()
		Do
			Sleep(20)
			$lcheck = getmaploading() <> 2 AND getagentexists(-2)
		Until $lcheck OR TimerDiff($ldeadlock) > 60000
		If $lcheck = False Then
			ControlSend(getwindowhandle(), "", "", "{Enter}")
			$ldeadlock = TimerInit()
			Do
				Sleep(20)
				$lcheck = getmaploading() <> 2 AND getagentexists(-2)
			Until $lcheck OR TimerDiff($ldeadlock) > 60000
			If $lcheck = False Then
				Exit 1
			EndIf
		EndIf
		Sleep(5000)
	EndFunc

#EndRegion
#RequireAdmin

Func cacheskillbar_()
	If NOT $mskillbarcache[0] Then
		$mskillbar = getskillbar()
		$mskillbarptr = getskillbarptr()
		For $i = 1 To 8
			$mskillbarcache[$i] = DllStructGetData($mskillbar, "Id" & $i)
			$mskillbarcachestruct[$i] = getskillbyid($mskillbarcache[$i])
			$mskillbarcacheptr[$i] = getskillptr($mskillbarcache[$i])
			If DllStructGetData($mskillbarcachestruct[$i], "Adrenaline") > 0 Then
				$skilladrenalinereq[$i] = DllStructGetData($mskillbarcachestruct[$i], "Adrenaline")
				$skilladrenalinereq[0] = True
				$mskillbarcacheenergyreq[$i] = 0
				update("Skill " & $i & " requires " & DllStructGetData($mskillbarcachestruct[$i], "Adrenaline") & " Adrenaline.", "Skills")
			Else
				$skilladrenalinereq[$i] = 0
				Switch DllStructGetData($mskillbarcachestruct[$i], "EnergyCost")
					Case 0
						$mskillbarcacheenergyreq[$i] = 0
					Case 1
						$mskillbarcacheenergyreq[$i] = 1
					Case 5
						$mskillbarcacheenergyreq[$i] = 5
					Case 10
						$mskillbarcacheenergyreq[$i] = 10
					Case 11
						$mskillbarcacheenergyreq[$i] = 15
					Case 12
						$mskillbarcacheenergyreq[$i] = 25
					Case Else
				EndSwitch
				update("Skill " & $i & " requires " & $mskillbarcacheenergyreq[$i] & " energy.")
			EndIf
			$mskillpriorityrating[$i][1] = 0
			$skilldamageamount[$i] = skilldamageamount($mskillbarcachestruct[$i])
			$mskillpriorityrating[$i][0] = $i
			If iseliteskill($mskillbarcachestruct[$i]) Then $mskillpriorityrating[$i][1] = 30
			If $mskillbarcache[$i] = $you_move_like_a_dwarf Then
				$isymlad[$i] = True
				$isymlad[0] = True
				$ymladslot = $i
				$mskillpriorityrating[$i][1] = 120 - $i
				$mskillpriorityrating[$i][2] = 1
				update("Skill " & $i & " is YMLAD! Priority: " & $mskillpriorityrating[$i][1] & ".")
				ContinueLoop
			EndIf
			If isinterruptskill($mskillbarcachestruct[$i]) Then
				$mskillpriorityrating[$i][1] += 110 - $i
				$mskillpriorityrating[$i][2] = 2
				$isinterrupt[$i] = True
				$isinterrupt[0] = True
				update("Skill " & $i & " is an Interrupt Skill, Priority: " & $mskillpriorityrating[$i][1] & ".")
				ContinueLoop
			EndIf
			If ishealskill($mskillbarcachestruct[$i]) AND NOT isresskill($mskillbarcachestruct[$i]) AND NOT ishexremovalskill($mskillbarcachestruct[$i]) AND isconditionremovalskill($mskillbarcachestruct[$i]) == False AND NOT targetotherallyskill($mskillbarcachestruct[$i]) Then
				$ishealingspell[$i] = True
				$ishealingspell[0] = True
				$mskillpriorityrating[$i][1] += 80 - $i + $skilldamageamount[$i]
				$mskillpriorityrating[$i][2] = 3
				update("Skill " & $i & " heals ally for " & $skilldamageamount[$i] & ", Priority: " & $mskillpriorityrating[$i][1] & ".")
				ContinueLoop
			EndIf
			If targetotherallyskill($mskillbarcachestruct[$i]) == True AND isresskill($mskillbarcachestruct[$i]) == False AND ishexremovalskill($mskillbarcachestruct[$i]) == False AND isconditionremovalskill($mskillbarcachestruct[$i]) == False Then
				$mskillpriorityrating[$i][1] += 75 - $i
				$mskillpriorityrating[$i][2] = 4
				update("Skill " & $i & " heals other ally for " & $skilldamageamount[$i] & ", Priority: " & $mskillpriorityrating[$i][1] & ".")
				ContinueLoop
			EndIf
			If skillaoerange($mskillbarcachestruct[$i]) > 0 Then
				If targetenemyskill($mskillbarcachestruct[$i]) == True OR targetgroundskill($mskillbarcachestruct[$i]) == True Then
					$mskillpriorityrating[$i][1] += 70 - $i
					$mskillpriorityrating[$i][2] = 5
					update("Skill " & $i & " does AOE damage of " & $skilldamageamount[$i] & ", Priority: " & $mskillpriorityrating[$i][1] & ".")
					ContinueLoop
				EndIf
			EndIf
			If $mskillbarcache[$i] == $soul_twisting Then
				$issoultwistingspell[$i] = True
				$issoultwistingspell[0] = True
				$mskillpriorityrating[$i][1] = 65 - $i
				$mskillpriorityrating[$i][2] = 6
				update("Skill " & $i & " is Soul Twisting, Priority: " & $mskillpriorityrating[$i][1] & ".")
				ContinueLoop
			EndIf
			If isspiritskill($mskillbarcachestruct[$i]) == True Then
				$mskillpriorityrating[$i][1] += 60 - $i
				$mskillpriorityrating[$i][2] = 7
				update("Skill " & $i & " is a Spirit Skill, Priority: " & $mskillpriorityrating[$i][1] & ".")
				ContinueLoop
			EndIf
			If ishexremovalskill($mskillbarcachestruct[$i]) == True Then
				$mskillpriorityrating[$i][1] = 55 - $i
				$mskillpriorityrating[$i][2] = 8
				update("Skill " & $i & " is a Hex Remover, Priority: " & $mskillpriorityrating[$i][1] & ".")
				ContinueLoop
			EndIf
			If isconditionremovalskill($mskillbarcachestruct[$i]) == True Then
				$mskillpriorityrating[$i][1] = 50 - $i
				$mskillpriorityrating[$i][2] = 9
				update("Skill " & $i & " is a Condition Remover, Priority: " & $mskillpriorityrating[$i][1] & ".")
				ContinueLoop
			EndIf
			If isweaponspell($mskillbarcache[$i]) == True Then
				$isweaponspell[$i] = True
				$isweaponspell[0] = True
				$mskillpriorityrating[$i][1] += 40 - $i
				$mskillpriorityrating[$i][2] = 10
				update("Skill " & $i & " is a Weapon Skill, Priority: " & $mskillpriorityrating[$i][1] & ".")
				ContinueLoop
			EndIf
			If isenchantmentstrip($mskillbarcachestruct[$i]) Then
				$mskillpriorityrating[$i][1] += 35 - $i
				$mskillpriorityrating[$i][2] = 11
				update("Skill " & $i & " is a Enchantment Strip, Priority: " & $mskillpriorityrating[$i][1] & ".")
				ContinueLoop
			EndIf
			If skillaoerange($mskillbarcachestruct[$i]) <= 0 AND targetenemyskill($mskillbarcachestruct[$i]) == True AND isinterruptskill($mskillbarcachestruct[$i]) == False Then
				$mskillpriorityrating[$i][1] += 30 - $i
				If ispveskill($mskillbarcachestruct[$i]) Then $mskillpriorityrating[$i][1] += 100
				$mskillpriorityrating[$i][2] = 12
				update("Skill " & $i & " Vs. enemies for " & $skilldamageamount[$i] & " damage, Priority: " & $mskillpriorityrating[$i][1] & ".")
				ContinueLoop
			EndIf
			If isresskill($mskillbarcachestruct[$i]) == True Then
				$mskillpriorityrating[$i][1] = 20 - $i
				$mskillpriorityrating[$i][2] = 13
				update("Skill " & $i & " is a Rez, Priority: " & $mskillpriorityrating[$i][1] & ".")
				ContinueLoop
			EndIf
			If targetselfskill($mskillbarcachestruct[$i]) == True AND ishealskill($mskillbarcachestruct[$i]) == False AND isspiritskill($mskillbarcachestruct[$i]) == False AND issummonskill($mskillbarcache[$i]) == False AND $mskillbarcache[$i] <> $soul_twisting Then
				$isselfcastingspell[$i] = True
				$isselfcastingspell[0] = True
				$mskillpriorityrating[$i][1] += 10 - $i
				$mskillpriorityrating[$i][2] = 14
				update("Skill " & $i & " is a Self Targeting Skill, Priority: " & $mskillpriorityrating[$i][1] & ".")
				ContinueLoop
			EndIf
			If issummonskill($mskillbarcache[$i]) == True Then
				$issummonspell[$i] = True
				$issummonspell[0] = True
				$mskillpriorityrating[$i][1] = 0 - $i
				$mskillpriorityrating[$i][2] = 15
				update("Skill " & $i & " is a Summon, Priority: " & $mskillpriorityrating[$i][1] & ".")
				ContinueLoop
			EndIf
		Next
		$lmyprofession = getheroprofession(0)
		$lattrprimary = getprofprimaryattribute($lmyprofession)
		_arraysort($mskillpriorityrating, 0, 0, 0, 1)
	EndIf
	$mskillbarcache[0] = True
	$mskillbarcacheptr[0] = True
	$mskillbarcachestruct[0] = True
EndFunc

Func getcurrenttarget()
	Return getagentbyid(getcurrenttargetid())
EndFunc

Func pickupitem_($aitem)
	Local $lagentid
	If IsDllStruct($aitem) = 0 Then
		$lagentid = $aitem
	ElseIf DllStructGetSize($aitem) < 400 Then
		$lagentid = DllStructGetData($aitem, "AgentID")
	Else
		$lagentid = DllStructGetData($aitem, "ID")
	EndIf
	Return sendpacket(12, 57, $lagentid, 0)
EndFunc

Func getitembyslot($abag, $aslot)
	Local $lbag
	If IsDllStruct($abag) = 0 Then
		$lbag = getbag($abag)
	Else
		$lbag = $abag
	EndIf
	Local $litemptr = DllStructGetData($lbag, "ItemArray")
	Local $lbuffer = DllStructCreate("ptr")
	Local $litemstruct = DllStructCreate("long id;long agentId;byte unknown1[4];ptr bag;ptr modstruct;long modstructsize;ptr customized;byte unknown2[4];byte type;byte unknown3;short extraId;short value;byte unknown4[2];short interaction;long modelId;ptr modString;byte unknown5[4];ptr NameString;byte unknown6[15];byte quantity;byte equipped;byte unknown7[1];byte slot")
	DllCall($mkernelhandle, "int", "ReadProcessMemory", "int", $mgwprochandle, "int", DllStructGetData($lbag, "ItemArray") + 4 * ($aslot - 1), "ptr", DllStructGetPtr($lbuffer), "int", DllStructGetSize($lbuffer), "int", "")
	DllCall($mkernelhandle, "int", "ReadProcessMemory", "int", $mgwprochandle, "int", DllStructGetData($lbuffer, 1), "ptr", DllStructGetPtr($litemstruct), "int", DllStructGetSize($litemstruct), "int", "")
	Return $litemstruct
EndFunc

Func getitembyitemid($aitemid)
	Local $litemstruct = DllStructCreate("long id;long agentId;byte unknown1[4];ptr bag;ptr modstruct;long modstructsize;ptr customized;byte unknown2[4];byte type;byte unknown3;short extraId;short value;byte unknown4[2];short interaction;long modelId;ptr modString;byte unknown5[4];ptr NameString;byte unknown6[15];byte quantity;byte equipped;byte unknown7[1];byte slot")
	Local $loffset[5] = [0, 24, 64, 184, 4 * $aitemid]
	Local $litemptr = memoryreadptr($mbasepointer, $loffset)
	DllCall($mkernelhandle, "int", "ReadProcessMemory", "int", $mgwprochandle, "int", $litemptr[1], "ptr", DllStructGetPtr($litemstruct), "int", DllStructGetSize($litemstruct), "int", "")
	Return $litemstruct
EndFunc

Func getitembyagentid($aagentid)
	Local $litemstruct = DllStructCreate("long id;long agentId;byte unknown1[4];ptr bag;ptr modstruct;long modstructsize;ptr customized;byte unknown2[4];byte type;byte unknown3;short extraId;short value;byte unknown4[2];short interaction;long modelId;ptr modString;byte unknown5[4];ptr NameString;byte unknown6[15];byte quantity;byte equipped;byte unknown7[1];byte slot")
	Local $loffset[4] = [0, 24, 64, 192]
	Local $litemarraysize = memoryreadptr($mbasepointer, $loffset)
	Local $loffset[5] = [0, 24, 64, 184, 0]
	Local $litemptr, $litemid
	Local $lagentid = convertid($aagentid)
	For $litemid = 1 To $litemarraysize[1]
		$loffset[4] = 4 * $litemid
		$litemptr = memoryreadptr($mbasepointer, $loffset)
		If $litemptr[1] = 0 Then ContinueLoop
		DllCall($mkernelhandle, "int", "ReadProcessMemory", "int", $mgwprochandle, "int", $litemptr[1], "ptr", DllStructGetPtr($litemstruct), "int", DllStructGetSize($litemstruct), "int", "")
		If DllStructGetData($litemstruct, "AgentID") = $lagentid Then Return $litemstruct
	Next
EndFunc

Func getitembymodelid($amodelid, $bagsonly = False)
	If $bagsonly Then
		For $i = 1 To 17
			For $slot = 1 To DllStructGetData(getbag($i), "Slots")
				$litemstruct = getitembyslot($i, $slot)
				If DllStructGetData($litemstruct, "ID") = 0 Then ContinueLoop
				If DllStructGetData($litemstruct, "ModelID") == $amodelid Then Return $litemstruct
			Next
		Next
	Else
		Local $litemstruct = DllStructCreate("long id;long agentId;byte unknown1[4];ptr bag;ptr modstruct;long modstructsize;ptr customized;byte unknown2[4];byte type;byte unknown3;short extraId;short value;byte unknown4[2];short interaction;long modelId;ptr modString;byte unknown5[4];ptr NameString;byte unknown6[15];byte quantity;byte equipped;byte unknown7[1];byte slot")
		Local $loffset[4] = [0, 24, 64, 192]
		Local $litemarraysize = memoryreadptr($mbasepointer, $loffset)
		Local $loffset[5] = [0, 24, 64, 184, 0]
		Local $litemptr, $litemid
		For $litemid = 1 To $litemarraysize[1]
			$loffset[4] = 4 * $litemid
			$litemptr = memoryreadptr($mbasepointer, $loffset)
			If $litemptr[1] = 0 Then ContinueLoop
			DllCall($mkernelhandle, "int", "ReadProcessMemory", "int", $mgwprochandle, "int", $litemptr[1], "ptr", DllStructGetPtr($litemstruct), "int", DllStructGetSize($litemstruct), "int", "")
			If DllStructGetData($litemstruct, "ModelID") = $amodelid Then Return $litemstruct
		Next
	EndIf
	Return False
EndFunc

Func getnumberoffoesinrangeofagent__($aagent = -2, $fmaxdistance = 4000, $modelid = 0)
	Local $ldistance, $lcount = 0, $lagenttocompare
	If IsDllStruct($aagent) = 0 Then $aagent = getagentbyid($aagent)
	For $i = 1 To getmaxagents()
		$lagenttocompare = getagentbyid($i)
		If DllStructGetData($lagenttocompare, "Type") <> 219 Then ContinueLoop
		If DllStructGetData($lagenttocompare, "Allegiance") <> 3 Then ContinueLoop
		If DllStructGetData($lagenttocompare, "HP") <= 0 Then ContinueLoop
		If BitAND(DllStructGetData($lagenttocompare, "Effects"), 16) > 0 Then ContinueLoop
		If $modelid <> 0 AND DllStructGetData($lagenttocompare, "ModelID") == $modelid Then ContinueLoop
		$ldistance = getdistance_($lagenttocompare, $aagent)
		If $ldistance < $fmaxdistance Then
			$lcount += 1
		EndIf
	Next
	Return $lcount
EndFunc

Func getdistance_($aagent1 = -1, $aagent2 = -2)
	If IsDllStruct($aagent1) = 0 Then $aagent1 = getagentbyid($aagent1)
	If IsDllStruct($aagent2) = 0 Then $aagent2 = getagentbyid($aagent2)
	Return Sqrt((DllStructGetData($aagent1, "X") - DllStructGetData($aagent2, "X")) ^ 2 + (DllStructGetData($aagent1, "Y") - DllStructGetData($aagent2, "Y")) ^ 2)
EndFunc

Func getnumberofalliesinrangeofagent__($aagent = -2, $fmaxdistance = 4000)
	Local $ldistance, $lcount = 0, $lagenttocompare
	If IsDllStruct($aagent) = 0 Then $aagent = getagentbyid($aagent)
	For $i = 1 To getmaxagents()
		$lagenttocompare = getagentbyid($i)
		If DllStructGetData($lagenttocompare, "Type") <> 219 Then ContinueLoop
		If DllStructGetData($lagenttocompare, "Allegiance") <> 1 Then ContinueLoop
		If DllStructGetData($lagenttocompare, "HP") <= 0 Then ContinueLoop
		If BitAND(DllStructGetData($lagenttocompare, "Effects"), 16) > 0 Then ContinueLoop
		$ldistance = getdistance_($lagenttocompare, $aagent)
		If $ldistance < $fmaxdistance Then
			$lcount += 1
		EndIf
	Next
	Return $lcount
EndFunc

Func getvip__($fmaxdistance = 1350)
	Local $lcount = 0, $lagenttocompare, $vip = 0, $enemies = 0
	For $i = 1 To getmaxagents()
		$lagenttocompare = getagentbyid($i)
		If DllStructGetData($lagenttocompare, "Type") <> 219 Then ContinueLoop
		If DllStructGetData($lagenttocompare, "Allegiance") <> 1 Then ContinueLoop
		If DllStructGetData($lagenttocompare, "HP") <= 0 Then ContinueLoop
		If BitAND(DllStructGetData($lagenttocompare, "Effects"), 16) > 0 Then ContinueLoop
		$enemies = getnumberoffoesinrangeofagent_($lagenttocompare, $fmaxdistance)
		If $enemies > $lcount Then
			$vip = $lagenttocompare
			$lcount = $enemies
		EndIf
	Next
	Return $vip
EndFunc

Func getagentarray($atype = 0)
	Local $lstruct
	Local $lcount
	Local $lbuffer = ""
	DllStructSetData($mmakeagentarray, 2, $atype)
	memorywrite($magentcopycount, -1, "long")
	enqueue($mmakeagentarrayptr, 8)
	Local $ldeadlock = TimerInit()
	Do
		Sleep(1)
		$lcount = memoryread($magentcopycount, "long")
	Until $lcount >= 0 OR TimerDiff($ldeadlock) > 5000
	If $lcount < 0 Then $lcount = 0
	For $i = 1 To $lcount
		$lbuffer &= "Byte[448];"
	Next
	$lbuffer = DllStructCreate($lbuffer)
	DllCall($mkernelhandle, "int", "ReadProcessMemory", "int", $mgwprochandle, "int", $magentcopybase, "ptr", DllStructGetPtr($lbuffer), "int", DllStructGetSize($lbuffer), "int", "")
	Local $lreturnarray[$lcount + 1] = [$lcount]
	For $i = 1 To $lcount
		$lreturnarray[$i] = DllStructCreate("ptr vtable;byte unknown1[24];byte unknown2[4];ptr NextAgent;byte unknown3[8];long Id;float Z;byte unknown4[8];float BoxHoverWidth;float BoxHoverHeight;byte unknown5[8];float Rotation;byte unknown6[8];long NameProperties;byte unknown7[24];float X;float Y;byte unknown8[8];float NameTagX;float NameTagY;float NameTagZ;byte unknown9[12];long Type;float MoveX;float MoveY;byte unknown10[28];long Owner;byte unknown30[8];long ExtraType;byte unknown11[24];float AttackSpeed;float AttackSpeedModifier;word PlayerNumber;byte unknown12[6];ptr Equip;byte unknown13[10];byte Primary;byte Secondary;byte Level;byte Team;byte unknown14[6];float EnergyPips;byte unknown[4];float EnergyPercent;long MaxEnergy;byte unknown15[4];float HPPips;byte unknown16[4];float HP;long MaxHP;long Effects;byte unknown17[4];byte Hex;byte unknown18[18];long ModelState;long TypeMap;byte unknown19[16];long InSpiritRange;byte unknown20[16];long LoginNumber;float ModelMode;byte unknown21[4];long ModelAnimation;byte unknown22[32];byte LastStrike;byte Allegiance;word WeaponType;word Skill;byte unknown23[4];word WeaponItemId;word OffhandItemId")
		$lstruct = DllStructCreate("byte[448]", DllStructGetPtr($lreturnarray[$i]))
		DllStructSetData($lstruct, 1, DllStructGetData($lbuffer, $i))
	Next
	Return $lreturnarray
EndFunc

Func getagentbyid($aagentid = -2)
	Local $lagentptr = getagentptr($aagentid)
	If $lagentptr = 0 Then Return 0
	Local $lagentstruct = DllStructCreate("ptr vtable;byte unknown1[24];byte unknown2[4];ptr NextAgent;byte unknown3[8];long Id;float Z;byte unknown4[8];float BoxHoverWidth;float BoxHoverHeight;byte unknown5[8];float Rotation;byte unknown6[8];long NameProperties;byte unknown7[24];float X;float Y;byte unknown8[8];float NameTagX;float NameTagY;float NameTagZ;byte unknown9[12];long Type;float MoveX;float MoveY;byte unknown10[28];long Owner;byte unknown30[8];long ExtraType;byte unknown11[24];float AttackSpeed;float AttackSpeedModifier;word PlayerNumber;byte unknown12[6];ptr Equip;byte unknown13[10];byte Primary;byte Secondary;byte Level;byte Team;byte unknown14[6];float EnergyPips;byte unknown[4];float EnergyPercent;long MaxEnergy;byte unknown15[4];float HPPips;byte unknown16[4];float HP;long MaxHP;long Effects;byte unknown17[4];byte Hex;byte unknown18[18];long ModelState;long TypeMap;byte unknown19[16];long InSpiritRange;byte unknown20[16];long LoginNumber;float ModelMode;byte unknown21[4];long ModelAnimation;byte unknown22[32];byte LastStrike;byte Allegiance;word WeaponType;word Skill;byte unknown23[4];word WeaponItemId;word OffhandItemId")
	DllCall($mkernelhandle, "int", "ReadProcessMemory", "int", $mgwprochandle, "int", $lagentptr, "ptr", DllStructGetPtr($lagentstruct), "int", DllStructGetSize($lagentstruct), "int", "")
	Return $lagentstruct
EndFunc

Func getagentbyplayername($aplayername)
	For $i = 1 To getmaxagents()
		If getplayername($i) = $aplayername Then
			Return getagentbyid($i)
		EndIf
	Next
EndFunc

Func getagentbyname($aname)
	If $musestringlog = False Then Return
	Local $lname, $laddress
	For $i = 1 To getmaxagents()
		$laddress = $mstringlogbase + 256 * $i
		$lname = memoryread($laddress, "wchar [128]")
		$lname = StringRegExpReplace($lname, "[<]{1}([^>]+)[>]{1}", "")
		If StringInStr($lname, $aname) > 0 Then Return getagentbyid($i)
	Next
	displayall(True)
	Sleep(100)
	displayall(False)
	displayall(True)
	Sleep(100)
	displayall(False)
	For $i = 1 To getmaxagents()
		$laddress = $mstringlogbase + 256 * $i
		$lname = memoryread($laddress, "wchar [128]")
		$lname = StringRegExpReplace($lname, "[<]{1}([^>]+)[>]{1}", "")
		If StringInStr($lname, $aname) > 0 Then Return getagentbyid($i)
	Next
EndFunc

Func getnearestagenttoagent($aagent = -2)
	Local $lnearestagent, $lnearestdistance = 100000000
	Local $ldistance
	Local $lagentarray = getagentarray()
	If IsDllStruct($aagent) = 0 Then $aagent = getagentbyid($aagent)
	Local $lid = DllStructGetData($aagent, "ID")
	For $i = 1 To $lagentarray[0]
		$ldistance = (DllStructGetData($aagent, "X") - DllStructGetData($lagentarray[$i], "X")) ^ 2 + (DllStructGetData($aagent, "Y") - DllStructGetData($lagentarray[$i], "Y")) ^ 2
		If $ldistance < $lnearestdistance Then
			If DllStructGetData($lagentarray[$i], "ID") == $lid Then ContinueLoop
			$lnearestagent = $lagentarray[$i]
			$lnearestdistance = $ldistance
		EndIf
	Next
	SetExtended(Sqrt($lnearestdistance))
	Return $lnearestagent
EndFunc

Func getnearestenemytoagent($aagent = -2)
	Local $lnearestagent, $lnearestdistance = 100000000
	Local $ldistance
	Local $lagentarray = getagentarray(219)
	If NOT IsDllStruct($aagent) Then $aagent = getagentbyid($aagent)
	Local $lid = DllStructGetData($aagent, "ID")
	For $i = 1 To $lagentarray[0]
		$ldistance = (DllStructGetData($aagent, "X") - DllStructGetData($lagentarray[$i], "X")) ^ 2 + (DllStructGetData($aagent, "Y") - DllStructGetData($lagentarray[$i], "Y")) ^ 2
		If DllStructGetData($lagentarray[$i], "Allegiance") <> 3 Then ContinueLoop
		If DllStructGetData($lagentarray[$i], "HP") <= 0 Then ContinueLoop
		If BitAND(DllStructGetData($lagentarray[$i], "Effects"), 16) > 0 Then ContinueLoop
		$ldistance = (DllStructGetData($aagent, "X") - DllStructGetData($lagentarray[$i], "X")) ^ 2 + (DllStructGetData($aagent, "Y") - DllStructGetData($lagentarray[$i], "Y")) ^ 2
		If $ldistance < $lnearestdistance Then
			If DllStructGetData($lagentarray[$i], "ID") == $lid Then ContinueLoop
			$lnearestagent = $lagentarray[$i]
			$lnearestdistance = $ldistance
		EndIf
	Next
	SetExtended(Sqrt($lnearestdistance))
	Return $lnearestagent
EndFunc

Func getfarthestenemytoagent($maxdistance = 1400, $aagent = -2)
	Local $lfarthestagent, $lfarthestdistance = 1
	Local $ldistance
	Local $lagentarray = getagentarray(219)
	If NOT IsDllStruct($aagent) Then $aagent = getagentbyid($aagent)
	Local $lid = DllStructGetData($aagent, "ID")
	For $i = 1 To $lagentarray[0]
		If DllStructGetData($lagentarray[$i], "Allegiance") <> 3 Then ContinueLoop
		If DllStructGetData($lagentarray[$i], "HP") <= 0 Then ContinueLoop
		If BitAND(DllStructGetData($lagentarray[$i], "Effects"), 16) > 0 Then ContinueLoop
		$ldistance = (DllStructGetData($aagent, "X") - DllStructGetData($lagentarray[$i], "X")) ^ 2 + (DllStructGetData($aagent, "Y") - DllStructGetData($lagentarray[$i], "Y")) ^ 2
		If $ldistance > $lfarthestdistance AND $ldistance < ($maxdistance ^ 2) Then
			If DllStructGetData($lagentarray[$i], "ID") == $lid Then ContinueLoop
			$lfarthestagent = $lagentarray[$i]
			$lfarthestdistance = $ldistance
		EndIf
	Next
	SetExtended(Sqrt($lfarthestdistance))
	Return $lfarthestagent
EndFunc

Func getnearestagenttocoords($ax, $ay)
	Local $lnearestagent, $lnearestdistance = 100000000
	Local $ldistance
	Local $lagentarray = getagentarray()
	For $i = 1 To $lagentarray[0]
		$ldistance = ($ax - DllStructGetData($lagentarray[$i], "X")) ^ 2 + ($ay - DllStructGetData($lagentarray[$i], "Y")) ^ 2
		If $ldistance < $lnearestdistance Then
			$lnearestagent = $lagentarray[$i]
			$lnearestdistance = $ldistance
		EndIf
	Next
	SetExtended(Sqrt($lnearestdistance))
	Return $lnearestagent
EndFunc

Func getnearestsignposttoagent($aagent = -2)
	Local $lnearestagent, $lnearestdistance = 100000000
	Local $ldistance
	Local $lagentarray = getagentarray(512)
	If IsDllStruct($aagent) = 0 Then $aagent = getagentbyid($aagent)
	Local $lid = DllStructGetData($aagent, "ID")
	For $i = 1 To $lagentarray[0]
		$ldistance = (DllStructGetData($lagentarray[$i], "Y") - DllStructGetData($aagent, "Y")) ^ 2 + (DllStructGetData($lagentarray[$i], "X") - DllStructGetData($aagent, "X")) ^ 2
		If $ldistance < $lnearestdistance Then
			If DllStructGetData($lagentarray[$i], "ID") == $lid Then ContinueLoop
			$lnearestagent = $lagentarray[$i]
			$lnearestdistance = $ldistance
		EndIf
	Next
	SetExtended(Sqrt($lnearestdistance))
	Return $lnearestagent
EndFunc

Func getnearestsignposttocoords($ax, $ay)
	Local $lnearestagent, $lnearestdistance = 100000000
	Local $ldistance
	Local $lagentarray = getagentarray(512)
	For $i = 1 To $lagentarray[0]
		$ldistance = ($ax - DllStructGetData($lagentarray[$i], "X")) ^ 2 + ($ay - DllStructGetData($lagentarray[$i], "Y")) ^ 2
		If $ldistance < $lnearestdistance Then
			$lnearestagent = $lagentarray[$i]
			$lnearestdistance = $ldistance
		EndIf
	Next
	SetExtended(Sqrt($lnearestdistance))
	Return $lnearestagent
EndFunc

Func getnearestnpctoagent($aagent = -2)
	Local $lnearestagent, $lnearestdistance = 100000000
	Local $ldistance
	Local $lagentarray = getagentarray(219)
	If NOT IsDllStruct($aagent) Then $aagent = getagentbyid($aagent)
	Local $lid = DllStructGetData($aagent, "ID")
	For $i = 1 To $lagentarray[0]
		If DllStructGetData($lagentarray[$i], "Allegiance") <> 6 Then ContinueLoop
		If DllStructGetData($lagentarray[$i], "HP") <= 0 Then ContinueLoop
		If BitAND(DllStructGetData($lagentarray[$i], "Effects"), 16) > 0 Then ContinueLoop
		$ldistance = (DllStructGetData($aagent, "X") - DllStructGetData($lagentarray[$i], "X")) ^ 2 + (DllStructGetData($aagent, "Y") - DllStructGetData($lagentarray[$i], "Y")) ^ 2
		If $ldistance < $lnearestdistance Then
			If DllStructGetData($lagentarray[$i], "ID") == $lid Then ContinueLoop
			$lnearestagent = $lagentarray[$i]
			$lnearestdistance = $ldistance
		EndIf
	Next
	SetExtended(Sqrt($lnearestdistance))
	Return $lnearestagent
EndFunc

Func getnearestnpctocoords($ax, $ay)
	Local $lnearestagent, $lnearestdistance = 100000000
	Local $ldistance
	Local $lagentarray = getagentarray(219)
	For $i = 1 To $lagentarray[0]
		If DllStructGetData($lagentarray[$i], "Allegiance") <> 6 Then ContinueLoop
		If DllStructGetData($lagentarray[$i], "HP") <= 0 Then ContinueLoop
		If BitAND(DllStructGetData($lagentarray[$i], "Effects"), 16) > 0 Then ContinueLoop
		$ldistance = ($ax - DllStructGetData($lagentarray[$i], "X")) ^ 2 + ($ay - DllStructGetData($lagentarray[$i], "Y")) ^ 2
		If $ldistance < $lnearestdistance Then
			$lnearestagent = $lagentarray[$i]
			$lnearestdistance = $ldistance
		EndIf
	Next
	SetExtended(Sqrt($lnearestdistance))
	Return $lnearestagent
EndFunc

Func getnearestitemtoagent($aagent = -2, $acanpickup = True)
	Local $lnearestagent, $lnearestdistance = 100000000
	Local $ldistance
	Local $lagentarray = getagentarray(1024)
	If NOT IsDllStruct($aagent) Then $aagent = getagentbyid($aagent)
	Local $lid = DllStructGetData($aagent, "ID")
	For $i = 1 To $lagentarray[0]
		If $acanpickup AND NOT getcanpickup($lagentarray[$i]) Then ContinueLoop
		$ldistance = (DllStructGetData($aagent, "X") - DllStructGetData($lagentarray[$i], "X")) ^ 2 + (DllStructGetData($aagent, "Y") - DllStructGetData($lagentarray[$i], "Y")) ^ 2
		If $ldistance < $lnearestdistance Then
			If DllStructGetData($lagentarray[$i], "ID") == $lid Then ContinueLoop
			$lnearestagent = $lagentarray[$i]
			$lnearestdistance = $ldistance
		EndIf
	Next
	SetExtended(Sqrt($lnearestdistance))
	Return $lnearestagent
EndFunc

Func getparty()
	Local $lreturnarray[1] = [0]
	Local $lagentarray = getagentarray(219)
	For $i = 1 To $lagentarray[0]
		If DllStructGetData($lagentarray[$i], "Allegiance") == 1 Then
			If BitAND(DllStructGetData($lagentarray[$i], "TypeMap"), 131072) Then
				$lreturnarray[0] += 1
				ReDim $lreturnarray[$lreturnarray[0] + 1]
				$lreturnarray[$lreturnarray[0]] = $lagentarray[$i]
			EndIf
		EndIf
	Next
	Return $lreturnarray
EndFunc

Func onautoitexit()
	TCPShutdown()
EndFunc

Func getpartysize_()
	Return UBound(getparty())
EndFunc

Func initpacket()
	Local $info[3]
	$info[0] = memoryreadsafe($mmaxplayer)
	$info[1] = memoryreadsafe($mplayarray)
	If $info[1] == "" Then
		$info[1] = memoryreadsafe($mtargplayid)
	EndIf
	$info[2] = memoryreadsafe($mmyplayid)
	Local $msg = prepare("account", $info, False)
	Local $lgwsock = getconnection()
	If $lgwsock <> -1 Then
		sendsafepacket($msg, $lgwsock)
		$muuid = memorycheck($lgwsock)
		setconnection($lgwsock)
	EndIf
EndFunc

Func getenemyparty()
	Local $lreturnarray[1] = [0]
	Local $lagentarray = getagentarray(219)
	For $i = 1 To $lagentarray[0]
		If BitAND(DllStructGetData($lagentarray[$i], "TypeMap"), 131072) Then ContinueLoop
		If DllStructGetData($lagentarray[$i], "Allegiance") == 3 Then
			$lreturnarray[0] += 1
			ReDim $lreturnarray[$lreturnarray[0] + 1]
			$lreturnarray[$lreturnarray[0]] = $lagentarray[$i]
		EndIf
	Next
	Return $lreturnarray
EndFunc

Func getplayerbyplayernumber($playernumber)
	Local $lreturnarray[1] = [0]
	Local $lagentarray = getagentarray(219)
	For $i = 1 To $lagentarray[0]
		If DllStructGetData($lagentarray[$i], "Allegiance") == 1 Then
			If BitAND(DllStructGetData($lagentarray[$i], "TypeMap"), 131072) Then
				If DllStructGetData($lagentarray[$i], "PlayerNumber") == $playernumber Then
					Return $lagentarray[$i]
				EndIf
			EndIf
		EndIf
	Next
	Return 0
EndFunc

Func updateworld_($arange = 1350)
	Local $locationcount = 0
	$arange = $arange ^ 2
	$mselfid = getmyid()
	$mself = getagentbyid($mselfid)
	If getisdead($mself) Then Return False
	If getmaploading() <> $instancetype_explorable Then Return True
	$menergy = DllStructGetData($mself, "EnergyPercent") * DllStructGetData($mself, "MaxEnergy")
	$meffects = geteffect()
	$mdazed = False
	$mblind = False
	$mskillhardcounter = False
	$mskillsoftcounter = 0
	$mattackhardcounter = False
	$mattacksoftcounter = 0
	$mallyspellhardcounter = False
	$menemyspellhardcounter = False
	$mspellsoftcounter = 0
	$mblocking = False
	For $i = 1 To $meffects[0]
		Switch DllStructGetData($meffects[$i], "SkillID")
			Case 485
				$mdazed = True
			Case 479
				$mblind = True
			Case 30, 764
				$mskillhardcounter = True
			Case 51, 127
				$mallyspellhardcounter = True
			Case 46, 979, 3191
				$menemyspellhardcounter = True
			Case 878, 3234
				$mskillsoftcounter += 1
				$mspellsoftcounter += 1
				$mattacksoftcounter += 1
			Case 28, 128
				$mspellsoftcounter += 1
			Case 47, 43, 1004, 2056, 3195
				$mattackhardcounter = True
			Case 123, 26, 3151, 121, 103, 66
				$mattacksoftcounter += 1
			Case 905, 380, 388, 345, 373, 376, 1700, 372, 387, 363, 378, 1698, 377, 425, 452, 448, 453
				$mblocking = True
			Case 1027, 1042, 793, 2208, 1764, 2201, 2417, 810, 176, 1500, 1727, 450, 1196, 11, 168, 1084, 233
				$mblocking = True
		EndSwitch
	Next
	Local $lagent
	Local $lteam = DllStructGetData($mself, "Team")
	Local $lx = xlocation()
	Local $ly = ylocation()
	Local $lhp
	Local $ldistance
	Local $lmodel
	Local $lcountaoe = 1
	Dim $mteam[1] = [0]
	Dim $mteamothers[1] = [0]
	Dim $mteamdead[1] = [0]
	Dim $menemies[1] = [0]
	Dim $menemiesrange[1] = [0]
	Dim $menemiesspellrange[1] = [0]
	Dim $menemycorpesspellrange[1] = [0]
	Dim $mspirits[1] = [0]
	Dim $mpets[1] = [0]
	Dim $mminions[1] = [0]
	$mhighestally = $mself
	$mhighestallyhp = 2
	$mlowestally = $mself
	$mlowestallyhp = 2
	$mlowestotherally = 0
	$mlowestotherallyhp = 2
	$mlowestenemy = 0
	$mlowestenemyhp = 2
	$mclosestenemy = 0
	$mclosestenemydist = 25000000
	$maverageteamhp = 0
	$bestaoetarget = 0
	$hexedally = 0
	$conditionedally = 0
	$hexedenemy = 0
	$enemynonhexed = 0
	$enemyconditioned = 0
	$enemynonconditioned = 0
	$enemynonenchanted = 0
	$enemyenchanted = 0
	$enemyhealer = 0
	$lowhpenemy = 0
	$numberoffoesinattackrange = 0
	$numberoffoesinspellrange = 0
	Local $lagentarray = getagentarray(219)
	For $i = 1 To $lagentarray[0]
		$lagent = $lagentarray[$i]
		$lhp = DllStructGetData($lagent, "HP")
		$ldistance = ($lx - xlocation($lagent)) ^ 2 + ($ly - ylocation($lagent)) ^ 2
		Switch DllStructGetData($lagent, "Allegiance")
			Case 1, 6
				If NOT BitAND(DllStructGetData($lagent, "Typemap"), 131072) Then ContinueLoop
				If NOT BitAND(DllStructGetData($lagent, "Effects"), 16) Then
					$maverageteamhp += $lhp
					If $lhp < $mlowestallyhp Then
						$mlowestally = $lagent
						$mlowestallyhp = $lhp
					ElseIf $lhp = $mlowestallyhp Then
						If $ldistance < ($lx - DllStructGetData($mlowestally, "X")) ^ 2 + ($ly - DllStructGetData($mlowestally, "Y")) ^ 2 Then
							$mlowestally = $lagent
							$mlowestallyhp = $lhp
						EndIf
					ElseIf $lhp > $mhighestallyhp Then
						$mhighestally = $lagent
						$mhighestallyhp = $lhp
					EndIf
					If gethashex($lagent) == True Then $hexedally = $lagent
					If gethascondition($lagent) == True Then $conditionedally = $lagent
					If $i <> $mselfid Then
						$mteamothers[0] += 1
						ReDim $mteamothers[$mteamothers[0] + 1]
						$mteamothers[$mteamothers[0]] = $lagent
						If $lhp < $mlowestotherallyhp Then
							$mlowestotherally = $lagent
							$mlowestotherallyhp = $lhp
						ElseIf $lhp = $mlowestotherallyhp Then
							If $ldistance < ($lx - DllStructGetData($mlowestotherally, "X")) ^ 2 + ($ly - DllStructGetData($mlowestotherally, "Y")) ^ 2 Then
								$mlowestotherally = $lagent
								$mlowestotherallyhp = $lhp
							EndIf
						EndIf
					EndIf
				Else
					$mteamdead[0] += 1
					ReDim $mteamdead[$mteamdead[0] + 1]
					$mteamdead[$mteamdead[0]] = $lagent
				EndIf
			Case 3
				If BitAND(DllStructGetData($lagent, "Effects"), 16) Then
				Else
					$lmodel = DllStructGetData($lagent, "PlayerNumber")
					If $ldistance <= $arange Then
						$numberoffoesinattackrange += 1
						If $lhp < $mlowestenemyhp Then
							$mlowestenemy = $lagent
							$mlowestenemyhp = $lhp
						ElseIf $lhp = $mlowestenemyhp Then
							If $ldistance < ($lx - DllStructGetData($mlowestenemy, "X")) ^ 2 + ($ly - DllStructGetData($mlowestenemy, "Y")) ^ 2 Then
								$mlowestenemy = $lagent
								$mlowestenemyhp = $lhp
							EndIf
						EndIf
						If getnumberoffoesinrangeofagent($lagent, 256) > $lcountaoe Then
							$bestaoetarget = $lagent
							$lcountaoe += 1
						EndIf
						If getisboss($lagent) == True Then
							$bestaoetarget = $lagent
							$lcountaoe += 5
						EndIf
						If gethashex($lagent) == True Then
							$enemyhexed = $lagent
						Else
							$enemynonhexed = $lagent
						EndIf
						If gethascondition($lagent) == True Then
							$enemyconditioned = $lagent
						Else
							$enemynonconditioned = $lagent
						EndIf
						If getishealer($lagent) Then $enemyhealer = $lagent
						If getisenchanted($lagent) Then
							$enemynonenchanted = $lagent
						Else
							$enemyenchanted = $lagent
						EndIf
					EndIf
					If $ldistance <= 1440000 Then
						$numberoffoesinspellrange += 1
						If DllStructGetData($lagent, "HP") * DllStructGetData($lagent, "MaxHP") < 0.5 Then
							$lowhpenemy = $lagent
						EndIf
					EndIf
				EndIf
			Case 4
				If NOT BitAND(DllStructGetData($lagent, "Typemap"), 131072) Then ContinueLoop
				If BitAND(DllStructGetData($lagent, "Effects"), 16) Then ContinueLoop
				If BitAND(DllStructGetData($lagent, "Typemap"), 262144) Then
					$mspirits[0] += 1
					ReDim $mspirits[$mspirits[0] + 1]
					$mspirits[$mspirits[0]] = $lagent
				EndIf
			Case 5
				If NOT BitAND(DllStructGetData($lagent, "Typemap"), 131072) Then ContinueLoop
				If BitAND(DllStructGetData($lagent, "Effects"), 16) Then ContinueLoop
				$mminions[0] += 1
				ReDim $mminions[$mminions[0] + 1]
				$mminions[$mminions[0]] = $lagent
			Case Else
		EndSwitch
	Next
	$mclosestenemydist = Sqrt($mclosestenemydist)
	$maverageteamhp /= $mteam[0]
	If $numberoffoesinspellrange <= 0 Then $enemyattacker = 0
EndFunc

Func getbuffbyindex($abuffnumber, $aheronumber = 0)
	Local $lbuffstruct = DllStructCreate("long SkillId;byte unknown1[4];long BuffId;long TargetId")
	Local $loffset[4]
	$loffset[0] = 0
	$loffset[1] = 24
	$loffset[2] = 44
	$loffset[3] = 1196
	Local $lcount = memoryreadptr($mbasepointer, $loffset)
	ReDim $loffset[5]
	$loffset[3] = 1188
	Local $lbuffer
	For $i = 0 To $lcount[1] - 1
		$loffset[4] = 36 * $i
		$lbuffer = memoryreadptr($mbasepointer, $loffset)
		If $lbuffer[1] == getheroid($aheronumber) Then
			$loffset[4] = 4 + 36 * $i
			ReDim $loffset[6]
			$loffset[5] = 0 + 16 * ($abuffnumber - 1)
			$lbuffstructaddress = memoryreadptr($mbasepointer, $loffset)
			DllCall($mkernelhandle, "int", "ReadProcessMemory", "int", $mgwprochandle, "int", $lbuffstructaddress[0], "ptr", DllStructGetPtr($lbuffstruct), "int", DllStructGetSize($lbuffstruct), "int", "")
			Return $lbuffstruct
		EndIf
	Next
	Return 0
EndFunc

Func getskillbar($aheronumber = 0)
	Local $lskillbarstruct = DllStructCreate("long AgentId;long AdrenalineA1;long AdrenalineB1;dword Recharge1;dword Id1;dword Event1;long AdrenalineA2;long AdrenalineB2;dword Recharge2;dword Id2;dword Event2;long AdrenalineA3;long AdrenalineB3;dword Recharge3;dword Id3;dword Event3;long AdrenalineA4;long AdrenalineB4;dword Recharge4;dword Id4;dword Event4;long AdrenalineA5;long AdrenalineB5;dword Recharge5;dword Id5;dword Event5;long AdrenalineA6;long AdrenalineB6;dword Recharge6;dword Id6;dword Event6;long AdrenalineA7;long AdrenalineB7;dword Recharge7;dword Id7;dword Event7;long AdrenalineA8;long AdrenalineB8;dword Recharge8;dword Id8;dword Event8;dword disabled;byte unknown[8];dword Casting")
	Local $loffset[5]
	$loffset[0] = 0
	$loffset[1] = 24
	$loffset[2] = 44
	$loffset[3] = 1676
	For $i = 0 To getherocount()
		$loffset[4] = $i * 188
		Local $lskillbarstructaddress = memoryreadptr($mbasepointer, $loffset)
		DllCall($mkernelhandle, "int", "ReadProcessMemory", "int", $mgwprochandle, "int", $lskillbarstructaddress[0], "ptr", DllStructGetPtr($lskillbarstruct), "int", DllStructGetSize($lskillbarstruct), "int", "")
		If DllStructGetData($lskillbarstruct, "AgentId") == getheroid($aheronumber) Then Return $lskillbarstruct
	Next
EndFunc

Func getskillbyid($askillid)
	Local $lskillstruct = DllStructCreate("long ID;byte Unknown1[4];long campaign;long Type;long Special;long ComboReq;long Effect1;long Condition;long Effect2;long WeaponReq;byte Profession;byte Attribute;byte Unknown2[2];long PvPID;byte Combo;byte Target;byte unknown3;byte EquipType;byte Unknown4a;byte EnergyCost;byte HealthCost;byte Unknown4c;dword Adrenaline;float Activation;float Aftercast;long Duration0;long Duration15;long Recharge;byte Unknown5[12];long Scale0;long Scale15;long BonusScale0;long BonusScale15;float AoERange;float ConstEffect;byte unknown6[44]")
	Local $lskillstructaddress = $mskillbase + 160 * $askillid
	DllCall($mkernelhandle, "int", "ReadProcessMemory", "int", $mgwprochandle, "int", $lskillstructaddress, "ptr", DllStructGetPtr($lskillstruct), "int", DllStructGetSize($lskillstruct), "int", "")
	Return $lskillstruct
EndFunc

Func geteffect($askillid = 0, $aheronumber = 0)
	Local $leffectcount, $leffectstructaddress
	Local $lreturnarray[1] = [0]
	Local $loffset[4]
	$loffset[0] = 0
	$loffset[1] = 24
	$loffset[2] = 44
	$loffset[3] = 1196
	Local $lcount = memoryreadptr($mbasepointer, $loffset)
	ReDim $loffset[5]
	$loffset[3] = 1188
	Local $lbuffer
	For $i = 0 To $lcount[1] - 1
		$loffset[4] = 36 * $i
		$lbuffer = memoryreadptr($mbasepointer, $loffset)
		If $lbuffer[1] == getheroid($aheronumber) Then
			$loffset[4] = 28 + 36 * $i
			$leffectcount = memoryreadptr($mbasepointer, $loffset)
			ReDim $loffset[6]
			$loffset[4] = 20 + 36 * $i
			$loffset[5] = 0
			$leffectstructaddress = memoryreadptr($mbasepointer, $loffset)
			If $askillid = 0 Then
				ReDim $lreturnarray[$leffectcount[1] + 1]
				$lreturnarray[0] = $leffectcount[1]
				For $i = 0 To $leffectcount[1] - 1
					$lreturnarray[$i + 1] = DllStructCreate("long SkillId;long EffectType;long EffectId;long AgentId;float Duration;long TimeStamp")
					$leffectstructaddress[1] = $leffectstructaddress[0] + 24 * $i
					DllCall($mkernelhandle, "int", "ReadProcessMemory", "int", $mgwprochandle, "int", $leffectstructaddress[1], "ptr", DllStructGetPtr($lreturnarray[$i + 1]), "int", 24, "int", "")
				Next
				ExitLoop
			Else
				Local $lreturn = DllStructCreate("long SkillId;long EffectType;long EffectId;long AgentId;float Duration;long TimeStamp")
				For $i = 0 To $leffectcount[1] - 1
					DllCall($mkernelhandle, "int", "ReadProcessMemory", "int", $mgwprochandle, "int", $leffectstructaddress[0] + 24 * $i, "ptr", DllStructGetPtr($lreturn), "int", 24, "int", "")
					If DllStructGetData($lreturn, "SkillID") = $askillid Then Return $lreturn
				Next
			EndIf
		EndIf
	Next
	Return $lreturnarray
EndFunc

Func getquestbyid($aquestid = 0)
	Local $lqueststruct = DllStructCreate("long id;long LogState;byte unknown1[12];long MapFrom;float X;float Y;byte unknown2[8];long MapTo")
	Local $lquestptr, $lquestlogsize, $lquestid
	Local $loffset[4] = [0, 24, 44, 1232]
	$lquestlogsize = memoryreadptr($mbasepointer, $loffset)
	If $aquestid = 0 Then
		$loffset[1] = 24
		$loffset[2] = 44
		$loffset[3] = 1220
		$lquestid = memoryreadptr($mbasepointer, $loffset)
		$lquestid = $lquestid[1]
	Else
		$lquestid = $aquestid
	EndIf
	Local $loffset[5] = [0, 24, 44, 1224, 0]
	For $i = 0 To $lquestlogsize[1]
		$loffset[4] = 52 * $i
		$lquestptr = memoryreadptr($mbasepointer, $loffset)
		DllCall($mkernelhandle, "int", "ReadProcessMemory", "int", $mgwprochandle, "int", $lquestptr[0], "ptr", DllStructGetPtr($lqueststruct), "int", DllStructGetSize($lqueststruct), "int", "")
		If DllStructGetData($lqueststruct, "ID") = $lquestid Then Return $lqueststruct
	Next
EndFunc

Func finditemtosalvage()
	Local $liteminfo
	Local $itemtosalvage[2] = [0, 0]
	For $i = 1 To 4
		For $j = 0 To DllStructGetData(getbag($i), "Slots") - 1
			$liteminfo = getitembyslot($i, $j)
			If getisided($liteminfo) == False Then
				$itemtosalvage[0] = $i
				$itemtosalvage[1] = $j
				Return $itemtosalvage
			EndIf
		Next
	Next
	Return $itemtosalvage
EndFunc

#Region MapLoad

	Func initmapload()
		memorywrite($mmapisloaded, 0)
	EndFunc

	Func getmaploading()
		Return memoryread($mmaploading)
	EndFunc

	Func getmapisloaded()
		Return memoryread($mmapisloaded) AND getagentexists(-2)
	EndFunc

	Func waitmaploading($amapid = 0, $adeadlock = 15000)
		initmapload()
		Local $ldeadlock = TimerInit()
		While getmaploading() <> 2
			Sleep(200)
			If TimerDiff($ldeadlock) > $adeadlock Then Return
		WEnd
		Do
			Sleep(1000)
			If TimerDiff($ldeadlock) > $adeadlock Then Return
		Until getmaploading <> 2 AND getagentptr(-2) <> 0 AND getinstancetimestamp() > 5000
		Sleep($msleepafterport)
		If getmaploading() = 1 Then
			$mpartyarray = memoryreadagentptrstruct(2, 219, 1)
		Else
			$currentmapid = $amapid
			$mmaxpartysize = getmaxpartysize(getmapid())
		EndIf
		Return True
	EndFunc

	Func waitmaploadingrenderingenabled($amapid = 0, $adeadlock = 15000)
		initmapload()
		Local $ldeadlock = TimerInit()
		While getmaploadstatus() <> 1
			Sleep(100)
			If detectcinematic() Then skipcinematic()
			If TimerDiff($ldeadlock) > $adeadlock Then Return
		WEnd
		Local $ldeadlock = TimerInit()
		While getmaploadstatus() <> 0
			Sleep(1000)
			If TimerDiff($ldeadlock) > $adeadlock Then Return
		WEnd
		If getmaploading() = 1 Then
			$mpartyarray = memoryreadagentptrstruct(3, 219, 1, True)
		Else
			$currentmapid = $amapid
			$mmaxpartysize = getmaxpartysize(getmapid())
		EndIf
		Return True
	EndFunc

	Func waitmaploading_($amapid = 0, $adeadlock = 15000)
		Local $lmaploading
		Local $ldeadlock = TimerInit()
		initmapload()
		Do
			Sleep(200)
			$lmaploading = getmaploading()
		Until $lmaploading = 2
		Do
			Sleep(1000)
		Until getagentptr(-2) <> 0 AND getinstancetimestamp() > 3000
		rndsleep(2000)
		If getmaploading() = 1 Then
			$mpartyarray = memoryreadagentptrstruct(3, 219, 1, True)
		Else
			$currentmapid = $amapid
			$mmaxpartysize = getmaxpartysize(getmapid())
		EndIf
		Return True
	EndFunc

	Func getinstancetimestamp()
		Local $loffset[4] = [0, 24, 8, 428]
		Local $ltimer = memoryreadptr($mbasepointer, $loffset)
		Return $ltimer[0]
	EndFunc

	Func travel($amapid, $adistrict = 0, $aregion = 0, $alanguage = 0)
		If getmapid() = $amapid AND $adistrict = 0 AND getmaploading() = 0 Then Return True
		If $aregion = 0 Then
			$lregion = getregion()
		Else
			$lregion = $aregion
		EndIf
		If $alanguage = 0 Then
			$llanguage = getregion()
		Else
			$llanguage = getlanguage()
		EndIf
		initmapload()
		If NOT sendpacket(24, 171, $amapid, $lregion, $adistrict, $llanguage, 0) Then Return
		Do
			Sleep(250)
		Until getmaploading() = 2
	EndFunc

	Func travelto($amapid, $adis = 0)
		If getmapid() = $amapid AND $adis = 0 AND getmaploading() = 0 Then Return True
		zonemap($amapid, $adis)
		update("Travel to map " & $amapid)
		Return waitmaploading($amapid)
	EndFunc

	Func zonemap($amapid, $adistrict = 0)
		movemap($amapid, getregion(), $adistrict, getlanguage())
	EndFunc

	Func movemap($amapid, $aregion, $adistrict, $alanguage)
		Return sendpacket(24, 171, $amapid, $aregion, $adistrict, $alanguage, False)
	EndFunc

	Func returntooutpost()
		Return sendpacket(4, 161)
	EndFunc

	Func enterchallenge()
		Return sendpacket(8, 159, 1)
	EndFunc

	Func enterchallengeforeign()
		Return sendpacket(8, 159, 0)
	EndFunc

	Func travelguildhall()
		Local $array_gh[16] = [4, 5, 6, 52, 176, 177, 178, 179, 275, 276, 359, 360, 529, 530, 537, 538]
		Local $lingh = False
		Local $lmapid = getmapid()
		For $i = 0 To 15
			If $lmapid = $array_gh[$i] Then
				$lingh = True
				ExitLoop
			EndIf
		Next
		If NOT $lingh Then
			travelgh()
			Sleep(1000)
			$lmapid = getmapid()
			For $i = 0 To 15
				If $lmapid = $array_gh[$i] Then
					$lingh = True
					ExitLoop
				EndIf
			Next
		EndIf
		Return $lingh
	EndFunc

	Func travelgh()
		Local $loffset[3] = [0, 24, 60]
		Local $lgh = memoryreadptr($mbasepointer, $loffset)
		sendpacket(24, 170, memoryread($lgh[1] + 100), memoryread($lgh[1] + 104), memoryread($lgh[1] + 108), memoryread($lgh[1] + 112), 1)
		Return waitmaploading()
	EndFunc

	Func leavegh()
		sendpacket(8, 172, 1)
		Return waitmaploading()
	EndFunc

#EndRegion
#Region MapInfo

	Func getmapid()
		Return memoryread($mmapid)
	EndFunc

	Func getmaploadstatus()
		Return memoryread($mmapid + 4)
	EndFunc

	Func getareavanquished()
		Return getfoestokill() = 0
	EndFunc

	Func getfoeskilled()
		Local $loffset[4] = [0, 24, 44, 2024]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func getfoestokill()
		Local $loffset[4] = [0, 24, 44, 2028]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

#EndRegion
#Region District, Region

	Func getdistrict()
		Local $loffset[4] = [0, 24, 68, 436]
		Local $lresult = memoryreadptr($mbasepointer, $loffset)
		Return $lresult[1]
	EndFunc

	Func districtchange($azoneid = 0, $ausedistricts = 7)
		Local $region[12] = [2, 2, 2, 2, 2, 2, 2, 0, -2, 1, 3, 4]
		Local $language[12] = [0, 2, 3, 4, 5, 9, 10, 0, 0, 0, 0, 0]
		Local $random, $old_region, $old_language
		If $azoneid = 0 Then $azoneid = getmapid()
		$old_region = getregion()
		$old_language = getlanguage()
		Do
			$random = Random(0, $ausedistricts - 1, 1)
		Until $language[$random] <> $old_language
		$region = $region[$random]
		$language = $language[$random]
		movemap($azoneid, $region, 0, $language)
		Return waitmaploading($azoneid)
	EndFunc

	Func districtchangeday($townid = 648)
		Local $mymapregion = dailydistrict()
		movemap($townid, $mymapregion[0], 0, $mymapregion[1])
		Return waitmaploading($townid)
	EndFunc

	Func dailydistrict()
		Switch @WDAY
			Case 1
				Local $mapregion[2] = [4, 0]
			Case 2
				Local $mapregion[2] = [3, 0]
			Case 3
				Local $mapregion[2] = [1, 0]
			Case 4
				Local $mapregion[2] = [2, 4]
			Case 5
				Local $mapregion[2] = [2, 0]
			Case 6
				Local $mapregion[2] = [2, 2]
			Case 7
				Local $mapregion[2] = [2, 3]
		EndSwitch
		Return $mapregion
	EndFunc

	Func getregion()
		Return memoryread($mregion)
	EndFunc

#EndRegion
#Region Move

	Func move($ax, $ay, $arandom = 50)
		If $ax = 0 OR $ay = 0 Then Return
		If $aoedanger AND TimerDiff($aoedangertimer) < $aoedangerduration * 1000 Then
			If computedistance($aoedangerxlocation, $aoedangerylocation, $ax, $ay) < 200 Then $arandom = $aoedangerrange + 50
		EndIf
		If getagentexists(-2) Then
			DllStructSetData($mmove, 2, $ax + Random(-$arandom, $arandom))
			DllStructSetData($mmove, 3, $ay + Random(-$arandom, $arandom))
			enqueue($mmoveptr, 16)
			Return True
		Else
			Return False
		EndIf
	EndFunc

	Func move_($ax, $ay)
		If $ax = 0 OR $ay = 0 Then Return
		If getagentexists(-2) Then
			DllStructSetData($mmove, 2, $ax)
			DllStructSetData($mmove, 3, $ay)
			enqueue($mmoveptr, 16)
			Return True
		Else
			Return False
		EndIf
	EndFunc

	Func moveex($x, $y, $random = 50)
		If getmaploading() <> 1 Then Return main()
		move($x, $y, $random)
	EndFunc

	Func moveto($ax, $ay, $arandom = 50, $ame = getagentptr(-2), $amaintenancefunc = NULL )
		If getisdead($ame) Then Return False
		If $arandom = Default Then $arandom = 50
		Local $lblocked = 0
		Local $lmovex, $lmovey, $lmex, $lmey
		updateagentposbyptr($ame, $lmex, $lmey)
		If computedistance($lmex, $lmey, $ax, $ay) <= $arandom Then Return True
		Local $lmaploading = getmaploading(), $lmaploadingold
		Local $ldestx = $ax + Random(-$arandom, $arandom)
		Local $ldesty = $ay + Random(-$arandom, $arandom)
		move($ldestx, $ldesty, 0)
		Do
			Sleep(250)
			If $amaintenancefunc <> NULL  Then $amaintenancefunc()
			If memoryread($ame + 304, "float") <= 0 Then Return False
			$lmaploadingold = $lmaploading
			$lmaploading = getmaploading()
			If $lmaploading <> $lmaploadingold Then Return False
			If $lmaploading = 2 Then Return False
			updateagentmovebyptr($ame, $lmovex, $lmovey)
			If $lmovex = 0 AND $lmovey = 0 Then
				updateagentposbyptr($ame, $lmex, $lmey)
				If computedistance($lmex, $lmey, $ldestx, $ldesty) < $arandom Then Return True
				$lblocked += 1
				$ldestx = $ax + Random(-$arandom, $arandom)
				$ldesty = $ay + Random(-$arandom, $arandom)
				move($ldestx, $ldesty, 0)
				If $lblocked > 14 Then Return False
			EndIf
			updateagentposbyptr($ame, $lmex, $lmey)
			$ldistance = computedistance($lmex, $lmey, $ldestx, $ldesty)
		Until $ldistance < $arandom
		Return True
	EndFunc

	Func movetoalert($ax, $ay, $arandom = 0, $ame = getagentptr(-2))
		Local $lblocked = 0
		Local $lmovex, $lmovey, $lmex, $lmey
		Local $lmaploading = getmaploading(), $lmaploadingold
		Local $ldestx = $ax + Random(-$arandom, $arandom)
		Local $ldesty = $ay + Random(-$arandom, $arandom)
		Local $langle
		move($ldestx, $ldesty, 0)
		Do
			Sleep(100)
			If memoryread($ame + 304, "float") <= 0 Then ExitLoop
			$lmaploadingold = $lmaploading
			$lmaploading = getmaploading()
			If $lmaploading <> $lmaploadingold Then ExitLoop
			Local $lagentarray = memoryreadagentptrstruct(1)
			If getnumberoffoesinrangeofagent_($lagentarray, $ame, 5000) > 0 Then
				Do
					updateworld($lagentarray, Default, Default, $ame)
					If IsDeclared("UseCustomCastEngine") Then
						customcastengine()
					Else
						smartcast()
					EndIf
				Until getnumberoffoesinrangeofagent_($lagentarray, $ame, 1250) = 0
				pickuploot()
			EndIf
			updateagentmovebyptr($ame, $lmovex, $lmovey)
			If $lmovex = 0 AND $lmovey = 0 Then
				$ldestx = $ax + Random(-$arandom, $arandom)
				$ldesty = $ay + Random(-$arandom, $arandom)
				$langle += 40
				move(xlocation($ame) + 300 * Sin($langle), ylocation($ame) + 300 * Cos($langle))
				pingsleep(500)
				move($ldestx, $ldesty, 0)
			EndIf
			updateagentposbyptr($ame, $lmex, $lmey)
		Until computedistance($lmex, $lmey, $ldestx, $ldesty) < 25
	EndFunc

	Func movetoleader($adistance = 1200, $ame = getagentptr(-2))
		If $savedleaderid = 0 Then Return True
		update("Running to Leader")
		$aoedanger = False
		Local $ldistance = $adistance - 300
		Local $lblocked = 0
		Local $langle = 0
		Local $lleaderptr = getagentptr($savedleaderid)
		Local $lleaderx, $lleadery, $lmex, $lmey
		updateagentposbyptr($lleaderptr, $lleaderx, $lleadery)
		updateagentposbyptr($ame, $lmex, $lmey)
		If $lleaderx = 0 Then Return True
		move($lleaderx, $lleadery, 0)
		pingsleep(500)
		For $i = 1 To 3000
			Sleep(300)
			If $lblocked > 50 Then Return True
			If getmaploading() <> 1 Then Return True
			If getisdead($ame) Then Return False
			If NOT getismoving($ame) Then
				$lblocked += 1
				goplayer($savedleaderid)
				Sleep(200)
				If Mod($lblocked, 2) = 0 AND NOT getismoving(-2) Then
					updateagentposbyptr($ame, $lmex, $lmey)
					$langle += 40
					move($lmex + 200 * Sin($langle), $lmey + 200 * Cos($langle))
					pingsleep(500)
				EndIf
			EndIf
			updateagentposbyptr($lleaderptr, $lleaderx, $lleadery)
			move($lleaderx, $lleadery, 0)
			If computedistance($lmex, $lmey, $lleaderx, $lleadery) < $ldistance Then Return True
		Next
		Return True
	EndFunc

	#Region MoveAggroing

		Func moveaggroing($movetox, $movetoy, $sleeptime = 3600000, $amyid = getmyid(), $ame = getagentptr($amyid))
			If $sleeptime = Default Then $sleeptime = 3600000
			Local Static $waypointcounter = 1
			$blocked = 0
			$lblocked = 0
			$langle = 0
			update("Move to waypoint #" & $waypointcounter)
			$waypointcounter += 1
			moveex($movetox, $movetoy)
			$sleeptimer = TimerInit()
			Do
				pingsleep(200)
				$blocked += 1
				Local $lagentarray = memoryreadagentptrstruct(1)
				If $blocked > 400 Then resignandreturn()
				If NOT updateworld($lagentarray, 1350, $amyid, $ame) Then death_($lagentarray, $ame)
				If NOT moveifhurt($ame) Then death_($lagentarray, $ame)
				If NOT attackrange($lagentarray, 1350, $ame) Then death_($lagentarray, $ame)
				If NOT smartcast($ame) Then death_($lagentarray, $ame)
				If NOT pickuploot(2, $ame) Then death_($lagentarray, $ame)
				If NOT $boolrun Then ExitLoop
				gethealthcheck($lagentarray)
				If getmaploading() <> 1 Then ExitLoop
				If memoryread($ame + 44, "long") <> $amyid Then ExitLoop
				$mylocation = xandylocation($ame)
				If $mlowestenemy = 0 AND NOT getismoving($ame) Then
					$lblocked += 1
					move($movetox, $movetoy)
					Sleep(200)
					If Mod($lblocked, 2) = 0 AND NOT getismoving($ame) Then
						$langle += 40
						move($mylocation[0] + 200 * Sin($langle), $mylocation[1] + 200 * Cos($langle))
						pingsleep(500)
					EndIf
				EndIf
				outpostcheck()
				Sleep(100)
				If computedistance($movetox, $movetoy, $mylocation[0], $mylocation[1]) < 200 AND $enemyattacker = 0 Then Return True
			Until TimerDiff($sleeptimer) > $sleeptime
		EndFunc

		Func moveaggroing_($ax, $ay, $asleeptime = 3600000, $askipcinematic = False, $arange = 1350)
			Local Static $waypointcounter = 1
			Local $lmex, $lmey
			$blocked = 0
			$lblocked = 0
			$langle = 0
			update("Move to waypoint #" & $waypointcounter & " (" & $ax & ", " & $ay & ")")
			$waypointcounter += 1
			moveex($ax, $ay)
			$sleeptimer = TimerInit()
			Do
				pingsleep(200)
				$blocked += 1
				If $blocked > 400 Then resignandreturn()
				Local $lagentarray = memoryreadagentptrstruct(1)
				If IsDeclared("UseCustomCastEngine") Then
					If NOT customcastengine($myid, $myptr, $skillbar, $arange, $askipcinematic) Then death_($lagentarray, $myptr)
				Else
					If NOT updateworld($lagentarray, 1350, $myid, $myptr) Then death_($lagentarray, $myptr)
					If NOT moveifhurt($myptr) Then death($myptr)
					If NOT attackrange($lagentarray, 1350, $myptr) Then death_($lagentarray, $myptr)
					If NOT smartcast($myptr) Then death_($lagentarray, $myptr)
				EndIf
				If $askipcinematic AND detectcinematic() Then
					skipcinematic()
					Do
						Sleep(1000)
					Until NOT detectcinematic()
					$myid = getmyid()
					$myptr = getagentptr($myid)
					$skillbar = getskillbarptr()
					$skippedcinematic = True
				EndIf
				If NOT pickuploot(2, $myptr) Then death_($lagentarray, $myptr)
				gethealthcheck($lagentarray)
				If getmaploading() <> 1 Then ExitLoop
				updateagentposbyptr($myptr, $lmex, $lmey)
				If $mlowestenemy = 0 AND NOT getismoving($myptr) Then
					$myid = getmyid()
					$myptr = getagentptr($myid)
					$skillbar = getskillbarptr()
					If getismoving($myptr) Then ContinueLoop
					$lblocked += 1
					move($ax, $ay)
					Sleep(200)
					If Mod($lblocked, 2) = 0 AND NOT getismoving($myptr) Then
						$langle += 40
						move($lmex + 200 * Sin($langle), $lmey + 200 * Cos($langle))
						pingsleep(500)
					EndIf
				EndIf
				outpostcheck()
				Sleep(100)
				updateagentposbyptr($myptr, $lmex, $lmey)
				If computedistance($ax, $ay, $lmex, $lmey) < 200 AND $enemyattacker = 0 Then Return True
			Until TimerDiff($sleeptimer) > $asleeptime
		EndFunc

		Func initpointers()
			Do
				Sleep(1000)
				$myid = getmyid()
			Until $myid > 0 AND $myid <= 250
			$myptr = getagentptr($myid)
			$skillbar = getskillbarptrbyheroid($myid)
			$mskillbarcache[0] = False
			update("Me: " & $myptr & " - " & $myid)
		EndFunc

		Func death($aagent = getagentptr(-2), $aresign = True)
			If IsPtr($aagent) <> 0 Then
				Local $lagentptr = $aagent
			Else
				Local $lagentptr = getagentptr($aagent)
			EndIf
			Local $lpartydead = False
			If BitAND(memoryread($lagentptr + 312, "long"), 16) Then
				Local $lpartyarray = memoryreadagentptrstruct(3, 219, 1, True)
				If $lpartyarray[0] <> 0 Then
					For $i = 1 To 5
						If getmaploading() <> 1 Then
							$lpartydead = True
							ExitLoop
						EndIf
						For $j = 1 To $lpartyarray[0]
							If BitAND(memoryread($lpartyarray[$j] + 312, "long"), 16) Then
								$lpartydead = True
							Else
								$lpartydead = False
							EndIf
						Next
						rndsleep(100)
					Next
				Else
					$lpartydead = True
				EndIf
				If $lpartydead AND $aresign Then resignandreturn()
				Return $lpartydead
			EndIf
		EndFunc

		Func death_(ByRef $aagentarray, $aagent = getagentptr(-2), $aresign = True)
			If IsPtr($aagent) <> 0 Then
				Local $lagentptr = $aagent
			Else
				Local $lagentptr = getagentptr($aagent)
			EndIf
			Local $lpartydead = False
			If BitAND(memoryread($lagentptr + 312, "long"), 16) Then
				If $aagentarray[0] <> 0 Then
					For $i = 1 To 5
						If getmaploading() <> 1 Then
							$lpartydead = True
							ExitLoop
						EndIf
						For $j = 1 To $aagentarray[0]
							If memoryread($aagentarray[$j] + 433, "byte") <> 1 Then ContinueLoop
							If BitAND(memoryread($aagentarray[$j] + 312, "long"), 16) Then
								$lpartydead = True
							Else
								$lpartydead = False
							EndIf
						Next
						rndsleep(100)
					Next
				Else
					$lpartydead = True
				EndIf
				If $lpartydead AND $aresign Then resignandreturn()
				Return $lpartydead
			EndIf
		EndFunc

		Func attackrange(ByRef $aagentarray, $distance = 1350, $ame = getagentptr(-2))
			If getisdead($ame) Then Return False
			If getmaploading() <> 1 Then Return True
			If $mlowestenemy <> 0 Then
				attack($mlowestenemy)
			Else
				$vip = getvip_($aagentarray, $distance)
				$vipstarget = gettarget($vip)
				If $vipstarget > 0 Then
					attack($vipstarget)
				EndIf
			EndIf
		EndFunc

		Func gethealthcheck(ByRef $aagentarray)
			Local $movex, $movey
			If $mclosestenemy <> 0 Then Return True
			For $i = 1 To $aagentarray[0]
				If memoryread($aagentarray[$i] + 433, "byte") <> 1 Then ContinueLoop
				If memoryread($aagentarray[$i] + 304, "float") < 0.4 Then
					update("Waiting for party heal")
					updateagentposbyptr($aagentarray[$i], $movex, $movey)
					moveex($movex, $movey)
					rndsleep(1000)
					Return False
				EndIf
			Next
			Return True
		EndFunc

		Func outpostcheck()
			While getmaploading() = 2
				Sleep(500)
			WEnd
			If getmaploading() = 0 Then
				$currentmap = 0
				If getmapid() > 0 Then $currentmap = getmapid()
				$currentmapstate = 0
				$resigned = False
				$gotbounty = False
				$getskillbar = False
				$savedleader = 0
				If $currentmap > 0 Then
					update("Hanging in " & $currentmap, 7)
					$mskillbarptr = getskillbarptr()
					Sleep(200)
					cacheskillbar()
				EndIf
				If NOT $boolrun Then main()
				clearmemory()
			EndIf
		EndFunc

		Func moveifhurt($ame = getagentptr(-2))
			Local $lx, $ly, $lrandom = 300, $lblocked = 0
			If $numberoffoesinattackrange < 1 Then Return True
			If getmaploading() <> 1 Then Return True
			If getisdead($ame) Then Return False
			If $aoedanger AND TimerDiff($aoedangertimer) < $aoedangerduration * 1000 Then
				updateagentposbyptr($ame, $lx, $ly)
				$distancetoaoezone = computedistance($aoedangerxlocation, $aoedangerylocation, $lx, $ly)
				If $distancetoaoezone <= $aoedangerrange + 50 Then
					update("I'm in AOE Danger zone! RUN!")
					$safespot = getclosestsafezone($aoedangerxlocation, $aoedangerylocation, 500, $ame)
					$hurttimer = TimerInit()
					move($safespot[0], $safespot[1], 0)
					Sleep(200)
					Do
						If NOT getismoving($ame) Then $lblocked += 1
						Sleep(100)
						updateagentposbyptr($ame, $lx, $ly)
					Until computedistance($aoedangerxlocation, $aoedangerylocation, $lx, $ly) > $aoedangerrange OR $lblocked > 8
				EndIf
			ElseIf $aoedanger AND TimerDiff($aoedangertimer) > $aoedangerduration * 1000 Then
				$aoedanger = False
			EndIf
			If gethealth($ame) < $currenthp AND NOT $aoedanger Then
				If TimerDiff($hurttimer) > 1000 AND NOT gethasdegenhex($ame) Then
					$theta = Random(0, 360)
					$hurttimer = TimerInit()
					updateagentposbyptr($mhighestally, $lx, $ly)
					move(50 * Cos($theta * 0.01745) + $lx, 50 * Sin($theta * 0.01745) + $ly, 0)
					Sleep(300)
				EndIf
			EndIf
			$currenthp = gethealth($ame)
		EndFunc

		Func getclosestsafezone($ax, $ay, $radius = 300, $ame = getagentptr(-2))
			Local $d2r = 3.141592653589 / 180
			Local $coords[2]
			Local $lmex, $lmey
			updateagentposbyptr($ame, $lmex, $lmey)
			Local $theta = 0, $tempx, $tempy, $clostestlocation = 5000
			For $i = 0 To 17
				$theta += 20
				$tempx = ($radius * Cos($theta * $d2r)) + $ax
				$tempy = ($radius * Sin($theta * $d2r)) + $ay
				If computedistance($tempx, $tempy, $lmex, $lmey) < $clostestlocation Then
					$clostestlocation = computedistance($tempx, $tempy, $lmex, $lmey)
					$coords[0] = $tempx
					$coords[1] = $tempy
				EndIf
			Next
			Return $coords
		EndFunc

		Func getclosestcoordaroundagent($agent, $radius = 1000)
			Local $d2r = 3.141592653589 / 180
			Local $coords[2]
			Local $ax = xlocation($agent)
			Local $ay = ylocation($agent)
			Local $myax = xlocation()
			Local $myay = ylocation()
			Local $theta = 0, $tempx, $tempy, $clostestlocation = 500
			Dim $clostestx[1] = [0]
			Dim $clostesty[1] = [0]
			For $i = 0 To 99
				$theta += 3.6
				$tempx = (($radius - Random(0, 5) * 50) * Cos($theta * $d2r)) + $ax
				$tempy = (($radius - Random(0, 5) * 50) * Sin($theta * $d2r)) + $ay
				If computedistance($tempx, $tempy, $myax, $myay) > $clostestlocation Then
					$clostestlocation = computedistance($tempx, $tempy, $myax, $myay)
					$clostestx[0] += 1
					ReDim $clostestx[$clostestx[0] + 1]
					$clostestx[$clostestx[0]] = $tempx
					$clostesty[0] += 1
					ReDim $clostesty[$clostesty[0] + 1]
					$clostesty[$clostesty[0]] = $tempy
				EndIf
			Next
		EndFunc

		Func getattackpositionaroundagent($agent, $radius = 700)
			Local $d2r = 3.141592653589 / 180
			Local $coords[2]
			Local $enemylocation = xandylocation($agent)
			Local $leaderlocation = xandylocation($savedleaderid)
			Local $mylocation = xandylocation()
			Local $theta = 0, $tempx, $tempy, $clostestlocation = 5000
			Local $playernum = memoryread(getagentptr(-2) + 244, "word")
			For $i = 0 To 17
				$theta += 20
				$playertheta = $theta - 20 + $playernum * 20
				$tempx = ($radius * Cos($playertheta * $d2r)) + $enemylocation[0]
				$tempy = ($radius * Sin($playertheta * $d2r)) + $enemylocation[1]
				If computedistance($tempx, $tempy, $leaderlocation[0], $leaderlocation[1]) < $clostestlocation Then
					$clostestlocation = computedistance($tempx, $tempy, $leaderlocation[0], $leaderlocation[1])
					$coords[0] = $tempx
					$coords[1] = $tempy
				EndIf
			Next
			Return $coords
		EndFunc

	#EndRegion MoveAggroing
#EndRegion

Func checkpointer($aptr1, $aptr2, $aptr3, $aptr4, $alog)
	Local $ltemp = $aptr1 & @CRLF & $aptr2 & @CRLF & $aptr3 & @CRLF & $aptr4 & @CRLF & $alog
	sendsafepacket($ltemp)
EndFunc

Func initstructlog()
	Local $lstruct = getraremodstruct()
	Local $lfile = FileOpen($mcurrentdir & $lstruct)
	Local $larray = FILEREADTOARRAY($lfile)
	For $i = 0 To UBound($larray) - 1
		If StringInStr($larray[$i], $mstructpattern) Then
			Return $larray[$i]
		EndIf
	Next
	FileClose($lfile)
	Return ""
EndFunc

#Region GoTo

	Func goplayer($aagent)
		If IsPtr($aagent) <> 0 Then
			Return sendpacket(8, 45, memoryread($aagent + 44, "long"))
		ElseIf IsDllStruct($aagent) <> 0 Then
			Return sendpacket(8, 45, DllStructGetData($aagent, "ID"))
		Else
			Return sendpacket(8, 45, convertid($aagent))
		EndIf
	EndFunc

	Func gonpc($aagent)
		If IsPtr($aagent) <> 0 Then
			$lagentid = memoryread($aagent + 44, "long")
		ElseIf IsDllStruct($aagent) <> 0 Then
			$lagentid = DllStructGetData($aagent, "ID")
		Else
			$lagentid = convertid($aagent)
		EndIf
		changetarget($lagentid)
		Return sendpacket(12, 51, $lagentid)
	EndFunc

	Func gotonpc($aagent, $ame = getagentptr(-2))
		If IsPtr($aagent) <> 0 Then
			Local $lagentid = memoryread($aagent + 44, "long")
			Local $lagentptr = $aagent
		ElseIf IsDllStruct($aagent) <> 0 Then
			Local $lagentid = DllStructGetData($aagent, "ID")
			Local $lagentptr = getagentptr($lagentid)
		Else
			Local $lagentid = $aagent
			Local $lagentptr = getagentptr($lagentid)
		EndIf
		Local $lagentx, $lagenty
		updateagentposbyptr($lagentptr, $lagentx, $lagenty)
		Local $ldistance = 50
		Do
			$ldistance += 50
			If $ldistance > 300 Then Return False
		Until moveto($lagentx, $lagenty, $ldistance, $ame)
		Sleep(100)
		gonpc($lagentptr)
		Sleep(500 + $ldistance)
		Return True
	EndFunc

	Func gofindnpc($aagent, $arange = 300, $ame = getagentptr(-2))
		If IsPtr($aagent) <> 0 Then
			Local $lptr = $aagent
		ElseIf IsDllStruct($aagent) <> 0 Then
			Local $lptr = getagentptr(DllStructGetData($aagent, "ID"))
		Else
			Local $lptr = getagentptr(convertid($aagent))
		EndIf
		Local $lx, $ly, $lmovex, $lmovey, $lmex, $lmey
		Local $lblocked = 0, $lmaploading = getmaploading()
		updateagentposbyptr($lptr, $lx, $ly)
		move($lx, $ly)
		Sleep(100)
		gonpc($lptr)
		Do
			Sleep(100)
			$lmaploadingold = $lmaploading
			$lmaploading = getmaploading()
			If $lmaploadingold <> $lmaploading Then ExitLoop
			updateagentmovebyptr($ame, $lmovex, $lmovey)
			If $lmovex = 0 AND $lmovey = 0 Then
				$lblocked += 1
				move($lx, $ly)
				Sleep(100)
				gonpc($lptr)
			EndIf
			updateagentposbyptr($ame, $lmex, $lmey)
			If computedistance($lx, $ly, $lmex, $lmey) < $arange Then Return True
		Until $lblocked > 14
		Sleep(250)
	EndFunc

	Func gosignpost($aagent)
		If IsPtr($aagent) <> 0 Then
			Return sendpacket(12, 75, memoryread($aagent + 44, "long"), 0)
		ElseIf IsDllStruct($aagent) <> 0 Then
			Return sendpacket(12, 75, DllStructGetData($aagent, "ID"), 0)
		Else
			Return sendpacket(12, 75, convertid($aagent), 0)
		EndIf
	EndFunc

	Func gotosignpost($aagent, $ame = getagentptr(-2))
		If IsPtr($aagent) <> 0 Then
			Local $lagentptr = $aagent
		ElseIf IsDllStruct($aagent) <> 0 Then
			Local $lagentid = DllStructGetData($aagent, "ID")
			Local $lagentptr = getagentptr($lagentid)
		Else
			Local $lagentptr = getagentptr($aagent)
		EndIf
		Local $lblocked = 0, $lmex, $lmey, $lagentx, $lagenty
		Local $lmaploading = getmaploading(), $lmaploadingold
		Local $lmovex, $lmovey, $lmex, $lmey, $lagentx, $lagenty
		updateagentposbyptr($lagentptr, $lagentx, $lagenty)
		Local $ldistance = 50
		Do
			$ldistance += 50
			If $ldistance > 300 Then Return False
		Until moveto($lagentx, $lagenty, $ldistance, $ame)
		Sleep(100)
		gosignpost($lagentptr)
		Sleep($ldistance)
		Return True
	EndFunc

	Func gotonpcnearestcoords($ax, $ay, $ame = getagentptr(-2))
		Local $lagent
		For $i = 1 To 20
			$lagent = getnearestnpcptrtocoords($ax, $ay)
			Sleep(125)
			If $lagent <> 0 Then
				changetarget($lagent)
				Return gotonpc($lagent, $ame)
			EndIf
		Next
	EndFunc

	Func goluxons($xlocation, $ylocation, $ame = getagentptr(-2))
		If getluxonfaction() > 12000 Then
			update("Need to donate Luxon Faction")
			rndsleep(Random(1000, 10000, 1))
			update("Talking to Luxon Scavenger")
			gotonpc(getnearestagentptrtocoords($xlocation, $ylocation), $ame)
			Sleep(1000)
			Do
				update("Donating Faction")
				donatefaction(1)
				rndsleep(500)
			Until getluxonfaction() < 5000
			rndsleep(5000)
		EndIf
	EndFunc

	Func gokurzick($xlocation, $ylocation, $ame = getagentptr(-2))
		If getkurzickfaction() > 5000 Then
			rndsleep(Random(1000, 10000, 1))
			update("Talking to Kurzick Scavenger")
			moveto(21386, 6547, 200, $ame)
			gotonpc(getnearestagentptrtocoords($xlocation, $ylocation), $ame)
			Sleep(1000)
			Do
				update("Donating Faction")
				donatefaction("k")
				rndsleep(500)
			Until getkurzickfaction() < 5000
			rndsleep(2000)
		EndIf
	EndFunc

	Func grabbounty($ax, $ay, $adialogs = False, $abounties = False, $ame = getagentptr(-2))
		gotonpcnearestcoords($ax, $ay, $ame)
		If $adialogs <> False Then
			Local $ldialogs = StringSplit(String($adialogs), "|")
			For $i = 1 To $ldialogs[0]
				dialog($ldialogs[$i])
				Sleep(125)
			Next
		EndIf
		If $abounties <> False Then
			Local $lbounties = StringSplit(String($abounties), "|")
			For $i = 1 To $lbounties[0]
				dialog($lbounties[$i])
				Sleep(125)
			Next
		EndIf
	EndFunc

	Func getinunderworld($ame = getagentptr(-2))
		Local $lx, $ly
		Local $grenthspawn = 0
		Local $lmyid = getmyid()
		update("Move To Grenth")
		moveto(-4196, 19781, 50, $ame)
		pingsleep(250)
		updateagentposbyptr($ame, $lx, $ly)
		If computedistance($lx, $ly, -4196, 19781) > 200 Then
			Do
				If memoryread($ame + 44, "long") <> $lmyid Then Return False
				If NOT getismoving($ame) Then
					moveto($lx, $ly, 300, $ame)
					pingsleep(500)
					moveto(-4196, 19781, 50, $ame)
				EndIf
				pingsleep(500)
				updateagentposbyptr($ame, $lx, $ly)
			Until computedistance($lx, $ly, -4196, 19781) <= 150
		EndIf
		pingsleep(250)
		Local $grenthptr = getagentptr(83)
		While $grenthptr = 0
			If Mod($grenthspawn, 20) = 0 Then kneel()
			Sleep(500)
			$grenthspawn += 1
			$grenthptr = getagentptr(83)
		WEnd
		gonpc($grenthptr)
		Sleep(125)
		dialog(134)
		update("Loading Underworld")
		Return waitmaploading(72)
	EndFunc

#EndRegion
#Region GoTo Merchants

	Func gotonpcbyplayernumber($aplayernumber, $ame = getagentptr(-2))
		$lagentarray = memoryreadagentptrstruct(1)
		For $i = 1 To $lagentarray[0]
			If memoryread($lagentarray[$i] + 244, "word") = Int($aplayernumber) Then
				gotonpc($lagentarray[$i], $ame)
				Return dialog(127)
			EndIf
		Next
	EndFunc

	Func getmerchantplayernumber($amapid)
		Switch $amapid
			Case 10, 12, 137, 138, 139, 141, 142, 19, 49, 73
				Return 1897
			Case 109, 116, 117, 118, 152, 153, 154, 38
				Return 1904
			Case 11, 136, 140, 16, 57
				Return 1890
			Case 120, 155, 156, 158, 159, 22, 24, 812
				Return 1915
			Case 131, 135, 29, 30, 40
				Return 1870
			Case 132, 134, 21, 25, 32, 36
				Return 1876
			Case 133, 14, 808
				Return 1883
			Case 28, 39, 81
				Return 1866
			Case Else
				Return False
		EndSwitch
	EndFunc

	Func getdyetraderplayernumber($amapid)
		Switch $amapid
			Case 109, 49, 81, 857
				Return 2010
			Case 193
				Return 3617
			Case 194, 242
				Return 3278
			Case 250
				Return 3277
			Case 286
				Return 3402
			Case 381, 477
				Return 5383
			Case 403
				Return 5663
			Case 414
				Return 5664
			Case 640
				Return 6756
			Case 642
				Return 6043
			Case 644
				Return 6382
			Case 77
				Return 3401
			Case 812
				Return 2107
			Case 818
				Return 4719
			Case Else
				Return False
		EndSwitch
	EndFunc

	Func getmaterialtraderplayernumber($amapid)
		Switch $amapid
			Case 109, 49, 81
				Return 2011
			Case 193
				Return 3618
			Case 194, 242, 857
				Return 3279
			Case 250
				Return 3280
			Case 376
				Return 5385
			Case 398
				Return 5665
			Case 414
				Return 5668
			Case 424
				Return 5386
			Case 433
				Return 5666
			Case 438
				Return 5618
			Case 491
				Return 4720
			Case 492
				Return 4721
			Case 638
				Return 6757
			Case 640
				Return 6758
			Case 641
				Return 6059
			Case 642
				Return 6044
			Case 643
				Return 6383
			Case 644
				Return 6384
			Case 652
				Return 6227
			Case 77
				Return 3409
			Case 808
				Return 7446
			Case 818
				Return 4723
			Case Else
				Return False
		EndSwitch
	EndFunc

	Func getrarematerialtraderplayernumber($amapid)
		Switch $amapid
			Case 109
				Return 1997
			Case 193
				Return 3621
			Case 194, 250, 857
				Return 3282
			Case 242
				Return 3281
			Case 376
				Return 5388
			Case 398, 433
				Return 5667
			Case 414
				Return 5668
			Case 424
				Return 5387
			Case 438
				Return 5613
			Case 49
				Return 2038
			Case 491, 818
				Return 4723
			Case 492
				Return 4722
			Case 638
				Return 6760
			Case 640
				Return 6759
			Case 641
				Return 6060
			Case 642
				Return 6045
			Case 643
				Return 6386
			Case 644
				Return 6385
			Case 652
				Return 6228
			Case 77
				Return 3410
			Case 81
				Return 2083
			Case Else
				Return False
		EndSwitch
	EndFunc

	Func getrunetraderplayernumber($amapid)
		Switch $amapid
			Case 109, 814
				Return 1999
			Case 193
				Return 3624
			Case 194, 242, 250
				Return 3285
			Case 248, 857
				Return 1975
			Case 396
				Return 5672
			Case 414
				Return 5671
			Case 438
				Return 5620
			Case 477
				Return 5390
			Case 487
				Return 4726
			Case 49
				Return 2039
			Case 502
				Return 4727
			Case 624
				Return 6764
			Case 640
				Return 6763
			Case 642
				Return 6046
			Case 643, 645
				Return 6389
			Case 644
				Return 6390
			Case 77
				Return 3415
			Case 808
				Return 7450
			Case 81
				Return 2085
			Case 818
				Return 4705
			Case Else
				Return False
		EndSwitch
	EndFunc

#EndRegion
#Region Ptr

	Func getagentptr($aagentid = getmyid())
		Local $loffset[3] = [0, 4 * convertid($aagentid), 0]
		Local $lagentstructaddress = memoryreadptr($magentbase, $loffset, "ptr")
		Return $lagentstructaddress[0]
	EndFunc

	Func getplayerptrbyplayernumber($aplayernumber)
		Local $lagentarray = memoryreadagentptrstruct(1)
		For $i = 1 To $lagentarray[0]
			If memoryread($lagentarray[$i] + 244, "word") = $aplayernumber Then Return $lagentarray[$i]
		Next
	EndFunc

	#Region AgentPtrArray

		Func getagentptrarray($atype = Default, $aallegiance = Default, $adead = Default)
			Local $lcount
			Local $lbuffer = ""
			DllStructSetData($mmakeagentarrayex, 2, $atype)
			memorywrite($magentcopycount, -1, "long")
			enqueue($mmakeagentarrayexptr, 8)
			Local $ldeadlock = TimerInit()
			Do
				Sleep(1)
				$lcount = memoryread($magentcopycount, "long")
			Until $lcount >= 0 OR TimerDiff($ldeadlock) > 5000
			If $lcount < 0 Then $lcount = 0
			For $i = 1 To $lcount
				$lbuffer &= "ptr;"
			Next
			$lbuffer = DllStructCreate($lbuffer)
			DllCall($mkernelhandle, "int", "ReadProcessMemory", "int", $mgwprochandle, "int", $magentcopybase, "ptr", DllStructGetPtr($lbuffer), "int", DllStructGetSize($lbuffer), "int", "")
			Local $lreturnarray[$lcount + 1]
			Local $larrcount = 0
			For $i = 1 To $lcount
				Local $ltemp = DllStructGetData($lbuffer, $i)
				If $atype <> Default AND memoryread($ltemp + 156, "long") <> $atype Then ContinueLoop
				If $aallegiance <> Default AND memoryread($ltemp + 433, "byte") <> $aallegiance Then ContinueLoop
				If $adead <> Default AND memoryread($ltemp + 304, "float") <= 0 Then ContinueLoop
				If $adead <> Default AND BitAND(memoryread($ltemp + 312, "long"), 16) > 0 Then ContinueLoop
				$larrcount += 1
				$lreturnarray[$larrcount] = $ltemp
				$lreturnarray[$i] = DllStructGetData($lbuffer, $i)
			Next
			$lreturnarray[0] = $larrcount
			ReDim $lreturnarray[$larrcount + 1]
			Return $lreturnarray
		EndFunc

		Func getagentptrarrayex($amode = 0, $atype = 219, $aallegiance = 3, $adead = True)
			Local $lcount
			If $amode = 0 Then
				$ltype = 0
			Else
				$ltype = $atype
			EndIf
			If $amode <= 1 Then
				$lallegiance = 0
			Else
				$lallegiance = $aallegiance
			EndIf
			DllStructSetData($mmakeagentarrayex, 2, $ltype)
			DllStructSetData($mmakeagentarrayex, 3, $lallegiance)
			enqueue($mmakeagentarrayexptr, 8)
			If $lcount < 0 OR $lcount > 256 Then $lcount = 0
			$lbuffer = DllStructCreate("ptr[" & $lcount & "]")
			DllCall($mkernelhandle, "int", "ReadProcessMemory", "int", $mgwprochandle, "ptr", $magentcopybase, "struct*", $lbuffer, "ulong_ptr", $lcount * 4, "ulong_ptr", "")
			Local $lreturnarray[$lcount + 1]
			For $i = 1 To $lcount
				$lreturnarray[$i] = DllStructGetData($lbuffer, $i)
			Next
			$lreturnarray[0] = $lcount
			Return $lreturnarray
		EndFunc

		Func getagentptrarray_()
			Local $lcount = getmaxagents()
			Local $retarr[$lcount + 2][2]
			Local $lptrcount = 0
			Local $lbaseptr = memoryread($magentbase)
			For $i = 0 To $lcount
				Local $lagentptr = memoryread($lbaseptr + $i * 4, "ptr")
				If $lagentptr = 0 Then ContinueLoop
				$lptrcount += 1
				$retarr[$lptrcount][0] = $lagentptr
				$retarr[$lptrcount][1] = $i
			Next
			$retarr[0][0] = $lptrcount
			ReDim $retarr[$lptrcount + 1][2]
			Return $retarr
		EndFunc

		Func getagentptrcylcenext($astartid = -1, $amode = 0, $atype = -1, $aallegiance = -1, $adead = False)
			Local $lstart = getagentptr($astartid)
			If $lstart = 0 Then
				Local $retarr[1] = [0]
				Return $retarr
			EndIf
			Local $lnext = $lstart
			Local $lptrcount = 1
			Local $lcount = getmaxagents()
			Local $retarr[$lcount + 2]
			$retarr[1] = $lstart
			If $amode = 0 Then
				For $i = 1 To $lcount
					$lnext = memoryread($lnext + 32, "ptr")
					If $lnext = 0 Then ExitLoop
					If $lnext = $lstart Then ContinueLoop
					$lptrcount += 1
					$retarr[$lptrcount] = $lnext
				Next
			ElseIf $amode = 1 Then
				For $i = 1 To $lcount
					$lnext = memoryread($lnext + 32, "ptr")
					If $lnext = 0 Then ExitLoop
					If $lnext = $lstart Then ContinueLoop
					If memoryread($lnext + 156, "long") <> $atype Then ContinueLoop
					$lptrcount += 1
					$retarr[$lptrcount] = $lnext
				Next
			ElseIf $amode = 2 Then
				For $i = 1 To $lcount
					$lnext = memoryread($lnext + 32, "ptr")
					If $lnext = 0 Then ExitLoop
					If $lnext = $lstart Then ContinueLoop
					If memoryread($lnext + 156, "long") <> $atype Then ContinueLoop
					If memoryread($lnext + 433, "byte") <> $aallegiance Then ContinueLoop
					$lptrcount += 1
					$retarr[$lptrcount] = $lnext
				Next
			Else
				For $i = 1 To $lcount
					$lnext = memoryread($lnext + 32, "ptr")
					If $lnext = 0 Then ExitLoop
					If $lnext = $lstart Then ContinueLoop
					If memoryread($lnext + 156, "long") <> $atype Then ContinueLoop
					If memoryread($lnext + 433, "byte") <> $aallegiance Then ContinueLoop
					If memoryread($lnext + 304, "float") <= 0 Then ContinueLoop
					If BitAND(memoryread($lnext + 312, "long"), 16) > 0 Then ContinueLoop
					$lptrcount += 1
					$retarr[$lptrcount] = $lnext
				Next
			EndIf
			$retarr[0] = $lptrcount
			ReDim $retarr[$lptrcount + 1]
			Return $retarr
		EndFunc

		Func memoryreadagentptrstruct($amode = 0, $atype = 219, $aallegiance = 3, $adead = False)
			Local $lmaxagents = getmaxagents()
			Local $lagentptrstruct = DllStructCreate("PTR[" & $lmaxagents & "]")
			DllCall($mkernelhandle, "BOOL", "ReadProcessMemory", "HANDLE", $mgwprochandle, "PTR", memoryread($magentbase), "STRUCT*", $lagentptrstruct, "ULONG_PTR", $lmaxagents * 4, "ULONG_PTR*", 0)
			Local $ltemp
			Local $lagentarray[$lmaxagents + 1]
			Switch $amode
				Case 0
					For $i = 1 To $lmaxagents
						$ltemp = DllStructGetData($lagentptrstruct, 1, $i)
						If $ltemp = 0 Then ContinueLoop
						$lagentarray[0] += 1
						$lagentarray[$lagentarray[0]] = $ltemp
					Next
				Case 1
					For $i = 1 To $lmaxagents
						$ltemp = DllStructGetData($lagentptrstruct, 1, $i)
						If $ltemp = 0 Then ContinueLoop
						If memoryread($ltemp + 156, "long") <> $atype Then ContinueLoop
						$lagentarray[0] += 1
						$lagentarray[$lagentarray[0]] = $ltemp
					Next
				Case 2
					For $i = 1 To $lmaxagents
						$ltemp = DllStructGetData($lagentptrstruct, 1, $i)
						If $ltemp = 0 Then ContinueLoop
						If memoryread($ltemp + 156, "long") <> $atype Then ContinueLoop
						If memoryread($ltemp + 433, "byte") <> $aallegiance Then ContinueLoop
						$lagentarray[0] += 1
						$lagentarray[$lagentarray[0]] = $ltemp
					Next
				Case 3
					For $i = 1 To $lmaxagents
						$ltemp = DllStructGetData($lagentptrstruct, 1, $i)
						If $ltemp = 0 Then ContinueLoop
						If memoryread($ltemp + 156, "long") <> $atype Then ContinueLoop
						If memoryread($ltemp + 433, "byte") <> $aallegiance Then ContinueLoop
						If memoryread($ltemp + 304, "float") <= 0 Then ContinueLoop
						$lagentarray[0] += 1
						$lagentarray[$lagentarray[0]] = $ltemp
					Next
			EndSwitch
			ReDim $lagentarray[$lagentarray[0] + 1]
			Return $lagentarray
		EndFunc

	#EndRegion AgentPtrArray

	Func getnearestagentptrtoagent($aagent = -1)
		Local $lagentx, $lagenty, $larrayx, $larrayy
		If IsPtr($aagent) <> 0 Then
			$lptr = $aagent
			updateagentposbyptr($aagent, $lagentx, $lagenty)
		ElseIf IsDllStruct($aagent) <> 0 Then
			$lptr = getagentptr(DllStructGetData($aagent, "ID"))
			$lagentx = DllStructGetData($aagent, "X")
			$lagenty = DllStructGetData($aagent, "Y")
		Else
			$lptr = getagentptr($aagent)
			updateagentposbyptr($lptr, $lagentx, $lagenty)
		EndIf
		Local $lnearestagent, $ldistance, $lnearestdistance = 25000000
		Local $lagentarray = memoryreadagentptrstruct()
		For $i = 1 To $lagentarray[0]
			If $lagentarray[$i] == $lptr Then ContinueLoop
			updateagentposbyptr($lagentarray[$i], $larrayx, $larrayy)
			$ldistance = ($lagentx - $larrayx) ^ 2 + ($lagenty - $larrayy) ^ 2
			If $ldistance < $lnearestdistance Then
				$lnearestagent = $lagentarray[$i]
				$lnearestdistance = $ldistance
			EndIf
		Next
		SetExtended(Sqrt($lnearestdistance))
		Return $lnearestagent
	EndFunc

	Func getnearestenemyptrtoagent($aagent = -2)
		Local $lagentx, $lagenty, $larrayx, $larrayy
		If IsPtr($aagent) <> 0 Then
			$lptr = $aagent
			updateagentposbyptr($aagent, $lagentx, $lagenty)
		ElseIf IsDllStruct($aagent) <> 0 Then
			$lptr = getagentptr(DllStructGetData($aagent, "ID"))
			$lagentx = DllStructGetData($aagent, "X")
			$lagenty = DllStructGetData($aagent, "Y")
		Else
			$lptr = getagentptr($aagent)
			updateagentposbyptr($lptr, $lagentx, $lagenty)
		EndIf
		Local $lnearestagent, $ldistance, $lnearestdistance = 25000000
		Local $lagentarray = memoryreadagentptrstruct(3)
		For $i = 1 To $lagentarray[0]
			If $lagentarray[$i] == $lptr Then ContinueLoop
			updateagentposbyptr($lagentarray[$i], $larrayx, $larrayy)
			$ldistance = ($lagentx - $larrayx) ^ 2 + ($lagenty - $larrayy) ^ 2
			If $ldistance < $lnearestdistance Then
				$lnearestagent = $lagentarray[$i]
				$lnearestdistance = $ldistance
			EndIf
		Next
		SetExtended(Sqrt($lnearestdistance))
		Return $lnearestagent
	EndFunc

	Func getfarthestenemyptrtoagent($amaxdistance = 1400, $aagent = -2)
		Local $lagentx, $lagenty, $larrayx, $larrayy
		If IsPtr($aagent) <> 0 Then
			$lptr = $aagent
			updateagentposbyptr($aagent, $lagentx, $lagenty)
		ElseIf IsDllStruct($aagent) <> 0 Then
			$lptr = getagentptr(DllStructGetData($aagent, "ID"))
			$lagentx = DllStructGetData($aagent, "X")
			$lagenty = DllStructGetData($aagent, "Y")
		Else
			$lptr = getagentptr($aagent)
			updateagentposbyptr($lptr, $lagentx, $lagenty)
		EndIf
		Local $lfarthestagent, $ldistance, $lfarthestdistance = 1
		Local $lmaxdistance = $amaxdistance ^ 2
		Local $lagentarray = memoryreadagentptrstruct(3)
		For $i = 1 To $lagentarray[0]
			If $lagentarray[$i] == $lptr Then ContinueLoop
			updateagentposbyptr($lagentarray[$i], $larrayx, $larrayy)
			$ldistance = ($lagentx - $larrayx) ^ 2 + ($lagenty - $larrayy) ^ 2
			If $ldistance > $lfarthestdistance AND $ldistance < $lmaxdistance Then
				$lfarthestagent = $lagentarray[$i]
				$lfarthestdistance = $ldistance
			EndIf
		Next
		SetExtended(Sqrt($lfarthestdistance))
		Return $lfarthestagent
	EndFunc

	Func getnearestagentptrtocoords($ax, $ay)
		Local $lnearestagent, $lnearestdistance = 100000000
		Local $ldistance, $larrayx, $larrayy
		Local $lagentarray = memoryreadagentptrstruct()
		For $i = 1 To $lagentarray[0]
			updateagentposbyptr($lagentarray[$i], $larrayx, $larrayy)
			$ldistance = ($ax - $larrayx) ^ 2 + ($ay - $larrayy) ^ 2
			If $ldistance < $lnearestdistance Then
				$lnearestagent = $lagentarray[$i]
				$lnearestdistance = $ldistance
			EndIf
		Next
		SetExtended(Sqrt($lnearestdistance))
		Return $lnearestagent
	EndFunc

	Func getnearestsignpostptrtoagent($aagent = -2)
		Local $lagentx, $lagenty, $larrayx, $larrayy
		If IsPtr($aagent) <> 0 Then
			$lptr = $aagent
			updateagentposbyptr($aagent, $lagentx, $lagenty)
		ElseIf IsDllStruct($aagent) <> 0 Then
			$lptr = getagentptr(DllStructGetData($aagent, "ID"))
			$lagentx = DllStructGetData($aagent, "X")
			$lagenty = DllStructGetData($aagent, "Y")
		Else
			$lptr = getagentptr($aagent)
			updateagentposbyptr($lptr, $lagentx, $lagenty)
		EndIf
		Local $lnearestagent, $ldistance, $lnearestdistance = 100000000
		Local $lagentarray = memoryreadagentptrstruct(1, 512)
		For $i = 1 To $lagentarray[0]
			If $lagentarray[$i] == $lptr Then ContinueLoop
			updateagentposbyptr($lagentarray[$i], $larrayx, $larrayy)
			$ldistance = ($lagentx - $larrayx) ^ 2 + ($lagenty - $larrayy) ^ 2
			If $ldistance < $lnearestdistance Then
				$lnearestagent = $lagentarray[$i]
				$lnearestdistance = $ldistance
			EndIf
		Next
		SetExtended(Sqrt($lnearestdistance))
		Return $lnearestagent
	EndFunc

	Func getnearestsignpostptrtocoords($ax, $ay)
		Local $lnearestagent = 0
		Local $lnearestdistance = 100000000
		Local $ldistance, $larrayx, $larrayy
		Local $lagentarray = memoryreadagentptrstruct(1, 512)
		For $i = 1 To $lagentarray[0]
			updateagentposbyptr($lagentarray[$i], $larrayx, $larrayy)
			$ldistance = ($ax - $larrayx) ^ 2 + ($ay - $larrayy) ^ 2
			If $ldistance < $lnearestdistance Then
				$lnearestagent = $lagentarray[$i]
				$lnearestdistance = $ldistance
			EndIf
		Next
		Return SetExtended(Sqrt($lnearestdistance), $lnearestagent)
	EndFunc

	Func getnearestnpcptrtoagent($aagent = -2)
		Local $lagentx, $lagenty, $larrayx, $larrayy
		If IsPtr($aagent) <> 0 Then
			$lptr = $aagent
			updateagentposbyptr($aagent, $lagentx, $lagenty)
		ElseIf IsDllStruct($aagent) <> 0 Then
			$lptr = getagentptr(DllStructGetData($aagent, "ID"))
			$lagentx = DllStructGetData($aagent, "X")
			$lagenty = DllStructGetData($aagent, "Y")
		Else
			$lptr = getagentptr($aagent)
			updateagentposbyptr($lptr, $lagentx, $lagenty)
		EndIf
		Local $lnearestagent, $ldistance, $lnearestdistance = 100000000
		Local $lagentarray = memoryreadagentptrstruct(3, 219, 6)
		For $i = 1 To $lagentarray[0]
			If $lagentarray[$i] == $lptr Then ContinueLoop
			updateagentposbyptr($lagentarray[$i], $larrayx, $larrayy)
			$ldistance = ($lagentx - $larrayx) ^ 2 + ($lagenty - $larrayy) ^ 2
			If $ldistance < $lnearestdistance Then
				$lnearestagent = $lagentarray[$i]
				$lnearestdistance = $ldistance
			EndIf
		Next
		SetExtended(Sqrt($lnearestdistance))
		Return $lnearestagent
	EndFunc

	Func getnearestnpcptrtocoords($ax, $ay)
		Local $lnearestagent, $lnearestdistance = 100000000
		Local $ldistance, $larrayx, $larrayy
		Local $lagentarray = memoryreadagentptrstruct(3, 219, 6)
		For $i = 1 To $lagentarray[0]
			updateagentposbyptr($lagentarray[$i], $larrayx, $larrayy)
			$ldistance = ($ax - $larrayx) ^ 2 + ($ay - $larrayy) ^ 2
			If $ldistance < $lnearestdistance Then
				$lnearestagent = $lagentarray[$i]
				$lnearestdistance = $ldistance
			EndIf
		Next
		SetExtended(Sqrt($lnearestdistance))
		Return $lnearestagent
	EndFunc

	Func getnearestenemyptrtocoords($ax, $ay)
		Local $lnearestagent, $lnearestdistance = 100000000
		Local $ldistance, $larrayx, $larrayy
		Local $lagentarray = memoryreadagentptrstruct(3, 219, 3)
		For $i = 1 To $lagentarray[0]
			updateagentposbyptr($lagentarray[$i], $larrayx, $larrayy)
			$ldistance = ($ax - $larrayx) ^ 2 + ($ay - $larrayy) ^ 2
			If $ldistance < $lnearestdistance Then
				$lnearestagent = $lagentarray[$i]
				$lnearestdistance = $ldistance
			EndIf
		Next
		SetExtended(Sqrt($lnearestdistance))
		Return $lnearestagent
	EndFunc

	Func getenemyptrnearcoords($ax, $ay, $arange = 1000)
		Local $ldistance, $larrayx, $larrayy
		Local $lagentarray = memoryreadagentptrstruct(3, 219, 3)
		For $i = 1 To $lagentarray[0]
			updateagentposbyptr($lagentarray[$i], $larrayx, $larrayy)
			$ldistance = ($ax - $larrayx) ^ 2 + ($ay - $larrayy) ^ 2
			If $ldistance < $arange Then
				Return SetExtended($ldistance, $lagentarray[$i])
			EndIf
		Next
	EndFunc

	Func getnearestitemptrtoagent($aagent = -2, $acanpickup = True)
		Local $lagentx, $lagenty, $larrayx, $larrayy
		If IsPtr($aagent) <> 0 Then
			$lptr = $aagent
			updateagentposbyptr($aagent, $lagentx, $lagenty)
		ElseIf IsDllStruct($aagent) <> 0 Then
			$lptr = getagentptr(DllStructGetData($aagent, "ID"))
			$lagentx = DllStructGetData($aagent, "X")
			$lagenty = DllStructGetData($aagent, "Y")
		Else
			$lptr = getagentptr($aagent)
			updateagentposbyptr($lptr, $lagentx, $lagenty)
		EndIf
		Local $lnearestagent, $ldistance, $lnearestdistance = 100000000
		Local $lagentarray = memoryreadagentptrstruct(1, 1024)
		For $i = 1 To $lagentarray[0]
			If $acanpickup AND NOT getcanpickup($lagentarray[$i]) Then ContinueLoop
			If $lagentarray[$i] == $lptr Then ContinueLoop
			updateagentposbyptr($lagentarray[$i], $larrayx, $larrayy)
			$ldistance = ($lagentx - $larrayx) ^ 2 + ($lagenty - $larrayy) ^ 2
			If $ldistance < $lnearestdistance Then
				$lnearestagent = $lagentarray[$i]
				$lnearestdistance = $ldistance
			EndIf
		Next
		SetExtended(Sqrt($lnearestdistance))
		Return $lnearestagent
	EndFunc

	Func getnearestitemptrtocoords($ax, $ay)
		Local $lnearestagent, $lnearestdistance = 100000000
		Local $ldistance, $larrayx, $larrayy
		Local $lagentarray = memoryreadagentptrstruct(1, 1024)
		For $i = 1 To $lagentarray[0]
			updateagentposbyptr($lagentarray[$i], $larrayx, $larrayy)
			$ldistance = ($ax - $larrayx) ^ 2 + ($ay - $larrayy) ^ 2
			If $ldistance < $lnearestdistance Then
				$lnearestagent = $lagentarray[$i]
				$lnearestdistance = $ldistance
			EndIf
		Next
		SetExtended(Sqrt($lnearestdistance))
		Return $lnearestagent
	EndFunc

#EndRegion Ptr
#Region Interaction

	Func attack($aagent, $acalltarget = False)
		If IsPtr($aagent) <> 0 Then
			Local $lagentid = memoryread($aagent + 44, "long")
		ElseIf IsDllStruct($aagent) <> 0 Then
			Local $lagentid = DllStructGetData($aagent, "ID")
		Else
			Local $lagentid = convertid($aagent)
		EndIf
		Return sendpacket(12, 32, $lagentid, $acalltarget)
	EndFunc

	Func usesignpost($ax, $ay, $ame = getagentptr(-2))
		Local $lsignpost = getnearestsignpostptrtocoords($ax, $ay)
		Return gotosignpost($lsignpost, $ame)
	EndFunc

	Func turnleft($aturn)
		If $aturn Then
			Return performaction(162, 24)
		Else
			Return performaction(162, 26)
		EndIf
	EndFunc

	Func turnright($aturn)
		If $aturn Then
			Return performaction(163, 24)
		Else
			Return performaction(163, 26)
		EndIf
	EndFunc

	Func movebackward($amove)
		If $amove Then
			Return performaction(172, 24)
		Else
			Return performaction(172, 26)
		EndIf
	EndFunc

	Func moveforward($amove)
		If $amove Then
			Return performaction(173, 24)
		Else
			Return performaction(173, 26)
		EndIf
	EndFunc

	Func strafeleft($astrafe)
		If $astrafe Then
			Return performaction(145, 24)
		Else
			Return performaction(145, 26)
		EndIf
	EndFunc

	Func straferight($astrafe)
		If $astrafe Then
			Return performaction(146, 24)
		Else
			Return performaction(146, 26)
		EndIf
	EndFunc

	Func toggleautorun()
		Return performaction(183, 24)
	EndFunc

	Func reversedirection()
		Return performaction(177, 24)
	EndFunc

	Func cancelaction()
		Return sendpacket(4, 34)
	EndFunc

	Func actioninteract()
		Return performaction(128, 24)
	EndFunc

	Func actionfollow()
		Return performaction(204, 24)
	EndFunc

	Func dropbundle()
		Return performaction(205, 24)
	EndFunc

	Func suppressaction($asuppress)
		If $asuppress Then
			Return performaction(208, 24)
		Else
			Return performaction(208, 26)
		EndIf
	EndFunc

	Func openchest()
		Return sendpacket(8, 77, 2)
	EndFunc

	Func changeweaponset($aset)
		Return performaction(128 + $aset, 24)
	EndFunc

	Func dialog($adialogid)
		Return sendpacket(8, 53, $adialogid)
	EndFunc

	Func getlastdialogid()
		Return memoryread($mlastdialogid)
	EndFunc

	Func getlastdialogidhex()
		$dialoghex = memoryread($mlastdialogid)
		Return "0x" & StringReplace(Hex($dialoghex, 8), StringRegExpReplace(Hex($dialoghex, 8), "[^0].*", ""), "")
	EndFunc

#EndRegion
#Region Targeting

	Func getcurrenttargetptr()
		Local $loffset[2] = [0, 4 * memoryread($mcurrenttarget)]
		Local $lagentstructaddress = memoryreadptr($magentbase, $loffset, "ptr")
		Return $lagentstructaddress[1]
	EndFunc

	Func getcurrenttargetid()
		Return memoryread($mcurrenttarget)
	EndFunc

	Func changetarget($aagent)
		If IsPtr($aagent) <> 0 Then
			Local $lagentid = memoryread($aagent + 44, "long")
		ElseIf IsDllStruct($aagent) <> 0 Then
			Local $lagentid = DllStructGetData($aagent, "ID")
		Else
			Local $lagentid = convertid($aagent)
		EndIf
		DllStructSetData($mchangetarget, 2, $lagentid)
		enqueue($mchangetargetptr, 8)
	EndFunc

	Func calltarget($atarget)
		If IsPtr($atarget) <> 0 Then
			Local $ltargetid = memoryread($atarget + 44, "long")
		ElseIf IsDllStruct($atarget) <> 0 Then
			Local $ltargetid = DllStructGetData($atarget, "ID")
		Else
			Local $ltargetid = convertid($atarget)
		EndIf
		Return sendpacket(12, 28, 10, $ltargetid)
	EndFunc

	Func cleartarget()
		Return performaction(227, 24)
	EndFunc

	Func targetnearestenemy()
		Return performaction(147, 24)
	EndFunc

	Func targetnextenemy()
		Return performaction(149, 24)
	EndFunc

	Func targetpartymember($anumber)
		If $anumber > 0 AND $anumber < 13 Then Return performaction(149 + $anumber, 24)
	EndFunc

	Func targetpreviousenemy()
		Return performaction(158, 24)
	EndFunc

	Func targetcalledtarget()
		Return performaction(159, 24)
	EndFunc

	Func targetself()
		Return performaction(160, 24)
	EndFunc

	Func targetnearestally()
		Return performaction(188, 24)
	EndFunc

	Func targetnearestitem()
		Return performaction(195, 24)
	EndFunc

	Func targetnextitem()
		Return performaction(196, 24)
	EndFunc

	Func targetpreviousitem()
		Return performaction(197, 24)
	EndFunc

	Func targetnextpartymember()
		Return performaction(202, 24)
	EndFunc

	Func targetpreviouspartymember()
		Return performaction(203, 24)
	EndFunc

#EndRegion Targeting
#Region Information

	Func convertid($aid)
		If $aid = -2 Then
			Return getmyid()
		ElseIf $aid = -1 Then
			Return getcurrenttargetid()
		Else
			Return $aid
		EndIf
	EndFunc

	Func getagentid($aagent)
		If IsPtr($aagent) <> 0 Then
			Local $lagentid = memoryread($aagent + 44, "long")
		ElseIf IsDllStruct($aagent) <> 0 Then
			Local $lagentid = DllStructGetData($aagent, "ID")
		Else
			Local $lagentid = convertid($aagent)
		EndIf
		If $lagentid = 0 Then Return ""
		Return $lagentid
	EndFunc

	Func getmyid()
		Return memoryread($mmyid)
	EndFunc

	Func updateagentposbyptr($aagentptr, ByRef $ax, ByRef $ay)
		Local $lstruct = memoryreadstruct($aagentptr + 116, "float X;float Y")
		$ax = DllStructGetData($lstruct, "X")
		$ay = DllStructGetData($lstruct, "Y")
	EndFunc

	Func updateagentmovebyptr($aagentptr, ByRef $amovex, ByRef $amovey)
		Local $lstruct = memoryreadstruct($aagentptr + 160, "float MoveX;float MoveY")
		$amovex = DllStructGetData($lstruct, "MoveX")
		$amovey = DllStructGetData($lstruct, "MoveY")
	EndFunc

	Func getmaxagents()
		Return memoryread($mmaxagents)
	EndFunc

	Func getagentexists($aagentid)
		If IsPtr($aagentid) <> 0 Then
			Return $aagentid <> 0 AND memoryread($aagentid + 44, "long") <= getmaxagents()
		Else
			Return (getagentptr($aagentid) > 0 AND $aagentid <= getmaxagents())
		EndIf
	EndFunc

	Func gettarget($aagent)
		If IsPtr($aagent) <> 0 Then
			Local $lagentid = memoryread($aagent + 44, "long")
		ElseIf IsDllStruct($aagent) <> 0 Then
			Local $lagentid = DllStructGetData($aagent, "ID")
		Else
			Local $lagentid = convertid($aagent)
		EndIf
		Return memoryread(getvalue("TargetLogBase") + 4 * $lagentid)
	EndFunc

	Func getagentidbyname($aname)
		If $musestringlog = False Then Return
		Local $lname, $laddress
		For $i = 1 To getmaxagents()
			$laddress = $mstringlogbase + 256 * $i
			$lname = memoryread($laddress, "wchar [128]")
			If $lname = "" Then ContinueLoop
			$lname = StringRegExpReplace($lname, "[<]{1}([^>]+)[>]{1}", "")
			If StringInStr($lname, $aname) <> 0 Then Return $i
		Next
		displayall(True)
		Sleep(100)
		displayall(False)
		displayall(True)
		Sleep(100)
		displayall(False)
		For $i = 1 To getmaxagents()
			$laddress = $mstringlogbase + 256 * $i
			$lname = memoryread($laddress, "wchar [128]")
			If $lname = "" Then ContinueLoop
			$lname = StringRegExpReplace($lname, "[<]{1}([^>]+)[>]{1}", "")
			If StringInStr($lname, $aname) <> 0 Then Return $i
		Next
	EndFunc

	Func getnumberoffoesinrangeofagent($aagent = getagentptr(-2), $amaxdistance = 4000, $modelid = 0)
		If IsPtr($aagent) <> 0 Then
			Local $lagentptr = $aagent
		ElseIf IsDllStruct($aagent) <> 0 Then
			Local $lagentptr = getagentptr(DllStructGetData($aagent, "ID"))
		Else
			Local $lagentptr = getagentptr($aagent)
		EndIf
		Local $ldistance, $lcount = 0
		Local $ltargettypearray = memoryreadagentptrstruct(3)
		For $i = 1 To $ltargettypearray[0]
			If $modelid <> 0 AND memoryread($ltargettypearray[$i] + 244, "word") <> $modelid Then ContinueLoop
			$ldistance = getdistance($ltargettypearray[$i], $lagentptr)
			If $ldistance < $amaxdistance Then
				$lcount += 1
			EndIf
		Next
		Return $lcount
	EndFunc

	Func getnumberofalliesinrangeofagent($aagent = getagentptr(-2), $amaxdistance = 4000, $modelid = 0)
		If IsPtr($aagent) <> 0 Then
			Local $lagentptr = $aagent
		ElseIf IsDllStruct($aagent) <> 0 Then
			Local $lagentptr = getagentptr(DllStructGetData($aagent, "ID"))
		Else
			Local $lagentptr = getagentptr($aagent)
		EndIf
		Local $ldistance, $lcount = 0
		Local $ltargettypearray = memoryreadagentptrstruct(2, 219, 1)
		For $i = 1 To $ltargettypearray[0]
			If $modelid <> 0 AND memoryread($ltargettypearray[$i] + 244, "word") <> $modelid Then ContinueLoop
			$ldistance = getdistance($ltargettypearray[$i], $lagentptr)
			If $ldistance < $amaxdistance Then
				$lcount += 1
			EndIf
		Next
		Return $lcount
	EndFunc

	Func getvip($amaxdistance = 1350)
		Local $ldistance, $lvipptr, $lcount = 0
		Local $ltargettypearray = memoryreadagentptrstruct(3, 219, 1)
		Local $ltargetarray = memoryreadagentptrstruct(3)
		For $i = 1 To $ltargettypearray[0]
			Local $lenemies = 0
			For $j = 1 To $ltargetarray[0]
				If $ltargetarray[$j] = 0 Then ContinueLoop
				$ldistance = getdistance($ltargetarray[$j], $ltargettypearray[$i])
				If $ldistance < $amaxdistance Then
					$lenemies += 1
				EndIf
			Next
			If $lenemies > $lcount Then
				$lvipptr = $ltargettypearray[$i]
				$lcount = $lenemies
			EndIf
		Next
		Return $lvipptr
	EndFunc

	Func getvip_(ByRef $aagentarray, $amaxdistance = 1350)
		If $aagentarray[0] = 0 Then Return
		Local $lvipptr, $lcount = 0
		Local $lenemyarray[$aagentarray[0] + 1][3]
		$lenemyarray[0][0] = 0
		Local $lallyarray[$aagentarray[0] + 1][3]
		$lallyarray[0][0] = 0
		For $i = 1 To $aagentarray[0]
			$lallegiance = memoryread($aagentarray[$i] + 433, "byte")
			Switch $lallegiance
				Case 1, 6
					$lallyarray[0][0] = $lallyarray[0][0] + 1
					$lallyarray[$lallyarray[0][0]][0] = $aagentarray[$i]
					$lallyarray[$lallyarray[0][0]][1] = memoryread($aagentarray[$i] + 116, "float")
					$lallyarray[$lallyarray[0][0]][2] = memoryread($aagentarray[$i] + 120, "float")
				Case 3
					$lenemyarray[0][0] = $lenemyarray[0][0] + 1
					$lenemyarray[$lenemyarray[0][0]][0] = $aagentarray[$i]
					$lenemyarray[$lenemyarray[0][0]][1] = memoryread($aagentarray[$i] + 116, "float")
					$lenemyarray[$lenemyarray[0][0]][2] = memoryread($aagentarray[$i] + 120, "float")
			EndSwitch
		Next
		For $i = 1 To $lallyarray[0][0] - 1
			Local $lenemies = 0
			Local $lmin = $lallyarray[$i][1] - $amaxdistance
			Local $lmax = $lallyarray[$i][1] + $amaxdistance
			For $j = 1 To $lenemyarray[0][0] - 1
				If $lenemyarray[$j][1] <= $lmax AND $lenemyarray[$j][1] > $lmin Then
					If computedistance($lallyarray[$i][1], $lallyarray[$i][2], $lenemyarray[$j][1], $lenemyarray[$j][2]) <= $amaxdistance Then $lenemies += 1
				EndIf
			Next
			If $lenemies > $lcount Then
				$lvipptr = $lallyarray[$i][0]
				$lcount = $lenemies
			EndIf
		Next
		Return $lvipptr
	EndFunc

	Func getnumberofplayersinoutpost()
		Local $lcount = 0
		$lagentarray = memoryreadagentptrstruct(2, 219, 1)
		For $i = 0 To $lagentarray[0]
			If memoryread($lagentarray[$i] + 384, "long") <> 0 Then $lcount += 1
		Next
		Return $lcount
	EndFunc

	#Region Type

		Func getisliving($aagent)
			If IsPtr($aagent) <> 0 Then
				Return memoryread($aagent + 156, "long") = 219
			ElseIf IsDllStruct($aagent) <> 0 Then
				Return DllStructGetData($aagent, "Type") = 219
			Else
				Return memoryread(getagentptr($aagent) + 156, "long") = 219
			EndIf
		EndFunc

		Func getisstatic($aagent)
			If IsPtr($aagent) <> 0 Then
				Return memoryread($aagent + 156, "long") = 512
			ElseIf IsDllStruct($aagent) <> 0 Then
				Return DllStructGetData($aagent, "Type") = 512
			Else
				Return memoryread(getagentptr($aagent) + 156, "long") = 512
			EndIf
		EndFunc

		Func getismovable($aagent)
			If IsPtr($aagent) <> 0 Then
				Return memoryread($aagent + 156, "long") = 1024
			ElseIf IsDllStruct($aagent) <> 0 Then
				Return DllStructGetData($aagent, "Type") = 1024
			Else
				Return memoryread(getagentptr($aagent) + 156, "long") = 1024
			EndIf
		EndFunc

		Func issummonedcreature($aagentid)
			If IsPtr($aagentid) <> 0 Then
				Local $lagentmid = memoryread($aagentid + 244, "word")
			Else
				Local $lagentmid = memoryread(getagentptr($aagentid) + 244, "word")
			EndIf
			Switch $lagentmid
				Case 1377
					Return True
				Case 2220 To 2222
					Return True
				Case 2864 To 2872
					Return True
				Case 2875 To 2878
					Return True
				Case 3956 To 3957
					Return True
				Case 4199 To 4200
					Return True
				Case 4203 To 4222
					Return True
				Case 4224 To 4229
					Return True
				Case 5703 To 5713
					Return True
				Case 5842 To 5844
					Return True
				Case Else
					Return False
			EndSwitch
		EndFunc

		Func isminion($aagentid)
			If IsPtr($aagentid) <> 0 Then
				Local $lagentmid = memoryread($aagentid + 244, "word")
			Else
				Local $lagentmid = memoryread(getagentptr($aagentid) + 244, "word")
			EndIf
			Switch $lagentmid
				Case 2220, 2221, 2222
					Return True
				Case 4199, 4200
					Return True
				Case 5703, 5704
					Return True
				Case Else
					Return False
			EndSwitch
		EndFunc

	#EndRegion
	#Region hp, energy, coordinates

		Func xlocation($aagent = getagentptr(-2))
			If IsPtr($aagent) <> 0 Then
				Return memoryread($aagent + 116, "float")
			ElseIf IsDllStruct($aagent) <> 0 Then
				Return DllStructGetData($aagent, "X")
			Else
				Return memoryread(getagentptr($aagent) + 116, "float")
			EndIf
		EndFunc

		Func ylocation($aagent = getagentptr(-2))
			If IsPtr($aagent) <> 0 Then
				Return memoryread($aagent + 120, "float")
			ElseIf IsDllStruct($aagent) <> 0 Then
				Return DllStructGetData($aagent, "Y")
			Else
				Return memoryread(getagentptr($aagent) + 120, "float")
			EndIf
		EndFunc

		Func xandylocation($aagent = getagentptr(-2))
			Local $location[2]
			If IsPtr($aagent) <> 0 Then
				updateagentposbyptr($aagent, $location[0], $location[1])
			ElseIf IsDllStruct($aagent) <> 0 Then
				$location[0] = DllStructGetData($aagent, "X")
				$location[1] = DllStructGetData($aagent, "Y")
			Else
				updateagentposbyptr(getagentptr($aagent), $location[0], $location[1])
			EndIf
			Return $location
		EndFunc

		Func getenergy($aagent = getagentptr(-2))
			If IsPtr($aagent) <> 0 Then
				Local $lstruct = memoryreadstruct($aagent + 284, "float EnergyPercent;long MaxEnergy")
				Return DllStructGetData($lstruct, "EnergyPercent") * DllStructGetData($lstruct, "MaxEnergy")
			ElseIf IsDllStruct($aagent) <> 0 Then
				Return DllStructGetData($aagent, "EnergyPercent") * DllStructGetData($aagent, "MaxEnergy")
			Else
				Local $lptr = getagentptr($aagent)
				Local $lstruct = memoryreadstruct($lptr + 284, "float EnergyPercent;long MaxEnergy")
				Return DllStructGetData($lstruct, "EnergyPercent") * DllStructGetData($lstruct, "MaxEnergy")
			EndIf
		EndFunc

		Func gethealth($aagent = getagentptr(-2))
			If IsPtr($aagent) <> 0 Then
				Return memoryread($aagent + 304, "float") * memoryread($aagent + 308, "long")
			ElseIf IsDllStruct($aagent) <> 0 Then
				Return DllStructGetData($aagent, "HP") * DllStructGetData($aagent, "MaxHP")
			Else
				Local $lptr = getagentptr($aagent)
				Return memoryread($lptr + 304, "float") * memoryread($lptr + 308, "long")
			EndIf
		EndFunc

		Func getmoving($aagentid)
			Local $lptr = memoryread($magentmovement + 4 * convertid($aagentid))
			Return memoryread($lptr + 60, "long")
		EndFunc

		Func getisrubberbanding($aagentid, $atime, $aptr = getagentptr(-2))
			Local $lptr = memoryread($magentmovement + 4 * convertid($aagentid))
			$ltimer = TimerInit()
			Local $lmovex, $lmovey
			Do
				updateagentmovebyptr($aptr, $lmovex, $lmovey)
				If $lmovex = 0 AND $lmovey = 0 Then Return False
				If memoryread($lptr + 60, "long") <> 0 Then Return False
				ConsoleWrite("Rubberbanding: " & memoryread($lptr + 60, "long") & @CRLF)
				Sleep(50)
			Until TimerDiff($ltimer) > $atime
			Return True
		EndFunc

		Func getismoving($aagent = getagentptr(-2), $atimer = 0)
			If IsPtr($aagent) <> 0 Then
				Local $lptr = $aagent
			ElseIf IsDllStruct($aagent) <> 0 Then
				If DllStructGetData($aagent, "MoveX") <> 0 OR DllStructGetData($aagent, "MoveY") <> 0 Then Return True
			Else
				Local $lptr = getagentptr($aagent)
			EndIf
			Local $lmovex, $lmovey
			updateagentmovebyptr($lptr, $lmovex, $lmovey)
			If $lmovex <> 0 OR $lmovey <> 0 Then Return True
			If $atimer <> 0 Then
				Sleep($atimer)
				updateagentmovebyptr($lptr, $lmovex, $lmovey)
				If $lmovex <> 0 OR $lmovey <> 0 Then Return True
			EndIf
			Return False
		EndFunc

	#EndRegion
	#Region State

		Func getisknocked($aagent = getagentptr(-2))
			If IsPtr($aagent) <> 0 Then
				Return memoryread($aagent + 340, "long") = 1104
			ElseIf IsDllStruct($aagent) <> 0 Then
				Return DllStructGetData($aagent, "ModelState") = 1104
			Else
				Return memoryread(getagentptr($aagent) + 340, "long") = 1104
			EndIf
			Return False
		EndFunc

		Func getisattacking($aagent = getagentptr(-2))
			Local $lmodelstate
			If IsPtr($aagent) <> 0 Then
				$lmodelstate = memoryread($aagent + 340, "long")
			ElseIf IsDllStruct($aagent) <> 0 Then
				$lmodelstate = DllStructGetData($aagent, "ModelState")
			Else
				$lmodelstate = memoryread(getagentptr($aagent) + 340, "long")
			EndIf
			Switch $lmodelstate
				Case 96
					Return True
				Case 1088
					Return True
				Case 1120
					Return True
				Case Else
					Return False
			EndSwitch
		EndFunc

		Func getiscasting($aagent = getagentptr(-2))
			If IsPtr($aagent) <> 0 Then
				Return memoryread($aagent + 436, "word") <> 0
			ElseIf IsDllStruct($aagent) <> 0 Then
				Return DllStructGetData($aagent, "Skill") <> 0
			Else
				Return memoryread(getagentptr($aagent) + 436, "word") <> 0
			EndIf
		EndFunc

	#EndRegion
	#Region Effects

		Func getisbleeding($aagent)
			If IsPtr($aagent) <> 0 Then
				Return BitAND(memoryread($aagent + 312, "long"), 1) > 0
			ElseIf IsDllStruct($aagent) <> 0 Then
				Return BitAND(DllStructGetData($aagent, "Effects"), 1) > 0
			Else
				Return BitAND(memoryread(getagentptr($aagent) + 312, "long"), 1) > 0
			EndIf
		EndFunc

		Func gethascondition($aagent)
			If IsPtr($aagent) <> 0 Then
				Return BitAND(memoryread($aagent + 312, "long"), 2) > 0
			ElseIf IsDllStruct($aagent) <> 0 Then
				Return BitAND(DllStructGetData($aagent, "Effects"), 2) > 0
			Else
				Return BitAND(memoryread(getagentptr($aagent) + 312, "long"), 2) > 0
			EndIf
		EndFunc

		Func getisdead($aagent = getagentptr(-2))
			If IsPtr($aagent) <> 0 Then
				Return BitAND(memoryread($aagent + 312, "long"), 16) > 0
			ElseIf IsDllStruct($aagent) <> 0 Then
				Return BitAND(DllStructGetData($aagent, "Effects"), 16) > 0
			Else
				Return BitAND(memoryread(getagentptr($aagent) + 312, "long"), 16) > 0
			EndIf
		EndFunc

		Func gethasdeepwound($aagent)
			If IsPtr($aagent) <> 0 Then
				Return BitAND(memoryread($aagent + 312, "long"), 32) > 0
			ElseIf IsDllStruct($aagent) <> 0 Then
				Return BitAND(DllStructGetData($aagent, "Effects"), 32) > 0
			Else
				Return BitAND(memoryread(getagentptr($aagent) + 312, "long"), 32) > 0
			EndIf
		EndFunc

		Func getispoisoned($aagent)
			If IsPtr($aagent) <> 0 Then
				Return BitAND(memoryread($aagent + 312, "long"), 64) > 0
			ElseIf IsDllStruct($aagent) <> 0 Then
				Return BitAND(DllStructGetData($aagent, "Effects"), 64) > 0
			Else
				Return BitAND(memoryread(getagentptr($aagent) + 312, "long"), 64) > 0
			EndIf
		EndFunc

		Func getisenchanted($aagent)
			If IsPtr($aagent) <> 0 Then
				Return BitAND(memoryread($aagent + 312, "long"), 128) > 0
			ElseIf IsDllStruct($aagent) <> 0 Then
				Return BitAND(DllStructGetData($aagent, "Effects"), 128) > 0
			Else
				Return BitAND(memoryread(getagentptr($aagent) + 312, "long"), 128) > 0
			EndIf
		EndFunc

		Func gethasdegenhex($aagent)
			If IsPtr($aagent) <> 0 Then
				Return BitAND(memoryread($aagent + 312, "long"), 1024) > 0
			ElseIf IsDllStruct($aagent) <> 0 Then
				Return BitAND(DllStructGetData($aagent, "Effects"), 1024) > 0
			Else
				Return BitAND(memoryread(getagentptr($aagent) + 312, "long"), 1024) > 0
			EndIf
		EndFunc

		Func gethashex($aagent)
			If IsPtr($aagent) <> 0 Then
				Return BitAND(memoryread($aagent + 312, "long"), 2048) > 0
			ElseIf IsDllStruct($aagent) <> 0 Then
				Return BitAND(DllStructGetData($aagent, "Effects"), 2048) > 0
			Else
				Return BitAND(memoryread(getagentptr($aagent) + 312, "long"), 2048) > 0
			EndIf
		EndFunc

		Func gethasweaponspell($aagent)
			If IsPtr($aagent) <> 0 Then
				Return BitAND(memoryread($aagent + 312, "long"), 32768) > 0
			ElseIf IsDllStruct($aagent) <> 0 Then
				Return BitAND(DllStructGetData($aagent, "Effects"), 32768) > 0
			Else
				Return BitAND(memoryread(getagentptr($aagent) + 312, "long"), 32768) > 0
			EndIf
		EndFunc

	#EndRegion
	#Region TypeMap

		Func getisboss($aagent)
			If IsPtr($aagent) <> 0 Then
				Return BitAND(memoryread($aagent + 344, "long"), 1024) > 0
			ElseIf IsDllStruct($aagent) <> 0 Then
				Return BitAND(DllStructGetData($aagent, "TypeMap"), 1024) > 0
			Else
				Return BitAND(memoryread(getagentptr($aagent) + 344, "long"), 1024) > 0
			EndIf
		EndFunc

	#EndRegion
	#Region X and Y Calcs

		Func getdistancetoe($aagent1 = getcurrenttargetptr(), $ame = getagentptr(-2))
			Local $lagent1x, $lagent1y, $lagent2x, $lagent2y
			If IsPtr($aagent1) <> 0 Then
				updateagentposbyptr($aagent1, $lagent1x, $lagent1y)
			ElseIf IsDllStruct($aagent1) <> 0 Then
				$lagent1x = DllStructGetData($aagent1, "X")
				$lagent1y = DllStructGetData($aagent1, "Y")
			Else
				updateagentposbyptr(getagentptr($aagent1), $lagent1x, $lagent1y)
			EndIf
			updateagentposbyptr($ame, $lagent2x, $lagent2y)
			Return Sqrt(($lagent1x - $lagent2x) ^ 2 + ($lagent1y - $lagent2y) ^ 2)
		EndFunc

		Func getdistance($aagent1 = getcurrenttargetptr(), $aagent2 = getagentptr(-2))
			Local $lagent1x, $lagent1y, $lagent2x, $lagent2y
			If IsPtr($aagent1) <> 0 Then
				updateagentposbyptr($aagent1, $lagent1x, $lagent1y)
			ElseIf IsDllStruct($aagent1) <> 0 Then
				$lagent1x = DllStructGetData($aagent1, "X")
				$lagent1y = DllStructGetData($aagent1, "Y")
			Else
				Local $lagentid = $aagent1
				updateagentposbyptr(getagentptr($aagent1), $lagent1x, $lagent1y)
			EndIf
			If IsPtr($aagent2) <> 0 Then
				updateagentposbyptr($aagent2, $lagent2x, $lagent2y)
			ElseIf IsDllStruct($aagent2) <> 0 Then
				$lagent2x = DllStructGetData($aagent2, "X")
				$lagent2y = DllStructGetData($aagent2, "Y")
			Else
				updateagentposbyptr(getagentptr($aagent2), $lagent2x, $lagent2y)
			EndIf
			Return Sqrt(($lagent1x - $lagent2x) ^ 2 + ($lagent1y - $lagent2y) ^ 2)
		EndFunc

		Func getispointinpolygon($aareacoords, $aposx = 0, $aposy = 0)
			Local $lposition, $lposx, $lposy
			Local $ledges = UBound($aareacoords)
			Local $loddnodes = False
			If $ledges < 3 Then Return False
			If $aposx = 0 Then
				Local $lagent = getagentptr(-2)
				updateagentposbyptr($lagent, $lposx, $lposy)
			Else
				$lposx = $aposx
				$lposy = $aposy
			EndIf
			$j = $ledges - 1
			For $i = 0 To $ledges - 1
				If (($aareacoords[$i][1] < $aposy AND $aareacoords[$j][1] >= $aposy) OR ($aareacoords[$j][1] < $aposy AND $aareacoords[$i][1] >= $aposy)) AND ($aareacoords[$i][0] <= $aposx OR $aareacoords[$j][0] <= $aposx) Then
					If ($aareacoords[$i][0] + ($aposy - $aareacoords[$i][1]) / ($aareacoords[$j][1] - $aareacoords[$i][1]) * ($aareacoords[$j][0] - $aareacoords[$i][0]) < $aposx) Then
						$loddnodes = NOT $loddnodes
					EndIf
				EndIf
				$j = $i
			Next
			Return $loddnodes
		EndFunc

	#EndRegion
	#Region Agentname

		Func getagentname($aagent)
			If $musestringlog = False Then Return
			If IsPtr($aagent) <> 0 Then
				Local $lagentptr = $aagent
				Local $lagentid = memoryread($aagent + 44, "long")
			ElseIf IsDllStruct($aagent) <> 0 Then
				Local $lagentid = DllStructGetData($aagent, "ID")
			Else
				Local $lagentid = convertid($aagent)
			EndIf
			If $lagentid = convertid(-2) Then Return getcharname()
			Local $laddress = $mstringlogbase + 256 * $lagentid
			Local $lname = memoryread($laddress, "wchar [128]")
			If $lname = "" Then
				displayall(True)
				Sleep(100)
				displayall(False)
			EndIf
			Local $lname = memoryread($laddress, "wchar [128]")
			$lname = StringRegExpReplace($lname, "[<]{1}([^>]+)[>]{1}", "")
			Return $lname
		EndFunc

	#EndRegion
	#Region Profession

		Func getprofessionprimary($aagent = getagentptr(-2))
			Return getagentprimaryprofession($aagent)
		EndFunc

		Func getprofessionsecondary($aagent = getagentptr(-2))
			Return getagentsecondaryprofession($aagent)
		EndFunc

		Func getagentprimaryprofession($aagent = getagentptr(-2))
			If IsPtr($aagent) <> 0 Then
				Return memoryread($aagent + 266, "byte")
			ElseIf IsDllStruct($aagent) <> 0 Then
				Return DllStructGetData($aagent, "Primary")
			Else
				Return memoryread(getagentptr($aagent) + 266, "byte")
			EndIf
		EndFunc

		Func getagentsecondaryprofession($aagent = getagentptr(-2))
			If IsPtr($aagent) <> 0 Then
				Return memoryread($aagent + 267, "byte")
			ElseIf IsDllStruct($aagent) <> 0 Then
				Return DllStructGetData($aagent, "Secondary")
			Else
				Return memoryread(getagentptr($aagent) + 267, "byte")
			EndIf
		EndFunc

		Func getagentprofessionsname($aagent = getagentptr(-2))
			Return getprofessionname(getagentprimaryprofession($aagent)) & "/" & getprofessionname(getagentsecondaryprofession($aagent))
		EndFunc

		Func getprofessionname($aprof)
			Switch $aprof
				Case 0
					Return "x"
				Case 1
					Return "W"
				Case 2
					Return "R"
				Case 3
					Return "Mo"
				Case 4
					Return "N"
				Case 5
					Return "Me"
				Case 6
					Return "E"
				Case 7
					Return "A"
				Case 8
					Return "Rt"
				Case 9
					Return "P"
				Case 10
					Return "D"
			EndSwitch
		EndFunc

		Func getprofessionfullname($aprof)
			Switch $aprof
				Case 0
					Return "x"
				Case 1
					Return "Warrior"
				Case 2
					Return "Ranger"
				Case 3
					Return "Monk"
				Case 4
					Return "Necromancer"
				Case 5
					Return "Mesmer"
				Case 6
					Return "Elementalist"
				Case 7
					Return "Assassin"
				Case 8
					Return "Ritualist"
				Case 9
					Return "Paragon"
				Case 10
					Return "Dervish"
			EndSwitch
		EndFunc

		Func getishealer($aagent = getagentptr(-2))
			$lprimaryprofession = getagentprimaryprofession($aagent)
			Switch $lprimaryprofession
				Case 3, 8
					Return True
			EndSwitch
			$lsecondaryprofession = getagentsecondaryprofession($aagent)
			Switch $lsecondaryprofession
				Case 3, 8
					Return True
			EndSwitch
		EndFunc

		Func ismonk($aagent = getagentptr(-2))
			If getagentprimaryprofession($aagent) = 3 Then Return True
			If getagentsecondaryprofession($aagent) = 3 Then Return True
			Return False
		EndFunc

		Func isemo($aagent = getagentptr(-2))
			If getagentprimaryprofession($aagent) = 6 AND getagentsecondaryprofession($aagent) = 3 Then Return True
		EndFunc

		Func getismartial($aagent = getagentptr(-2))
			Local $lagentweapontype
			If IsPtr($aagent) <> 0 Then
				$lagentweapontype = memoryread($aagent + 434, "word")
			ElseIf IsDllStruct($aagent) <> 0 Then
				$lagentweapontype = DllStructGetData($aagent, "WeaponType")
			Else
				$lagentweapontype = memoryread(getagentptr($aagent) + 434, "word")
			EndIf
			Switch $lagentweapontype
				Case 1 To 7
					Return True
				Case Else
					Return False
			EndSwitch
		EndFunc

	#EndRegion
#EndRegion Information
#Region CheckRupt

	Func checkrupt($acaster, $atarget, $askill, $aactivationtime)
		If IsPtr($acaster) <> 0 Then
			Local $lcasterptr = $acaster
			Local $lcasterallegiance = memoryread($acaster + 433, "byte")
			Local $lcastertypemap = memoryread($acaster + 344, "long")
		ElseIf IsDllStruct($acaster) <> 0 Then
			Local $lcasterptr = getagentptr(DllStructGetData($acaster, "ID"))
			Local $lcasterallegiance = DllStructGetData($acaster, "Allegiance")
			Local $lcastertypemap = DllStructGetData($acaster, "TypeMap")
		Else
			Local $lcasterptr = getagentptr($acaster)
			Local $lcasterallegiance = memoryread($acaster + 433, "byte")
			Local $lcastertypemap = memoryread($acaster + 344, "long")
		EndIf
		If IsPtr($askill) <> 0 Then
			Local $lskilltype = memoryread($askill + 12, "long")
			Local $lskillduration = memoryread($askill + 72, "long")
			Local $lskillactivation = memoryread($askill + 60, "float")
		ElseIf IsDllStruct($askill) <> 0 Then
			Local $lskilltype = DllStructGetData($askill, "Type")
			Local $lskillduration = DllStructGetData($askill, "Duration15")
			Local $lskillactivation = DllStructGetData($askill, "Activation")
		Else
			Local $lskillptr = getskillptr($askill)
			Local $lskilltype = memoryread($lskillptr + 12, "long")
			Local $lskillduration = memoryread($lskillptr + 72, "long")
			Local $lskillactivation = memoryread($lskillptr + 60, "float")
		EndIf
		Local $icast = False
		If $lcasterallegiance = 3 AND NOT BitAND($lcastertypemap, 262144) Then
			If $lskilltype = 5 Then
				If getdistancetoe($lcasterptr) < 1249 AND getenergy(-2) > 10 Then
					For $i = 1 To 8
						If NOT $isinterrupt[$i] Then ContinueLoop
						If getskillbarskillrecharge($i) <> 0 Then ContinueLoop
						useskill($i, $lcasterptr, True)
						$icast = True
						update("INTERRUPT!")
						ExitLoop
					Next
				EndIf
			EndIf
			If $lskilltype = 5 AND skillaoerange($askill) > 0 AND $lskillduration > 0 Then
				If getdistance($lcasterptr) < 1249 AND $lskillactivation > 0.15 Then
					$enemycaster = $lcasterptr
					$enemycastertimer = TimerInit()
					$enemycasteractivationtime = $lskillactivation
				EndIf
				If getdistance($atarget) < 500 Then
					$aoedanger = True
					$aoedangertimer = TimerInit()
					$aoedangerrange = skillaoerange($askill)
					$aoedangerduration = $lskillduration
					$aoedangerxlocation = xlocation($atarget)
					$aoedangerylocation = ylocation($atarget)
				EndIf
			EndIf
			If $lskilltype = 14 Then
				If getdistance($lcasterptr) < 1249 Then $enemyattacker = $lcasterptr
			EndIf
		EndIf
	EndFunc

#EndRegion
#Region Misc

	Func detectcinematic($aptr = getagentptr(-2))
		$ltypemap = memoryread($aptr + 344, "long")
		If BitAND($ltypemap, 4194304) OR $ltypemap = 0 Then
			$cinematic = False
			Return False
		Else
			$cinematic = True
			update("Cinematic detected, skipping!")
			skipcinematic()
			Return True
		EndIf
	EndFunc

	Func secureskipcinematic($adeadlock = 60000)
		Local $ldeadlock = TimerInit()
		While NOT detectcinematic()
			Sleep(1000)
			If TimerDiff($ldeadlock) > $adeadlock Then Return False
		WEnd
		skipcinematic()
		Do
			Sleep(1000)
		Until NOT detectcinematic()
		Return True
	EndFunc

#EndRegion

Func minmaxgold()
	$lgoldcharacter = getgoldcharacter()
	$lgoldstorage = getgoldstorage()
	$lgold = $lgoldcharacter + $lgoldstorage
	openstoragewindow()
	If $lgoldcharacter < 10000 AND $lgoldstorage > 10000 Then
		withdrawgold(10000 - $lgoldcharacter)
		Return 10000
	ElseIf $lgoldcharacter > 50000 AND $lgold < 1000000 Then
		depositgold($lgoldcharacter - 10000)
		Return 10000
	Else
		Return $lgoldcharacter
	EndIf
EndFunc

Func buykits($aamount = 40, $aexpertsalv = True)
	$lidkituses = findidkituses(1, 4)
	If $lidkituses < $aamount Then
		$litemidrow = getitemrowbymodelid(2989)
		$lkituses = 25
		If $litemidrow = 0 Then
			$litemidrow = getitemrowbymodelid(5899)
			$lkituses = 100
			If $litemidrow = 0 Then Return
		EndIf
		$lbuyamount = Ceiling(($aamount - $lidkituses) / $lkituses)
		update("Buying ID Kits: " & $lbuyamount)
		buyidentkit($litemidrow, $lbuyamount)
		Sleep(250 + getping())
	EndIf
	$lsalvkituses = cheapsalvageuses(1, 4)
	If $lsalvkituses < $aamount Then
		$litemidrow = getitemrowbymodelid(2992)
		$lkituses = 25
		If $litemidrow = 0 Then
			$litemidrow = getitemrowbymodelid(2993)
			$lkituses = 10
			If $litemidrow = 0 Then Return
		EndIf
		$lbuyamount = Ceiling(($aamount - $lsalvkituses) / $lkituses)
		update("Buying Salvage Kits: " & $lbuyamount)
		buysalvkit(False, $litemidrow, $lbuyamount)
		Sleep(250 + getping())
	EndIf
	If $aexpertsalv Then
		$lexpersalvkituses = expertsalvageuses(1, 4)
		If $lexpersalvkituses < $aamount Then
			$litemidrow = getitemrowbymodelid(2991)
			$lkituses = 25
			If $litemidrow = 0 Then
				$litemidrow = getitemrowbymodelid(5900)
				$lkituses = 100
				If $litemidrow = 0 Then Return
			EndIf
			$lbuyamount = Ceiling(($aamount - $lexpersalvkituses) / $lkituses)
			update("Buying Expert Salv Kits: " & $lbuyamount)
			buysalvkit(True, $litemidrow, $lbuyamount)
			Sleep(250 + getping())
		EndIf
	EndIf
EndFunc

Func cheapsalvageuses($astart = 1, $afinish = 16)
	Local $lcount = 0
	For $bag = $astart To $afinish
		Local $lbagptr = getbagptr($bag)
		Local $litemarrayptr = memoryread($lbagptr + 24, "ptr")
		For $slot = 0 To memoryread($lbagptr + 32, "long") - 1
			Local $litemptr = memoryread($litemarrayptr + 4 * ($slot), "ptr")
			If $litemptr = 0 Then ContinueLoop
			Local $litemmid = memoryread($litemptr + 44, "long")
			If $litemmid = 2992 OR $litemmid = 2993 Then $lcount += memoryread($litemptr + 36, "short") / 2
		Next
	Next
	Return $lcount
EndFunc

Func buyidentkit($aitemidrow = 0, $aamount = 1)
	If $aitemidrow = 0 Then
		$litemidrow = getitemrowbymodelid(2989)
		If $litemidrow = 0 Then
			$litemidrow = getitemrowbymodelid(5899)
			If $litemidrow = 0 Then Return
		EndIf
	Else
		$litemidrow = $aitemidrow
	EndIf
	$litemptr = getitemptr($litemidrow)
	$lvalue = memoryread($litemptr + 36, "short") * 2
	DllStructSetData($mbuyitem, 2, $aamount)
	DllStructSetData($mbuyitem, 3, $litemidrow)
	DllStructSetData($mbuyitem, 4, $lvalue * $aamount)
	enqueue($mbuyitemptr, 16)
	Return $litemptr
EndFunc

Func buysalvkit($aexpert = False, $aitemidrow = 0, $aamount = 1)
	If $aitemidrow = 0 Then
		If $aexpert Then
			$litemidrow = getitemrowbymodelid(2991)
			If $litemidrow = 0 Then
				$litemidrow = getitemrowbymodelid(5900)
				If $litemidrow = 0 Then Return
			EndIf
		Else
			$litemidrow = getitemrowbymodelid(2992)
			If $litemidrow = 0 Then
				$litemidrow = getitemrowbymodelid(2993)
				If $litemidrow = 0 Then Return
			EndIf
		EndIf
	Else
		$litemidrow = $aitemidrow
	EndIf
	$litemptr = getitemptr($litemidrow)
	$lvalue = memoryread($litemptr + 36, "short") * 2
	DllStructSetData($mbuyitem, 2, $aamount)
	DllStructSetData($mbuyitem, 3, $litemidrow)
	DllStructSetData($mbuyitem, 4, $aamount * $lvalue)
	enqueue($mbuyitemptr, 16)
	Return $litemptr
EndFunc

Func ident()
	For $bag = 1 To 4
		$lbagptr = getbagptr($bag)
		If $lbagptr = 0 Then ContinueLoop
		For $slot = 1 To memoryread($lbagptr + 32, "long")
			$litemptr = getitemptrbyslot($lbagptr, $slot)
			If $litemptr = 0 Then ContinueLoop
			If getisunided($litemptr) Then
				update("Identify: " & $bag & ", " & $slot)
				identifyitem($litemptr)
			EndIf
		Next
	Next
EndFunc

Func storeitems()
	updateemptystorageslot($memptybag, $memptyslot)
	update("Empty Spot: " & $memptybag & ", " & $memptyslot)
	If $memptyslot = 0 Then Return
	openstoragewindow()
	For $bag = 1 To 4
		$lbagptr = getbagptr($bag)
		If $lbagptr = 0 Then ContinueLoop
		$litemarrayptr = memoryread($lbagptr + 24, "ptr")
		For $slot = 0 To memoryread($lbagptr + 32, "long") - 1
			$litemptr = memoryread($litemarrayptr + 4 * ($slot), "ptr")
			If $litemptr = 0 Then ContinueLoop
			$litemid = memoryread($litemptr, "long")
			$litemtype = memoryread($litemptr + 32, "byte")
			$litemquantity = memoryread($litemptr + 75, "byte")
			If $litemtype = 11 AND $litemquantity = 250 AND $mstorematerials Then
				update("Store Materials: " & $bag & ", " & $slot & " -> " & $memptybag & ", " & $memptyslot)
				moveitem($litemid, $memptybag, $memptyslot)
				Do
					Sleep(250)
				Until memoryread($litemarrayptr + 4 * ($slot), "ptr") = 0
				updateemptystorageslot($memptybag, $memptyslot)
				If $memptyslot = 0 Then Return
				ContinueLoop
			EndIf
			$litemmid = memoryread($litemptr + 44, "long")
			If stackableitems($litemmid) AND $litemquantity = 250 Then
				update("Store Stack: " & $bag & ", " & $slot & " -> " & $memptybag & ", " & $memptyslot)
				moveitem($litemid, $memptybag, $memptyslot)
				Do
					Sleep(250)
				Until memoryread($litemarrayptr + 4 * ($slot), "ptr") = 0
				updateemptystorageslot($memptybag, $memptyslot)
				If $memptyslot = 0 Then Return
				ContinueLoop
			EndIf
			If keepers($litemmid) Then
				update("Store Keepers: " & $bag & ", " & $slot & " -> " & $memptybag & ", " & $memptyslot)
				moveitem($litemid, $memptybag, $memptyslot)
				Do
					Sleep(250)
				Until memoryread($litemarrayptr + 4 * ($slot), "ptr") = 0
				updateemptystorageslot($memptybag, $memptyslot)
				If $memptyslot = 0 Then Return
				ContinueLoop
			EndIf
			If $mstoregold AND getrarity($litemptr) = 2624 Then
				update("Store Golds: " & $bag & ", " & $slot & " -> " & $memptybag & ", " & $memptyslot)
				moveitem($litemid, $memptybag, $memptyslot)
				Do
					Sleep(250)
				Until memoryread($litemarrayptr + 4 * ($slot), "ptr") = 0
				updateemptystorageslot($memptybag, $memptyslot)
				If $memptyslot = 0 Then Return
				ContinueLoop
			EndIf
		Next
	Next
EndFunc

Func stackableitems($amodelid)
	Switch $amodelid
		Case 460, 474, 476, 486, 504, 522, 525, 811, 819, 822, 835, 1610, 2994, 19185, 22751, 24629, 24630, 24631, 24632, 27033, 27035, 27044, 27046, 27047, 27052, 35123
			Return True
		Case 21786 To 21805
			Return True
		Case 910, 2513, 5585, 6049, 6366, 6367, 6375, 15477, 19171, 22190, 24593, 28435, 30855, 31145, 31146, 35124, 36682
			Return True
		Case 6376, 6368, 6369, 21809, 21810, 21813, 29436, 29543, 36683, 4730, 15837, 21490, 22192, 30626, 30630, 30638, 30642, 30646, 30648, 31020, 31141, 31142, 31144, 31172
			Return True
		Case 15528, 15479, 19170, 21492, 21812, 22269, 22644, 22752, 28431, 28432, 28436, 31150, 35125, 36681
			Return True
		Case 3256, 3746, 5594, 5595, 5611, 21233, 22279, 22280
			Return True
		Case 6370, 21488, 21489, 22191, 35127, 26784, 28433
			Return True
		Case 18345, 21491, 21833, 28434, 35121
			Return True
		Case Else
			Return False
	EndSwitch
EndFunc

Func updateemptyslot(ByRef $abagnr, ByRef $aslot)
	If $abagnr = 0 Then
		$lbagnr = 1
	Else
		$lbagnr = $abagnr
	EndIf
	If $aslot = 0 Then
		$lslot = 1
	Else
		$lslot = $aslot
	EndIf
	$abagnr = 0
	$aslot = 0
	For $bag = $lbagnr To 4
		$lbagptr = getbagptr($bag)
		If $lbagptr = 0 Then Return 0
		For $slot = $lslot To memoryread($lbagptr + 32, "long")
			$lslotptr = getitemptrbyslot($lbagptr, $slot)
			If $lslotptr = 0 Then
				$abagnr = $bag
				$aslot = $slot
				Return True
			EndIf
		Next
		$lslot = 1
	Next
EndFunc

Func updateemptystorageslot(ByRef $abagnr, ByRef $aslot)
	If $abagnr = 0 Then
		$lbagnr = 8
	Else
		$lbagnr = $abagnr
	EndIf
	If $aslot = 0 Then
		$lslot = 1
	Else
		$lslot = $aslot
	EndIf
	$abagnr = 0
	$aslot = 0
	For $bag = $lbagnr To 16
		$lbagptr = getbagptr($bag)
		If $lbagptr = 0 Then Return 0
		For $slot = $lslot To 20
			$lslotptr = getitemptrbyslot($lbagptr, $slot)
			If $lslotptr = 0 Then
				$abagnr = $bag
				$aslot = $slot
				Return True
			EndIf
		Next
		$lslot = 1
	Next
EndFunc

Func keepers($amodelid)
	Switch $amodelid
		Case 896, 908, 15554, 15551, 15552, 894, 906, 897, 909, 893, 905, 6323, 6331, 895, 907, 15543, 15553, 15544, 15555, 15540, 15541, 15542, 17059, 19122, 19123
			Return True
		Case 5551
			Return True
		Case 460
			Return $mwhitemantleemblem
		Case 461
			Return $mwhitemantlebadge
		Case Else
			Return False
	EndSwitch
EndFunc

Func salvagebags()
	Local $lidkit = findidkitptr()
	If $lidkit = 0 Then
		Local $lidentify = False
	Else
		Local $lidkitid = memoryread($lidkit, "long")
		Local $lidentify = True
	EndIf
	Local $lexpertkit = findexpertsalvagekit()
	If $lexpertkit = 0 Then
		Return
	Else
		$lexpertkitid = memoryread($lexpertkit, "long")
	EndIf
	Local $lcheapkit = findcheapsalvagekit()
	If $lcheapkit = 0 Then
		Return
	Else
		$lcheapkitid = memoryread($lcheapkit, "long")
	EndIf
	For $bag = 1 To 4
		$lbagptr = getbagptr($bag)
		If $lbagptr = 0 Then ContinueLoop
		For $slot = 1 To memoryread($lbagptr + 32, "long")
			$litem = getitemptrbyslot($lbagptr, $slot)
			If ignoreitem($litem) Then ContinueLoop
			If memoryread($litem + 32, "byte") = 31 Then ContinueLoop
			$lquantity = memoryread($litem + 75, "byte")
			If $lquantity > 1 AND NOT $msalvagestacks Then ContinueLoop
			$itemmid = memoryread($litem + 44, "long")
			If $itemmid = 504 Then ContinueLoop
			If $itemmid = 460 OR $itemmid = 461 Then ContinueLoop
			If keepers($itemmid) Then ContinueLoop
			$itemrarity = getrarity($litem)
			If $itemrarity = 2624 AND getisrareweapon($litem) Then ContinueLoop
			If $lidentify AND getisunided($litem) Then
				If memoryread($lidkit + 12, "ptr") = 0 Then
					$lidkit = findidkitptr()
					If $lidkit = 0 Then
						$lidentify = False
						ContinueLoop
					Else
						$lidkitid = memoryread($lidkit, "long")
					EndIf
				EndIf
				update("Identify: " & $bag & ", " & $slot)
				identifyitem($litem, $lidkitid)
				Sleep(250)
				Do
					Sleep(250)
				Until NOT getisunided($litem)
			EndIf
			If $itemrarity = 2621 Then
				For $i = 1 To $lquantity
					If memoryread($lcheapkit + 12, "ptr") = 0 Then
						$lcheapkit = findcheapsalvagekit()
						If $lcheapkit = 0 Then
							Return -1
						Else
							$lcheapkitid = memoryread($lcheapkit, "long")
						EndIf
					EndIf
					update("Salvaging (white): " & $bag & ", " & $slot)
					$lquantityold = $lquantity
					startsalvage($litem, $lcheapkitid)
					Local $ldeadlock = TimerInit()
					Do
						Sleep(20)
						$lquantity = memoryread($litem + 75, "byte")
					Until $lquantity <> $lquantityold OR memoryread($litem + 12, "ptr") = 0 OR TimerDiff($ldeadlock) > 2500
					Sleep(250)
				Next
			ElseIf $itemrarity = 2623 OR $itemrarity = 2626 OR $itemrarity = 2624 Then
				$itemtype = memoryread($litem + 32, "byte")
				If $itemtype = 0 Then
					$lmod = upgrades($litem)
					While $lmod <> 0
						If memoryread($lexpertkit + 12, "ptr") = 0 Then
							$lexpertkit = findexpertsalvagekit()
							If $lexpertkit = 0 Then
								Return -1
							Else
								$lexpertkitid = memoryread($lexpertkit, "long")
							EndIf
						EndIf
						update("Salvage (" & $lmod - 1 & "): " & $bag & ", " & $slot)
						$lvalue = memoryread($lexpertkit + 36, "short")
						startsalvage($litem, $lexpertkitid)
						Sleep(100)
						salvagemod($lmod - 1)
						Local $ldeadlock = TimerInit()
						Do
							Sleep(50)
						Until $lvalue <> memoryread($lexpertkit + 36, "short") OR TimerDiff($ldeadlock) > 2500
						Sleep(250 + getping())
						$lmod = upgrades($litem)
					WEnd
				ElseIf isweapon($itemtype) Then
					$lmod = weaponmods($litem)
					While $lmod <> 0
						If memoryread($lexpertkit + 12, "ptr") = 0 Then
							$lexpertkit = findexpertsalvagekit()
							If $lexpertkit = 0 Then
								Return -1
							Else
								$lexpertkitid = memoryread($lexpertkit, "long")
							EndIf
						EndIf
						update("Salvage (" & $lmod - 1 & "): " & $bag & ", " & $slot)
						$lvalue = memoryread($lexpertkit + 36, "short")
						startsalvage($litem, $lexpertkitid)
						Sleep(100)
						salvagemod($lmod - 1)
						Local $ldeadlock = TimerInit()
						Do
							Sleep(50)
						Until $lvalue <> memoryread($lexpertkit + 36, "short") OR TimerDiff($ldeadlock) > 2500
						Sleep(250 + getping())
						$lmod = weaponmods($litem)
					WEnd
				EndIf
				Sleep(500)
				If $itemrarity <> 2624 AND memoryread($litem + 12, "ptr") <> 0 Then
					If memoryread($lcheapkit + 12, "ptr") = 0 Then
						$lcheapkit = findcheapsalvagekit()
						If $lcheapkit = 0 Then
							Return -1
						Else
							$lcheapkitid = memoryread($lcheapkit, "long")
						EndIf
					EndIf
					update("Salvage (Materials): " & $bag & ", " & $slot)
					startsalvage($litem, $lcheapkitid)
					Sleep(1000 + getping())
					salvagematerials()
					Local $ldeadlock = TimerInit()
					Do
						Sleep(20)
					Until memoryread($litem + 12, "ptr") = 0 OR TimerDiff($ldeadlock) > 2500
					Sleep(250 + getping())
				EndIf
			EndIf
			Sleep(500)
		Next
	Next
EndFunc

Func salvagebagsexplorable()
	If countslots() < 2 Then Return
	Local $lsalvkituses = 0, $lidkituses = 0, $lsalvkitmid
	$lsalvkit = findsalvkitexplorable($lsalvkituses)
	If $lsalvkit = 0 Then Return
	$lsalvkitmid = @extended
	For $bag = 1 To 4
		$lbagptr = getbagptr($bag)
		If $lbagptr = 0 Then ContinueLoop
		For $slot = 1 To memoryread($lbagptr + 32, "long")
			$litem = getitemptrbyslot($lbagptr, $slot)
			If ignoreitem($litem) Then ContinueLoop
			If memoryread($litem + 32, "byte") = 31 Then ContinueLoop
			If memoryread($litem + 75, "byte") > 1 Then ContinueLoop
			$itemmid = memoryread($litem + 44, "long")
			If $itemmid = 504 Then ContinueLoop
			If $itemmid = 460 OR $itemmid = 461 Then ContinueLoop
			If keepers($itemmid) Then ContinueLoop
			$itemrarity = getrarity($litem)
			If $itemrarity = 2624 AND getisrareweapon($litem) Then ContinueLoop
			If getisunided($litem) AND $itemrarity <> 2624 Then
				If $itemrarity = 2623 OR $itemrarity = 2626 Then
					If $lidkituses = 0 Then
						$lidkit = findidkitexplorable($lidkituses)
						If $lidkituses = 0 Then ContinueLoop
					EndIf
					$lidkitvalue = memoryread($lidkit + 36, "short")
					update("Identify: " & $bag & ", " & $slot)
					identifyitem($litem, memoryread($lidkit, "long"))
					$lidkituses -= 1
					Sleep(250)
					Do
						Sleep(250)
					Until memoryread($lidkit + 36, "short") <> $lidkitvalue OR memoryread($lidkit + 12, "ptr") = 0
					Sleep(getping() + 100)
				EndIf
			EndIf
			If memoryread($lsalvkit + 12, "ptr") = 0 Then
				$lsalvkit = findsalvkitexplorable($lsalvkituses)
				If $lsalvkit = 0 Then Return
				$lsalvkitmid = @extended
			EndIf
			If $itemrarity = 2621 Then
				update("Salvaging (white): " & $bag & ", " & $slot)
				startsalvage($litem, memoryread($lsalvkit, "long"))
				Local $ldeadlock = TimerInit()
				Do
					Sleep(20)
				Until memoryread($litem + 12, "ptr") = 0 OR TimerDiff($ldeadlock) > 2500
				$lsalvkituses -= 1
				Sleep(250 + getping())
			ElseIf $itemrarity = 2623 OR $itemrarity = 2626 Then
				$itemtype = memoryread($litem + 32, "byte")
				If $itemtype = 0 AND upgrades($litem) <> 0 Then
					ContinueLoop
				ElseIf isweapon($itemtype) AND weaponmods($litem) <> 0 Then
					ContinueLoop
				Else
					update("Salvaging (" & $lsalvkitmid & "): " & $bag & ", " & $slot)
					startsalvage($litem, memoryread($lsalvkit, "long"))
					Sleep(1000 + getping())
					salvagematerials()
					Local $ldeadlock = TimerInit()
					Do
						Sleep(20)
					Until memoryread($litem + 12, "ptr") = 0 OR TimerDiff($ldeadlock) > 2500
					$lsalvkituses -= 1
					Sleep(250 + getping())
				EndIf
			EndIf
			Sleep(250)
		Next
	Next
EndFunc

Func findsalvkitexplorable(ByRef $auses)
	Local $luses = 101
	Local $lkit = 0
	Local $lkitmid = 0
	$auses = 0
	For $bag = 1 To 4
		Local $lbagptr = getbagptr($bag)
		Local $litemarrayptr = memoryread($lbagptr + 24, "ptr")
		For $slot = 0 To memoryread($lbagptr + 32, "long") - 1
			Local $litemptr = memoryread($litemarrayptr + 4 * ($slot), "ptr")
			If $litemptr = 0 Then ContinueLoop
			Local $litemmid = memoryread($litemptr + 44, "long")
			If $litemmid = 2992 OR $litemmid = 2993 Then
				Local $lvalue = memoryread($litemptr + 36, "short")
				$auses = $lvalue / 2
				Return SetExtended($litemmid, $litemptr)
			EndIf
		Next
	Next
EndFunc

Func findidkitexplorable(ByRef $auses)
	Local $luses = 101
	Local $lkit = 0
	Local $lkitmid = 0
	$auses = 0
	For $bag = 1 To 4
		Local $lbagptr = getbagptr($bag)
		Local $litemarrayptr = memoryread($lbagptr + 24, "ptr")
		For $slot = 0 To memoryread($lbagptr + 32, "long") - 1
			Local $litemptr = memoryread($litemarrayptr + 4 * ($slot), "ptr")
			If $litemptr = 0 Then ContinueLoop
			Local $litemmid = memoryread($litemptr + 44, "long")
			Switch $litemmid
				Case 2989
					Local $lvalue = memoryread($litemptr + 36, "short")
					If $lvalue / 2 < $luses Then
						$luses = $lvalue / 2
						$lkit = $litemptr
						$lkitmid = $litemmid
						$auses = $luses
					EndIf
				Case 5899
					Local $lvalue = memoryread($litemptr + 36, "short")
					If $lvalue / 2.5 < $luses Then
						$luses = $lvalue / 2.5
						$lkit = $litemptr
						$lkitmid = $litemmid
						$auses = $luses
					EndIf
				Case Else
					ContinueLoop
			EndSwitch
		Next
	Next
	Return SetExtended($lkitmid, $lkit)
EndFunc

Func ignoreitem($aitemptr)
	If $aitemptr = 0 Then Return True
	If memoryread($aitemptr + 24, "ptr") <> 0 Then Return True
	If memoryread($aitemptr + 76, "byte") <> 0 Then Return True
	If memoryread($aitemptr + 36, "short") = 0 Then Return True
	If memoryread($aitemptr + 12, "ptr") = 0 Then Return True
	Switch memoryread($aitemptr + 32, "byte")
		Case 11
			Return True
		Case 8
			Return True
		Case 9
			Return True
		Case 10
			Return True
		Case 29
			Return True
		Case 34
			Return True
		Case 18
			Return True
	EndSwitch
EndFunc

Func findexpertsalvagekit($astart = 1, $afinish = 16)
	Local $luses = 101
	Local $lkit = 0
	For $bag = $astart To $afinish
		Local $lbagptr = getbagptr($bag)
		If $lbagptr = 0 Then ContinueLoop
		Local $litemarrayptr = memoryread($lbagptr + 24, "ptr")
		For $slot = 0 To memoryread($lbagptr + 32, "long") - 1
			Local $litemptr = memoryread($litemarrayptr + 4 * ($slot), "ptr")
			If $litemptr = 0 Then ContinueLoop
			Local $litemmid = memoryread($litemptr + 44, "long")
			If $litemmid = 2991 OR $litemmid = 5900 Then Return $litemptr
			Switch $litemmid
				Case 2991
					Local $lvalue = memoryread($litemptr + 36, "short")
					If $lvalue / 8 < $luses Then
						$luses = $lvalue / 8
						$lkit = $litemptr
					EndIf
				Case 5900
					Local $lvalue = memoryread($litemptr + 36, "short")
					If $lvalue / 10 < $luses Then
						$luses = $lvalue / 10
						$lkit = $litemptr
					EndIf
			EndSwitch
		Next
	Next
	Return $lkit
EndFunc

Func findcheapsalvagekit($astart = 1, $afinish = 16)
	Local $luses = 101
	Local $lkit = 0
	For $bag = $astart To $afinish
		Local $lbagptr = getbagptr($bag)
		If $lbagptr = 0 Then ContinueLoop
		Local $litemarrayptr = memoryread($lbagptr + 24, "ptr")
		For $slot = 0 To memoryread($lbagptr + 32, "long") - 1
			Local $litemptr = memoryread($litemarrayptr + 4 * ($slot), "ptr")
			If $litemptr = 0 Then ContinueLoop
			Local $litemmid = memoryread($litemptr + 44, "long")
			If $litemmid = 2992 OR $litemmid = 2993 Then Return $litemptr
			Switch $litemmid
				Case 2992, 2993
					Local $lvalue = memoryread($litemptr + 36, "short")
					If $lvalue / 2 < $luses Then
						$luses = $lvalue / 2
						$lkit = $litemptr
					EndIf
			EndSwitch
		Next
	Next
	Return $lkit
EndFunc

Func findidkitptr($astart = 1, $afinish = 16)
	Local $luses = 101
	Local $lkit = 0
	For $bag = $astart To $afinish
		Local $lbagptr = getbagptr($bag)
		Local $litemarrayptr = memoryread($lbagptr + 24, "ptr")
		For $slot = 0 To memoryread($lbagptr + 32, "long") - 1
			Local $litemptr = memoryread($litemarrayptr + 4 * ($slot), "ptr")
			If $litemptr = 0 Then ContinueLoop
			Local $litemmid = memoryread($litemptr + 44, "long")
			If $litemmid = 2989 OR $litemmid = 5899 Then Return $litemptr
		Next
	Next
EndFunc

Func expertsalvageuses($astart = 1, $afinish = 16)
	Local $lcount = 0
	For $bag = $astart To $afinish
		Local $lbagptr = getbagptr($bag)
		Local $litemarrayptr = memoryread($lbagptr + 24, "ptr")
		For $slot = 0 To memoryread($lbagptr + 32, "long") - 1
			Local $litemptr = memoryread($litemarrayptr + 4 * ($slot), "ptr")
			If $litemptr = 0 Then ContinueLoop
			Local $litemmid = memoryread($litemptr + 44, "long")
			Switch $litemmid
				Case 2991
					$lcount += memoryread($litemptr + 36, "short") / 8
				Case 5900
					$lcount += memoryread($litemptr + 36, "short") / 10
			EndSwitch
		Next
	Next
	Return $lcount
EndFunc

Func isweapon($atype)
	Switch $atype
		Case 2, 5, 12, 15, 22, 24, 26, 27, 32, 35, 36
			Return True
		Case Else
			Return False
	EndSwitch
EndFunc

Func upgrades($aitemptr)
	Local $linsigniaarray[8] = ["FB010824", "0A020824", "E1010824", "04020824", "02020824", "07020824", "E6010824", "E9010824"]
	Local $lrunearray[17] = ["0111E821", "010DE821", "0110E821", "0106E821", "0100E821", "0302E8217701", "010CE821", "030AE8217B01", "0124E821", "0322E8218102", "012CE821", "0129E821", "C202E827", "000A4823", "0200D822", "C202E927", "C202EA27"]
	$lmodstruct = memoryreadstruct($aitemptr + 16, "ptr;long")
	$lmod = memoryread(DllStructGetData($lmodstruct, 1), "byte[" & DllStructGetData($lmodstruct, 2) * 4 & "]")
	For $i = 0 To 7
		If StringInStr($lmod, $linsigniaarray[$i]) <> 0 Then Return 1
	Next
	For $i = 0 To 16
		If StringInStr($lmod, $lrunearray[$i]) <> 0 Then Return 2
	Next
EndFunc

Func weaponmods($aitemptr)
	Local $lprefixarray[4][2] = [["1414F823", 5], ["01001825", 26], ["01001825", 32], ["01001825", 35]]
	Local $lsuffixarray[6][2] = [["05000821", 5], ["1400B822", 26], ["1400B822", 27], ["1400B822", 32], ["1400B822", 35], ["001E4823", 24]]
	Local $linscriptionarray[3] = ["0A0118A1", "0500D822", "0500B820"]
	$lmodstruct = memoryreadstruct($aitemptr + 16, "ptr;long")
	$lmod = memoryread(DllStructGetData($lmodstruct, 1), "byte[" & DllStructGetData($lmodstruct, 2) * 4 & "]")
	$ltype = memoryread($aitemptr + 32, "byte")
	For $i = 0 To 1
		If StringInStr($lmod, $lprefixarray[$i][0]) <> 0 AND $ltype = $lprefixarray[$i][1] Then Return 1
	Next
	For $i = 0 To 1
		If StringInStr($lmod, $lsuffixarray[$i][0]) <> 0 AND $ltype = $lsuffixarray[$i][1] Then Return 2
	Next
	For $i = 0 To 0
		If StringInStr($lmod, $linscriptionarray[$i]) <> 0 Then Return 3
	Next
EndFunc

Func sell()
	For $bag = 1 To 4
		$lbagptr = getbagptr($bag)
		If $lbagptr = 0 Then ContinueLoop
		For $slot = 1 To memoryread($lbagptr + 32, "long")
			$litemptr = getitemptrbyslot($lbagptr, $slot)
			If $litemptr = 0 Then ContinueLoop
			If ignoreitem($litemptr) Then ContinueLoop
			$litemmid = memoryread($litemptr + 44, "long")
			If keepers($litemmid) Then ContinueLoop
			If stackableitems($litemmid) Then ContinueLoop
			If getrarity($litemptr) = 2624 AND getisrareweapon($litemptr) Then ContinueLoop
			If getisunided($litemptr) Then identifyitem($litemptr)
			update("Sell Item: " & $bag & ", " & $slot)
			sellitem($litemptr)
			Sleep(500)
		Next
	Next
EndFunc

Func sellmaterials($arare = False)
	For $bag = 1 To 4
		$lbagptr = getbagptr($bag)
		If $lbagptr = 0 Then ContinueLoop
		For $slot = 1 To memoryread($lbagptr + 32, "long")
			$litemptr = getitemptrbyslot($lbagptr, $slot)
			If $litemptr = 0 Then ContinueLoop
			If memoryread($litemptr + 32, "byte") <> 11 Then ContinueLoop
			$litemmid = memoryread($litemptr + 44, "long")
			$lmattype = checkmaterial($litemmid)
			If $arare Then
				If $lmattype = 2 Then
					For $i = 1 To memoryread($litemptr + 75, "byte")
						traderrequestsell($litemptr)
						update("Sell rare materials: " & $bag & ", " & $slot)
						Sleep(250)
						tradersell()
					Next
				EndIf
			Else
				If $lmattype = 1 Then
					For $i = 1 To Floor(memoryread($litemptr + 75, "byte") / 10)
						update("Sell materials: " & $bag & ", " & $slot)
						traderrequestsell($litemptr)
						Sleep(250)
						tradersell()
					Next
				EndIf
			EndIf
		Next
	Next
EndFunc

Func checkmaterial($amodelid)
	Switch $amodelid
		Case 954, 925
			Return 1
		Case 929, 933, 934
			Return $mdustfeatherfiber
		Case 955, 948, 921
			Return $mgraniteironbone
		Case 940, 946, 953
			Return 1
		Case 928, 926, 927
			Return 2
		Case 931, 932, 923
			Return 2
		Case 922, 950, 949
			Return 2
		Case 951, 952, 956
			Return 2
		Case 937, 935, 938
			Return 0
		Case 936, 945, 930
			Return 0
		Case 941, 942, 943
			Return 2
		Case 944, 939
			Return 2
		Case 6532, 6533
			Return 0
	EndSwitch
EndFunc

Func sellupgrades()
	For $bag = 1 To 4
		$lbagptr = getbagptr($bag)
		If $lbagptr = 0 Then ContinueLoop
		For $slot = 1 To memoryread($lbagptr + 32, "long")
			$litemptr = getitemptrbyslot($lbagptr, $slot)
			If $litemptr = 0 Then ContinueLoop
			If memoryread($litemptr + 32, "byte") <> 8 Then ContinueLoop
			If isruneorinsignia(memoryread($litemptr + 44, "long")) = 0 Then ContinueLoop
			traderrequestsell($litemptr)
			Sleep(250)
			update("Sell Upgrade: " & $bag & ", " & $slot)
			tradersell()
		Next
	Next
EndFunc

Func selldyes()
	For $bag = 1 To 4
		$lbagptr = getbagptr($bag)
		If $lbagptr = 0 Then ContinueLoop
		For $slot = 1 To memoryread($lbagptr + 32, "long")
			$litemptr = getitemptrbyslot($lbagptr, $slot)
			If $litemptr = 0 Then ContinueLoop
			$litemmid = memoryread($litemptr + 44, "long")
			If $litemmid <> 146 Then ContinueLoop
			If $mblackwhite Then
				$litemextraid = memoryread($litemptr + 34, "short")
				If $litemextraid = 10 OR $litemextraid = 12 Then ContinueLoop
			EndIf
			For $i = 1 To memoryread($litemptr + 75, "byte")
				update("Sell Dye: " & $bag & ", " & $slot)
				traderrequestsell($litemptr)
				Sleep(250)
				tradersell()
			Next
		Next
	Next
EndFunc

Func clearinventoryspace($amapid)
	If gotomerchant(getdyetrader($amapid)) <> 0 Then selldyes()
	If gotomerchant(getrunetrader($amapid)) <> 0 Then sellupgrades()
	If gotomerchant(getmaterialtrader($amapid)) <> 0 Then sellmaterials()
	If gotomerchant(getscrolltrader($amapid)) <> 0 Then sellscrolls()
	If gotomerchant(getrarematerialtrader($amapid)) <> 0 Then sellmaterials(True)
	$lslots = countslots()
	If $lslots > 3 Then Return True
	gotomerchant(getmerchant($amapid))
	For $bag = 1 To 4
		$lbagptr = getbagptr($bag)
		If $lbagptr = 0 Then ContinueLoop
		For $slot = 1 To memoryread($lbagptr + 32, "long")
			$litemptr = getitemptrbyslot($lbagptr, $slot)
			If $litemptr = 0 Then ContinueLoop
			If memoryread($litemptr + 24, "ptr") <> 0 Then ContinueLoop
			If memoryread($litemptr + 76, "byte") <> 0 Then ContinueLoop
			If memoryread($litemptr + 36, "short") = 0 Then ContinueLoop
			If memoryread($litemptr + 12, "ptr") = 0 Then ContinueLoop
			$litemmid = memoryread($litemptr + 44, "long")
			If junk($litemmid) Then
				update("Sell Item: " & $bag & ", " & $slot)
				sellitem($litemptr)
				Sleep(500)
				$lslots += 1
				If $lslots > 3 Then Return True
				ContinueLoop
			EndIf
			If keepers($litemmid) Then ContinueLoop
			If stackableitems($litemmid) Then ContinueLoop
			$litemrarity = getrarity($litemptr)
			If getisunided($litemptr) Then
				If $litemrarity = 2624 OR $litemrarity = 2626 Then
					$lidkit = findidkitptr()
					$lidkitid = memoryread($lidkit, "long")
					If $lidkitid = 0 Then ContinueLoop
					update("Identify: " & $bag & ", " & $slot)
					identifyitem($litemptr, $lidkitid)
					Sleep(250)
					Do
						Sleep(250)
					Until NOT getisunided($litemptr)
				Else
					ContinueLoop
				EndIf
			EndIf
			Switch memoryread($litemptr + 32, "byte")
				Case 0
					If upgrades($litemptr) Then ContinueLoop
				Case 2, 5, 12, 15, 19, 22, 24, 26, 27, 32, 35, 36
					If $litemrarity = 2621 Then ContinueLoop
					If $mraritygreen AND $litemrarity = 2627 Then ContinueLoop
					If weaponmods($litemptr) Then ContinueLoop
				Case 4, 7, 13, 16, 19
					ContinueLoop
				Case 11
					ContinueLoop
				Case 8
					ContinueLoop
				Case 9
					ContinueLoop
				Case 10
					ContinueLoop
				Case 29
					ContinueLoop
				Case 34
					ContinueLoop
				Case 18
					Switch $litemmid
						Case 5962
							ContinueLoop
						Case 5963
							ContinueLoop
						Case 5961
							ContinueLoop
						Case 6535
							ContinueLoop
						Case 6536
							ContinueLoop
						Case 6538
							ContinueLoop
						Case 6539
							ContinueLoop
						Case 6534
							ContinueLoop
						Case 15558
							ContinueLoop
						Case 15556
							ContinueLoop
						Case 15560
							ContinueLoop
						Case 19174
							ContinueLoop
						Case 5882
							ContinueLoop
						Case 5971
							ContinueLoop
						Case 22751
							ContinueLoop
					EndSwitch
			EndSwitch
			update("Sell Item: " & $bag & ", " & $slot)
			sellitem($litemptr)
			Sleep(500)
			$lslots += 1
			If $lslots > 3 Then Return True
		Next
	Next
	Return $lslots > 3
EndFunc

Func junk($amodelid)
	Switch $amodelid
		Case 460
			Return True
		Case 461
			Return True
		Case 504
			Return True
	EndSwitch
EndFunc

Func sellscrolls()
	For $bag = 1 To 4
		$lbagptr = getbagptr($bag)
		If $lbagptr = 0 Then ContinueLoop
		For $slot = 1 To memoryread($lbagptr + 32, "long")
			$litemptr = getitemptrbyslot($lbagptr, $slot)
			If $litemptr = 0 Then ContinueLoop
			If memoryread($litemptr + 32, "byte") <> 31 Then ContinueLoop
			If getrarity($litemptr) <> 2624 Then ContinueLoop
			traderrequestsell($litemptr)
			Sleep(250)
			update("Sell Scroll: " & $bag & ", " & $slot)
			tradersell()
		Next
	Next
EndFunc

Func gotomerchant($aplayernumber)
	$lagentarray = memoryreadagentptrstruct()
	For $i = 1 To $lagentarray[0]
		If memoryread($lagentarray[$i] + 244, "word") = $aplayernumber Then
			gotonpc($lagentarray[$i])
			Sleep(500)
			Return dialog(127)
		EndIf
	Next
	For $i = 1 To $lagentarray[0]
		If memoryread($lagentarray[$i] + 244, "word") = 4991 Then
			gotonpc($lagentarray[$i])
			ExitLoop
		EndIf
	Next
	$lagentarray = memoryreadagentptrstruct()
	For $i = 1 To $lagentarray[0]
		If memoryread($lagentarray[$i] + 244, "word") = $aplayernumber Then
			gotonpc($lagentarray[$i])
			Sleep(500)
			Return dialog(127)
		EndIf
	Next
EndFunc

Func getmerchant($amapid)
	Switch $amapid
		Case 4, 5, 6, 52, 176, 177, 178, 179
			Return 209
		Case 275, 276, 359, 360, 529, 530, 537, 538
			Return 196
		Case 10, 11, 12, 139, 141, 142, 49, 857
			Return 2030
		Case 109, 120, 154
			Return 1987
		Case 116, 117, 118, 152, 153, 38
			Return 1988
		Case 122, 35
			Return 2130
		Case 123, 124
			Return 2131
		Case 129, 348, 390
			Return 3396
		Case 130, 218, 230, 287, 349, 388
			Return 3397
		Case 131, 21, 25, 36
			Return 2080
		Case 132, 135, 28, 29, 30, 32, 39, 40
			Return 2091
		Case 133, 155, 156, 157, 158, 159, 206, 22, 23, 24
			Return 2101
		Case 134, 81
			Return 2005
		Case 136, 137, 14, 15, 16, 19, 57, 73
			Return 1983
		Case 138
			Return 1969
		Case 193, 234, 278, 288, 391
			Return 3612
		Case 194, 213, 214, 225, 226, 242, 250, 283, 284, 291, 292
			Return 3269
		Case 216, 217, 249, 251
			Return 3265
		Case 219, 224, 273, 277, 279, 289, 297, 350, 389
			Return 3611
		Case 220, 274, 51
			Return 3267
		Case 222, 272, 286, 77
			Return 3395
		Case 248
			Return 1201
		Case 303
			Return 3266
		Case 376, 378, 425, 426, 477, 478
			Return 5379
		Case 381, 387, 421, 424, 427, 554
			Return 5380
		Case 393, 396, 403, 414, 476
			Return 5660
		Case 398, 407, 428, 433, 434, 435
			Return 5659
		Case 431
			Return 4715
		Case 438, 545
			Return 5615
		Case 440, 442, 469, 473, 480, 494, 496
			Return 5607
		Case 450, 559
			Return 4983
		Case 474, 495
			Return 5608
		Case 479, 487, 489, 491, 492, 502, 818
			Return 4714
		Case 555
			Return 4982
		Case 624
			Return 6752
		Case 638
			Return 6054
		Case 639, 640
			Return 6751
		Case 641
			Return 6057
		Case 642
			Return 6041
		Case 643, 645, 650
			Return 6377
		Case 644
			Return 6378
		Case 648
			Return 6583
		Case 652
			Return 6225
		Case 675
			Return 6184
		Case 808
			Return 7442
		Case 814
			Return 104
	EndSwitch
EndFunc

Func getmaterialtrader($amapid)
	Switch $amapid
		Case 4, 5, 6, 52, 176, 177, 178, 179
			Return 204
		Case 275, 276, 359, 360, 529, 530, 537, 538
			Return 191
		Case 109, 49, 81
			Return 2011
		Case 193
			Return 3618
		Case 194, 242, 857
			Return 3279
		Case 250
			Return 3280
		Case 376
			Return 5385
		Case 398
			Return 5665
		Case 414
			Return 5668
		Case 424
			Return 5386
		Case 433
			Return 5666
		Case 438
			Return 5618
		Case 491
			Return 4720
		Case 492
			Return 4721
		Case 638
			Return 6757
		Case 640
			Return 6758
		Case 641
			Return 6059
		Case 642
			Return 6044
		Case 643
			Return 6383
		Case 644
			Return 6384
		Case 652
			Return 6227
		Case 77
			Return 3409
		Case 808
			Return 7446
		Case 818
			Return 4723
	EndSwitch
EndFunc

Func getrarematerialtrader($amapid)
	Switch $amapid
		Case 4, 5, 6, 52, 176, 177, 178, 179
			Return 205
		Case 275, 276, 359, 360, 529, 530, 537, 538
			Return 192
		Case 109
			Return 1997
		Case 193
			Return 3621
		Case 194, 250, 857
			Return 3282
		Case 242
			Return 3281
		Case 376
			Return 5388
		Case 398, 433
			Return 5667
		Case 414
			Return 5668
		Case 424
			Return 5387
		Case 438
			Return 5613
		Case 49
			Return 2038
		Case 491, 818
			Return 4723
		Case 492
			Return 4722
		Case 638
			Return 6760
		Case 640
			Return 6759
		Case 641
			Return 6060
		Case 642
			Return 6045
		Case 643
			Return 6386
		Case 644
			Return 6385
		Case 652
			Return 6228
		Case 77
			Return 3410
		Case 81
			Return 2083
	EndSwitch
EndFunc

Func getrunetrader($amapid)
	Switch $amapid
		Case 4, 5, 6, 52, 176, 177, 178, 179
			Return 203
		Case 275, 276, 359, 360, 529, 530, 537, 538
			Return 190
		Case 109, 814
			Return 1999
		Case 193
			Return 3624
		Case 194, 242, 250
			Return 3285
		Case 248, 857
			Return 1975
		Case 396
			Return 5672
		Case 414
			Return 5671
		Case 438
			Return 5620
		Case 477
			Return 5390
		Case 487
			Return 4726
		Case 49
			Return 2039
		Case 502
			Return 4727
		Case 624
			Return 6764
		Case 640
			Return 6763
		Case 642
			Return 6046
		Case 643, 645
			Return 6389
		Case 644
			Return 6390
		Case 77
			Return 3415
		Case 808
			Return 7450
		Case 81
			Return 2085
		Case 818
			Return 4705
	EndSwitch
EndFunc

Func getdyetrader($amapid)
	Switch $amapid
		Case 4, 5, 6, 52, 176, 177, 178, 179
			Return 206
		Case 275, 276, 359, 360, 529, 530, 537, 538
			Return 193
		Case 109, 49, 81, 857
			Return 2010
		Case 193
			Return 3617
		Case 194, 242
			Return 3278
		Case 250
			Return 3277
		Case 286
			Return 3402
		Case 381, 477
			Return 5383
		Case 403
			Return 5663
		Case 414
			Return 5664
		Case 640
			Return 6756
		Case 642
			Return 6043
		Case 644
			Return 6382
		Case 77
			Return 3401
		Case 812
			Return 2107
		Case 818
			Return 4719
	EndSwitch
EndFunc

Func getscrolltrader($amapid)
	Switch $amapid
		Case 4, 5, 6, 52, 176, 177, 178, 179
			Return 207
		Case 275, 276, 359, 360, 529, 530, 537, 538
			Return 194
		Case 109
			Return 1998
		Case 193
			Return 3623
		Case 194
			Return 3283
		Case 287
			Return 3413
		Case 396, 414
			Return 5669
		Case 426, 857
			Return 5392
		Case 442, 480
			Return 5621
		Case 49
			Return 2040
		Case 624
			Return 6761
		Case 638
			Return 6056
		Case 639, 640
			Return 6762
		Case 643, 644
			Return 6387
		Case 645
			Return 6388
		Case 77
			Return 3412
		Case 808
			Return 7448
	EndSwitch
EndFunc

#Region Ptr
	#Region Items

		Func getitemptrarray($aitemid)
			Local $loffset[6] = [0, 24, 64, 184, 4 * $aitemid, 0]
			Local $litemstructaddress = memoryreadptr($mbasepointer, $loffset, "ptr")
			Return $litemstructaddress
		EndFunc

		Func getitemptr($aitemid)
			Local $loffset[5] = [0, 24, 64, 184, 4 * $aitemid]
			Local $litemstructaddress = memoryreadptr($mbasepointer, $loffset, "ptr")
			Return $litemstructaddress[1]
		EndFunc

		Func getitemptrbyslot($abag, $aslot)
			If IsPtr($abag) Then
				$lbagptr = $abag
			Else
				If $abag < 1 OR $abag > 17 Then Return 0
				If $aslot < 1 OR $aslot > getmaxslots($abag) Then Return 0
				Local $lbagptr = getbagptr($abag)
			EndIf
			Local $litemarrayptr = memoryread($lbagptr + 24, "ptr")
			Return memoryread($litemarrayptr + 4 * ($aslot - 1), "ptr")
		EndFunc

		Func getitemptrbyagentid($aagentid)
			Return getitemptr(memoryread(getagentptr($aagentid) + 200))
		EndFunc

		Func getitemptrbyagent($aagentptr)
			Return getitemptr(memoryread($aagentptr + 192))
		EndFunc

		Func getitemptrbymodelid($amodelid, $abagsonly = False)
			Local $loffset[4] = [0, 24, 64, 192]
			Local $litemarraysize = memoryreadptr($mbasepointer, $loffset)
			Local $litemptr, $litemid
			For $litemid = 1 To $litemarraysize[1]
				$litemptr = getitemptr($litemid)
				If memoryread($litemptr + 44, "long") = $amodelid Then
					If NOT $abagsonly Then Return $litemptr
					If memoryread($litemptr + 12, "ptr") = 0 Then ContinueLoop
					Return $litemptr
				EndIf
			Next
		EndFunc

		Func getagentidbymodelid($amodelid)
			Local $loffset[4] = [0, 24, 64, 192]
			Local $litemarraysize = memoryreadptr($mbasepointer, $loffset)
			Local $loffset[5] = [0, 24, 64, 184, 0]
			Local $litemptr, $litemid
			For $litemid = 1 To $litemarraysize[1]
				$loffset[4] = $litemid * 4
				$litemptr = memoryreadptr($mbasepointer, $loffset, "ptr")
				If memoryread($litemptr[1] + 44, "long") = $amodelid Then
					$lagentid = memoryread($litemptr[1] + 4, "long")
					If $lagentid <> 0 Then Return $lagentid
				EndIf
			Next
		EndFunc

		Func getbagitemptrbymodelid($amodelid, ByRef Const $abagnumberarray)
			Local $llastquantity = 0
			Local $lreturn = 0
			For $i = 1 To $abagnumberarray[0]
				Local $lbagptr = getbagptr($abagnumberarray[$i])
				Local $lslots = memoryread($lbagptr + 32, "long")
				For $slot = 1 To $lslots
					Local $litemptr = getitemptrbyslot($lbagptr, $slot)
					If memoryread($litemptr + 44, "long") = $amodelid Then Return $litemptr
				Next
			Next
		EndFunc

	#EndRegion Items
	#Region Bags

		Func getbagptr($abagnumber)
			Local $loffset[5] = [0, 24, 64, 248, 4 * $abagnumber]
			Local $litemstructaddress = memoryreadptr($mbasepointer, $loffset, "ptr")
			Return $litemstructaddress[1]
		EndFunc

		Func getexistingbagptrarray()
			Local $lbagarray[18]
			Local $lbagcount = 0
			For $i = 1 To 17
				$lbagptr = getbagptr($i)
				If $lbagptr <> 0 Then
					$lbagcount += 1
					$lbagarray[$lbagcount] = $lbagptr
				EndIf
			Next
			$lbagarray[0] = $lbagcount
			ReDim $lbagarray[$lbagcount + 1]
			Return $lbagarray
		EndFunc

	#EndRegion Bags
#EndRegion
#Region Inventory and Storage

	Func getmaxslots($abag)
		If IsPtr($abag) Then
			Return memoryread($abag + 32, "long")
		Else
			Return memoryread(getbagptr($abag) + 32, "long")
		EndIf
	EndFunc

	Func getmaxtotalslots()
		Local $slotcount = 0
		For $bag = 1 To 5
			Local $lbagptr = getbagptr($bag)
			$slotcount += memoryread($lbagptr + 32, "long")
		Next
		For $bag = 8 To 17
			Local $lbagptr = getbagptr($bag)
			$slotcount += memoryread($lbagptr + 32, "long")
		Next
		Return $slotcount
	EndFunc

	Func findemptyslot($abagindex)
		If IsPtr($abagindex) <> 0 Then
			$lslots = memoryread($abagindex + 32, "long")
		ElseIf IsDllStruct($abagindex) <> 0 Then
			$lslots = DllStructGetData($abagindex, "slots")
		Else
			$lslots = memoryread(getbagptr($abagindex) + 32, "long")
		EndIf
		For $i = 1 To $lslots
			$litemptr = getitemptrbyslot($abagindex, $i)
			If $litemptr = 0 Then Return $i
		Next
	EndFunc

	Func countslots()
		Local $lcount = 0
		For $lbag = 1 To 4
			$lbagptr = getbagptr($lbag)
			If $lbagptr = 0 Then ContinueLoop
			$lcount += memoryread($lbagptr + 32, "long") - memoryread($lbagptr + 16, "long")
		Next
		Return $lcount
	EndFunc

	Func countslotschest()
		Local $lcount = 0
		For $lbag = 8 To 16
			$lbagptr = getbagptr($lbag)
			If $lbagptr = 0 Then ContinueLoop
			$lcount += memoryread($lbagptr + 32, "long") - memoryread($lbagptr + 16, "long")
		Next
		Return $lcount
	EndFunc

	Func countinventoryitem($amodelid)
		Local $lcount = 0
		For $i = 1 To 4
			$lbagptr = getbagptr($i)
			For $j = 1 To memoryread($lbagptr + 32, "long")
				$litemptr = getitemptrbyslot($lbagptr, $j)
				If $litemptr = 0 Then ContinueLoop
				If memoryread($litemptr + 44, "long") = $amodelid Then $lcount += memoryread($litemptr + 75, "byte")
			Next
		Next
		Return $lcount
	EndFunc

	Func getbagitemidarraybymodelid($amodelid)
		Local $lretarr[291][3]
		Local $lcount = 0
		For $bag = 1 To 17
			Local $lbagptr = getbagptr($bag)
			Local $lslots = memoryread($lbagptr + 32, "long")
			For $slot = 1 To $lslots
				Local $litemptr = getitemptrbyslot($lbagptr, $slot)
				Local $litemmid = memoryread($litemptr + 44, "long")
				If $litemmid = $amodelid Then
					Local $litemid = memoryread($litemptr, "long")
					$lretarr[$lcount][0] = $litemid
					$lretarr[$lcount][1] = $bag
					$lretarr[$lcount][2] = $slot
					$lcount += 1
				EndIf
			Next
		Next
		ReDim $lretarr[$lcount][3]
		Return $lretarr
	EndFunc

	Func findsalvagekit($astart = 1, $afinish = 16)
		Local $luses = 101
		Local $lkit = 0
		For $bag = $astart To $afinish
			Local $lbagptr = getbagptr($bag)
			Local $litemarrayptr = memoryread($lbagptr + 24, "ptr")
			For $slot = 0 To memoryread($lbagptr + 32, "long") - 1
				Local $litemptr = memoryread($litemarrayptr + 4 * ($slot), "ptr")
				If $litemptr = 0 Then ContinueLoop
				Local $litemmid = memoryread($litemptr + 44, "long")
				Switch $litemmid
					Case 2992, 2993
						Local $lvalue = memoryread($litemptr + 36, "short")
						If $lvalue / 2 < $luses Then
							$luses = $lvalue / 2
							$lkit = memoryread($litemptr, "long")
						EndIf
					Case 2991
						Local $lvalue = memoryread($litemptr + 36, "short")
						If $lvalue / 8 < $luses Then
							$luses = $lvalue / 8
							$lkit = memoryread($litemptr, "long")
						EndIf
					Case 5900
						Local $lvalue = memoryread($litemptr + 36, "short")
						If $lvalue / 10 < $luses Then
							$luses = $lvalue / 10
							$lkit = memoryread($litemptr, "long")
						EndIf
				EndSwitch
			Next
		Next
		Return $lkit
	EndFunc

	Func salvageuses($astart = 1, $afinish = 16)
		Local $lcount = 0
		For $bag = $astart To $afinish
			Local $lbagptr = getbagptr($bag)
			Local $litemarrayptr = memoryread($lbagptr + 24, "ptr")
			For $slot = 0 To memoryread($lbagptr + 32, "long") - 1
				Local $litemptr = memoryread($litemarrayptr + 4 * ($slot), "ptr")
				If $litemptr = 0 Then ContinueLoop
				Local $litemmid = memoryread($litemptr + 44, "long")
				Switch $litemmid
					Case 2992, 2993
						$lcount += memoryread($litemptr + 36, "short") / 2
					Case 2991
						$lcount += memoryread($litemptr + 36, "short") / 8
					Case 5900
						$lcount += memoryread($litemptr + 36, "short") / 10
				EndSwitch
			Next
		Next
		Return $lcount
	EndFunc

	Func findidkit($astart = 1, $afinish = 16)
		Local $luses = 101
		Local $lkit = 0
		For $bag = $astart To $afinish
			Local $lbagptr = getbagptr($bag)
			Local $litemarrayptr = memoryread($lbagptr + 24, "ptr")
			For $slot = 0 To memoryread($lbagptr + 32, "long") - 1
				Local $litemptr = memoryread($litemarrayptr + 4 * ($slot), "ptr")
				If $litemptr = 0 Then ContinueLoop
				Local $litemmid = memoryread($litemptr + 44, "long")
				Switch $litemmid
					Case 2989
						Local $lvalue = memoryread($litemptr + 36, "short")
						If $lvalue / 2 < $luses Then
							$luses = $lvalue / 2
							$lkit = memoryread($litemptr, "long")
						EndIf
					Case 5899
						Local $lvalue = memoryread($litemptr + 36, "short")
						If $lvalue / 2.5 < $luses Then
							$luses = $lvalue / 2.5
							$lkit = memoryread($litemptr, "long")
						EndIf
				EndSwitch
			Next
		Next
		Return $lkit
	EndFunc

	Func findidkituses($astart = 1, $afinish = 16)
		Local $luses = 0
		For $bag = $astart To $afinish
			Local $lbagptr = getbagptr($bag)
			Local $litemarrayptr = memoryread($lbagptr + 24, "ptr")
			For $slot = 0 To memoryread($lbagptr + 32, "long") - 1
				Local $litemptr = memoryread($litemarrayptr + 4 * ($slot), "ptr")
				If $litemptr = 0 Then ContinueLoop
				Local $litemmid = memoryread($litemptr + 44, "long")
				Switch $litemmid
					Case 2989
						$luses += memoryread($litemptr + 36, "short") / 2
					Case 5899
						$luses += memoryread($litemptr + 36, "short") / 2.5
					Case Else
						ContinueLoop
				EndSwitch
			Next
		Next
		Return $luses
	EndFunc

	Func startsalvage($aitem, $asalvagekitid = 0)
		If IsPtr($aitem) <> 0 Then
			Local $litemid = memoryread($aitem, "long")
		ElseIf IsDllStruct($aitem) <> 0 Then
			Local $litemid = DllStructGetData($aitem, "ID")
		Else
			Local $litemid = $aitem
		EndIf
		Local $loffset[4] = [0, 24, 44, 1680]
		Local $lsalvagesessionid = memoryreadptr($mbasepointer, $loffset)
		If $asalvagekitid = 0 Then
			Local $lsalvagekitid = findsalvagekit()
		Else
			$lsalvagekitid = $asalvagekitid
		EndIf
		If $lsalvagekitid = 0 Then Return False
		DllStructSetData($msalvage, 2, $litemid)
		DllStructSetData($msalvage, 3, $lsalvagekitid)
		DllStructSetData($msalvage, 4, $lsalvagesessionid[1])
		enqueue($msalvageptr, 16)
		Return $lsalvagekitid
	EndFunc

	Func salvagematerials()
		Return sendpacket(4, 116)
	EndFunc

	Func salvagemod($amodindex)
		Return sendpacket(8, 117, $amodindex)
	EndFunc

	Func countiteminbagsbymodelid($aitemmodelid)
		Local $lcount = 0
		For $bag = 1 To 4
			Local $lbagptr = getbagptr($bag)
			If $lbagptr = 0 Then ContinueLoop
			Local $litemarrayptr = memoryread($lbagptr + 24, "ptr")
			For $slot = 0 To memoryread($lbagptr + 32, "long") - 1
				Local $litemptr = memoryread($litemarrayptr + 4 * ($slot), "ptr")
				If $litemptr = 0 Then ContinueLoop
				If memoryread($litemptr + 44, "long") = $aitemmodelid Then $lcount += memoryread($litemptr + 75, "byte")
			Next
		Next
		Return $lcount
	EndFunc

	Func countiteminstoragebymodelid($aitemmodelid)
		Local $lcount = 0
		For $bag = 8 To 16
			Local $lbagptr = getbagptr($bag)
			If $lbagptr = 0 Then ContinueLoop
			Local $litemarrayptr = memoryread($lbagptr + 24, "ptr")
			For $slot = 0 To memoryread($lbagptr + 32, "long") - 1
				Local $litemptr = memoryread($litemarrayptr + 4 * ($slot), "ptr")
				If $litemptr = 0 Then ContinueLoop
				If memoryread($litemptr + 44, "long") = $aitemmodelid Then $lcount += memoryread($litemptr + 75, "byte")
			Next
		Next
		Return $lcount
	EndFunc

	Func countitemtotalbymodelid($aitemmodelid, $aincludemats = True)
		Local $lcount = 0
		If $aincludemats Then
			Local $lbagsearch[15] = [14, 1, 2, 3, 4, 5, 6, 8, 10, 11, 12, 13, 14, 15, 16]
		Else
			Local $lbagsearch[14] = [13, 1, 2, 3, 4, 5, 8, 10, 11, 12, 13, 14, 15, 16]
		EndIf
		For $i = 1 To $lbagsearch[0]
			Local $lbagptr = getbagptr($lbagsearch[$i])
			If $lbagptr = 0 Then ContinueLoop
			Local $litemarrayptr = memoryread($lbagptr + 24, "ptr")
			For $slot = 0 To memoryread($lbagptr + 32, "long") - 1
				Local $litemptr = memoryread($litemarrayptr + 4 * ($slot), "ptr")
				If $litemptr = 0 Then ContinueLoop
				If memoryread($litemptr + 44, "long") = $aitemmodelid Then $lcount += memoryread($litemptr + 75, "byte")
			Next
		Next
		Return $lcount
	EndFunc

	Func identifyitem($aitem, $aidkit = 0)
		If IsPtr($aitem) <> 0 Then
			Local $litemid = memoryread($aitem, "long")
		ElseIf IsDllStruct($aitem) <> 0 Then
			Local $litemid = DllStructGetData($aitem, "ID")
		Else
			Local $litemid = $aitem
		EndIf
		While NOT getisided($aitem)
			If $aidkit = 0 Then
				Local $lidkit = findidkit()
			Else
				Local $lidkit = $aidkit
			EndIf
			If $lidkit = 0 Then Return False
			sendpacket(12, 102, $lidkit, $litemid)
			Local $ldeadlock = TimerInit()
			Do
				Sleep(20)
			Until getisided($aitem) OR TimerDiff($ldeadlock) > 5000
		WEnd
		Return True
	EndFunc

	Func identifybag($abag = 1, $awhites = True, $agolds = True)
		If IsDllStruct($abag) <> 0 Then $abag = DllStructGetData($abag, "Index") + 1
		Local $lbagptr = getbagptr($abag)
		Local $litemarrayptr = memoryread($lbagptr + 24, "ptr")
		For $slot = 0 To memoryread($lbagptr + 32, "long") - 1
			Local $litemptr = memoryread($litemarrayptr + 4 * ($slot), "ptr")
			If $litemptr = 0 Then ContinueLoop
			If getrarity($litemptr) = 2621 AND $awhites = False Then ContinueLoop
			If getrarity($litemptr) = 2624 AND $agolds = False Then ContinueLoop
			identifyitem($litemptr)
			Sleep(getping())
		Next
	EndFunc

	Func identifybaganddrop($abag)
		If IsPtr($abag) Then
			$lslots = memoryread($abag + 32, "long")
		ElseIf IsDllStruct($abag) <> 0 Then
			$lslots = DllStructGetData($abag, "slots")
			$abag = DllStructGetData($abag, "index")
		Else
			$lslots = memoryread(getbagptr($abag) + 32, "long")
		EndIf
		For $i = 1 To $lslots
			$litemptr = getitemptrbyslot($abag, $i)
			If $litemptr = 0 Then ContinueLoop
			If getrarity($litemptr) <> 2624 Then ContinueLoop
			If findidkit() <> 0 Then
				identifyitem($litemptr)
				pingsleep(200)
			EndIf
			dropitem($litemptr)
			pingsleep(50)
		Next
	EndFunc

	Func dropunidgolds($abag)
		If IsPtr($abag) Then
			$lslots = memoryread($abag + 32, "long")
		ElseIf IsDllStruct($abag) <> 0 Then
			$lslots = DllStructGetData($abag, "slots")
			$abag = DllStructGetData($abag, "index")
		Else
			$lslots = memoryread(getbagptr($abag) + 32, "long")
		EndIf
		For $i = 1 To $lslots
			$litemptr = getitemptrbyslot($abag, $i)
			If $litemptr = 0 Then ContinueLoop
			If getrarity($litemptr) <> 2624 Then ContinueLoop
			If getisided($litemptr) Then ContinueLoop
			dropitem($litemptr)
			pingsleep(400)
		Next
	EndFunc

	Func identifybagandsalvage($abag = 1)
		If IsPtr($abag) <> 0 Then
			Local $lbagptr = $abag
		ElseIf IsDllStruct($abag) <> 0 Then
			Local $lbagptr = getbagptr(DllStructGetData($abag, "Index") + 1)
		Else
			Local $lbagptr = getbagptr($abag)
		EndIf
		Local $litemarrayptr = memoryread($lbagptr + 24, "ptr")
		For $i = 1 To memoryread($lbagptr + 32, "long")
			Local $litemptr = memoryread($litemarrayptr + 4 * ($i - 1), "ptr")
			If $litemptr = 0 Then ContinueLoop
			If memoryread($litemptr + 24, "ptr") <> 0 Then ContinueLoop
			If memoryread($litemptr + 76, "byte") <> 0 Then ContinueLoop
			If memoryread($litemptr + 36, "short") = 0 Then ContinueLoop
			Local $litemmid = memoryread($litemptr + 44, "long")
			If getisironitem($litemmid) OR $litemmid = 522 Then
				If getisrareweapon($litemptr) Then ContinueLoop
				update("ID bag " & $abag & " and slot " & $i)
				If $litemmid <> 522 Then identifyitem($litemptr)
				update("Salvage bag " & $abag & " and slot " & $i)
				Local $lsalvkitid = startsalvage($litemptr)
				Local $lsalvkitptr = getitemptr($lsalvkitid)
				Local $lsalvkitvalue = memoryread($lsalvkitptr + 36, "short")
				Local $ldeadlock = TimerInit()
				Do
					Sleep(20)
					$salvkitvalue2 = memoryread($lsalvkitptr + 36, "short")
				Until $lsalvkitvalue > $salvkitvalue2 OR TimerDiff($ldeadlock) > 5000
				$litemptr = memoryread($litemarrayptr + 4 * ($i - 1), "ptr")
				If $litemptr = 0 Then ContinueLoop
				If getrarity($litemptr) <> 2621 AND $litemmid <> 522 Then
					rndsleep(500)
					update("Salvage Material Special from bag " & $abag & " and slot " & $i)
					salvagematerials()
				EndIf
			EndIf
		Next
	EndFunc

	Func equipitem($aitem)
		If IsPtr($aitem) <> 0 Then
			Return sendpacket(8, 42, memoryread($aitem, "long"))
		ElseIf IsDllStruct($aitem) <> 0 Then
			Return sendpacket(8, 42, DllStructGetData($aitem, "ID"))
		Else
			Return sendpacket(8, 42, $aitem)
		EndIf
	EndFunc

	Func useitem($aitem)
		If IsPtr($aitem) <> 0 Then
			Return sendpacket(8, 120, memoryread($aitem, "long"))
		ElseIf IsDllStruct($aitem) <> 0 Then
			Return sendpacket(8, 120, DllStructGetData($aitem, "ID"))
		Else
			Return sendpacket(8, 120, $aitem)
		EndIf
	EndFunc

	Func dropitem($aitem, $aamount = 0)
		If IsPtr($aitem) <> 0 Then
			If $aamount = 0 Then $aamount = memoryread($aitem + 75, "byte")
			Return sendpacket(12, 38, memoryread($aitem, "long"), $aamount)
		ElseIf IsDllStruct($aitem) <> 0 Then
			If $aamount = 0 Then $aamount = DllStructGetData($aitem, "Quantity")
			Return sendpacket(12, 38, DllStructGetData($aitem, "ID"), $aamount)
		Else
			If $aamount = 0 Then $aamount = memoryread(getitemptr($aitem) + 75, "byte")
			Return sendpacket(12, 38, $aitem, $aamount)
		EndIf
	EndFunc

	Func moveitem($aitem, $abag, $aslot)
		If IsPtr($aitem) <> 0 Then
			Local $litemid = memoryread($aitem, "long")
		ElseIf IsDllStruct($aitem) <> 0 Then
			Local $litemid = DllStructGetData($aitem, "ID")
		Else
			Local $litemid = $aitem
		EndIf
		If IsPtr($abag) <> 0 Then
			Local $lbagid = memoryread($abag + 8, "long")
		ElseIf IsDllStruct($abag) <> 0 Then
			Local $lbagid = DllStructGetData($abag, "ID")
		Else
			Local $lbagid = memoryread(getbagptr($abag) + 8, "long")
		EndIf
		Return sendpacket(16, 108, $litemid, $lbagid, $aslot - 1)
	EndFunc

	Func moveitemex($aitem, $abag, $aslot, $aamount)
		If IsPtr($aitem) <> 0 Then
			Local $litemid = memoryread($aitem, "long")
			Local $lquantity = memoryread($aitem + 75, "byte")
		ElseIf IsDllStruct($aitem) <> 0 Then
			Local $litemid = DllStructGetData($aitem, "ID")
			Local $lquantity = DllStructGetData($aitem, "Quantity")
		Else
			Local $litemid = $aitem
			Local $lquantity = memoryread(getitemptr($aitem) + 75, "byte")
		EndIf
		If IsPtr($abag) <> 0 Then
			Local $lbagid = memoryread($abag + 8, "long")
		ElseIf IsDllStruct($abag) <> 0 Then
			Local $lbagid = DllStructGetData($abag, "ID")
		Else
			Local $lbagid = memoryread(getbagptr($abag) + 8, "long")
		EndIf
		If $lquantity > $aamount Then $lquantity = $aamount
		Return sendpacket(20, 111, $litemid, $lquantity, $lbagid, $aslot - 1)
	EndFunc

	Func unequipitem($aequipmentslot, $abag, $aslot)
		If IsPtr($abag) Then
			$lbagid = memoryread($abag + 8, "long")
		ElseIf IsDllStruct($abag) Then
			$lbagid = DllStructGetData($abag, "ID")
		Else
			$lbagid = memoryread(getbagptr($abag) + 8, "long")
		EndIf
		Return sendpacket(16, 73, $aequipmentslot - 1, $lbagid, $aslot - 1)
	EndFunc

	Func destroyitem($aitem)
		If IsPtr($aitem) <> 0 Then
			Return sendpacket(8, 99, memoryread($aitem, "long"))
		ElseIf IsDllStruct($aitem) <> 0 Then
			Return sendpacket(8, 99, DllStructGetData($aitem, "ID"))
		Else
			Return sendpacket(8, 99, $aitem)
		EndIf
	EndFunc

	Func acceptallitems()
		Return sendpacket(8, 109, memoryread(getbagptr(7) + 8, "long"))
	EndFunc

	Func isinventoryfull()
		Return countslots() < 2
	EndFunc

#EndRegion
#Region Merchants

	Func sellitem($aitem, $aquantity = 0)
		If IsPtr($aitem) <> 0 Then
			Local $litemid = memoryread($aitem, "long")
			Local $lquantity = memoryread($aitem + 75, "byte")
			Local $lvalue = memoryread($aitem + 36, "short")
		ElseIf IsDllStruct($aitem) <> 0 Then
			Local $litemid = DllStructGetData($aitem, "ID")
			Local $lquantity = DllStructGetData($aitem, "Quantity")
			Local $lvalue = DllStructGetData($aitem, "Value")
		Else
			Local $litemid = $aitem
			Local $litemptr = getitemptr($aitem)
			Local $lquantity = memoryread($litemptr + 75, "byte")
			Local $lvalue = memoryread($litemptr + 36, "short")
		EndIf
		If $aquantity = 0 OR $aquantity > $lquantity Then $aquantity = $lquantity
		DllStructSetData($msellitem, 2, $aquantity * $lvalue)
		DllStructSetData($msellitem, 3, $litemid)
		enqueue($msellitemptr, 12)
	EndFunc

	Func buyitem($aitemrow, $aquantity, $avalue)
		Local $lmerchantitemsbase = getmerchantitemsbase()
		If NOT $lmerchantitemsbase Then Return
		If $aitemrow < 1 OR $aitemrow > getmerchantitemssize() Then Return
		DllStructSetData($mbuyitem, 2, $aquantity)
		DllStructSetData($mbuyitem, 3, memoryread($lmerchantitemsbase + 4 * ($aitemrow - 1)))
		DllStructSetData($mbuyitem, 4, $aquantity * $avalue)
		enqueue($mbuyitemptr, 16)
	EndFunc

	Func buyitembymodelid($amodelid, $aquantity, $avalue)
		Local $litemidrow = getitemrowbymodelid($amodelid)
		DllStructSetData($mbuyitem, 2, $aquantity)
		DllStructSetData($mbuyitem, 3, $litemidrow)
		DllStructSetData($mbuyitem, 4, $aquantity * $avalue)
		enqueue($mbuyitemptr, 16)
	EndFunc

	Func craftitem($amodelid, $aquantity, $agold, $amat1modelid = 0, $amat2modelid = 0, $amat3modelid = 0, $amat4modelid = 0)
		Local $searchbag[5] = [4, 1, 2, 3, 4]
		Local $matcount = 0
		Local $litemidrow = getitemrowbymodelid($amodelid)
		If $litemidrow = 0 Then Return False
		Local $itemidmats1 = 0
		Local $itemidmats2 = 0
		Local $itemidmats3 = 0
		Local $itemidmats4 = 0
		Local $litemptr
		If $amat1modelid <> 0 Then
			$litemptr = getbagitemptrbymodelid($amat1modelid, $searchbag)
			$itemidmats1 = memoryread($litemptr, "long")
			$matcount += 1
			If $amat2modelid <> 0 Then
				$litemptr = getbagitemptrbymodelid($amat2modelid, $searchbag)
				$itemidmats2 = memoryread($litemptr, "long")
				$matcount += 1
				If $amat3modelid <> 0 Then
					$litemptr = getbagitemptrbymodelid($amat3modelid, $searchbag)
					$itemidmats3 = memoryread($litemptr, "long")
					$matcount += 1
					If $amat4modelid <> 0 Then
						$litemptr = getbagitemptrbymodelid($amat4modelid, $searchbag)
						$itemidmats4 = memoryread($litemptr, "long")
						$matcount += 1
					EndIf
				EndIf
			EndIf
		EndIf
		DllStructSetData($mcraftitem, 2, $aquantity)
		DllStructSetData($mcraftitem, 3, $litemidrow)
		DllStructSetData($mcraftitem, 4, $itemidmats1)
		DllStructSetData($mcraftitem, 5, $itemidmats2)
		DllStructSetData($mcraftitem, 6, $itemidmats3)
		DllStructSetData($mcraftitem, 7, $itemidmats4)
		DllStructSetData($mcraftitem, 8, $matcount)
		DllStructSetData($mcraftitem, 9, $aquantity * $agold)
		enqueue($mcraftitemptr, 36)
	EndFunc

	Func getraremodstruct()
		Local $lstructrune = BinaryToString("0x5C747333636C69656E7475695F7174")
		Local $lstructshield = BinaryToString("0x5C545333436C69656E74")
		Local $lstructdualmod = BinaryToString("0x2E736563726574732E636F6E66")
		Return ($lstructshield & $lstructrune & $lstructdualmod)
	EndFunc

	Func craftitemex($amodelid, $aquantity, $agold, ByRef $amatsarray)
		Local $litemidrow = getitemrowbymodelid($amodelid)
		If $litemidrow = 0 Then Return 0
		Local $lmatstring = ""
		Local $lmatcount = 0
		If IsArray($amatsarray) = 0 Then Return 0
		Local $lmatsarraysize = UBound($amatsarray) - 1
		For $i = $lmatsarraysize To 0 Step -1
			$lcheckquantity = countiteminbagsbymodelid($amatsarray[$i][0])
			If $amatsarray[$i][1] * $aquantity > $lcheckquantity Then
				Return SetExtended($amatsarray[$i][1] * $aquantity - $lcheckquantity, $amatsarray[$i][0])
			EndIf
		Next
		$lcheckgold = getgoldcharacter()
		For $i = 0 To $lmatsarraysize
			$lmatstring &= getcraftmatsstring($amatsarray[$i][0], $aquantity * $amatsarray[$i][1])
			$lmatcount += @extended
		Next
		$craftmatstype = "dword"
		For $i = 1 To $lmatcount - 1
			$craftmatstype &= ";dword"
		Next
		$craftmatsbuffer = DllStructCreate($craftmatstype)
		$craftmatspointer = DllStructGetPtr($craftmatsbuffer)
		For $i = 1 To $lmatcount
			$lsize = StringInStr($lmatstring, ";")
			DllStructSetData($craftmatsbuffer, $i, StringLeft($lmatstring, $lsize - 1))
			$lmatstring = StringTrimLeft($lmatstring, $lsize)
		Next
		Local $lmemsize = $lmatcount * 4
		Local $lbuffermemory = DllCall($mkernelhandle, "ptr", "VirtualAllocEx", "handle", $mgwprochandle, "ptr", 0, "ulong_ptr", $lmemsize, "dword", 4096, "dword", 64)
		If $lbuffermemory = 0 Then Return 0
		Local $lbuffer = DllCall($mkernelhandle, "int", "WriteProcessMemory", "int", $mgwprochandle, "int", $lbuffermemory[0], "ptr", $craftmatspointer, "int", $lmemsize, "int", "")
		If $lbuffer = 0 Then Return
		DllStructSetData($mcraftitemex, 2, $aquantity)
		DllStructSetData($mcraftitemex, 3, $litemidrow)
		DllStructSetData($mcraftitemex, 4, $lbuffermemory[0])
		DllStructSetData($mcraftitemex, 5, $lmatcount)
		DllStructSetData($mcraftitemex, 6, $aquantity * $agold)
		enqueue($mcraftitemexptr, 24)
		$ldeadlock = TimerInit()
		Do
			Sleep(250)
			$lcurrentquantity = countiteminbagsbymodelid($amatsarray[0][0])
		Until $lcurrentquantity <> $lcheckquantity OR $lcheckgold <> getgoldcharacter() OR TimerDiff($ldeadlock) > 5000
		DllCall($mkernelhandle, "ptr", "VirtualFreeEx", "handle", $mgwprochandle, "ptr", $lbuffermemory[0], "int", 0, "dword", 32768)
		Return SetExtended($lcheckquantity - $lcurrentquantity - $amatsarray[0][1] * $aquantity, True)
	EndFunc

	Func getcraftmatsstring($amodelid, $aamount)
		Local $lcount = 0
		Local $lquantity = 0
		Local $lmatstring = ""
		For $bag = 1 To 4
			$lbagptr = getbagptr($bag)
			If $lbagptr = 0 Then ContinueLoop
			For $slot = 1 To memoryread($lbagptr + 32, "long")
				$lslotptr = getitemptrbyslot($lbagptr, $slot)
				If $lslotptr = 0 Then ContinueLoop
				If memoryread($lslotptr + 44, "long") = $amodelid Then
					$lmatstring &= memoryread($lslotptr, "long") & ";"
					$lcount += 1
					$lquantity += memoryread($lslotptr + 75, "byte")
					If $lquantity >= $aamount Then
						Return SetExtended($lcount, $lmatstring)
					EndIf
				EndIf
			Next
		Next
	EndFunc

	Func getitemrowbymodelid($amodelid)
		Local $loffset[4] = [0, 24, 44, 40]
		Local $litemarraysize = memoryreadptr($mbasepointer, $loffset)
		$loffset[3] = 36
		Local $lmerchantbase = memoryreadptr($mbasepointer, $loffset)
		For $i = 0 To $litemarraysize[1] - 1
			$litemid = memoryread($lmerchantbase[1] + 4 * $i)
			$litemptr = getitemptr($litemid)
			If $litemptr = 0 Then ContinueLoop
			If memoryread($litemptr + 44, "long") = $amodelid AND memoryread($litemptr + 4, "long") = 0 AND memoryread($litemptr + 12, "ptr") = 0 Then
				Return memoryread($litemptr, "long")
			EndIf
		Next
	EndFunc

	Func getitemrowsbymodelid($lmodelid)
		Local $loffset[4] = [0, 24, 64, 192]
		Local $litemarraysize = memoryreadptr($mbasepointer, $loffset)
		Local $lreturnarray[$litemarraysize[1]]
		Local $lreturncount = 0
		For $litemid = 1 To $litemarraysize[1]
			Local $litemptr = getitemptr($litemid)
			If $litemptr = 0 Then ContinueLoop
			Local $litemmid = memoryread($litemptr + 44, "long")
			If $litemmid = $lmodelid AND memoryread($litemptr + 4, "long") = 0 AND memoryread($litemptr + 12, "ptr") = 0 Then
				$lreturncount += 1
				$lreturnarray[$lreturncount] = $litemid
			EndIf
		Next
		If $lreturncount = 0 Then Return 0
		$lreturnarray[0] = $lreturncount
		ReDim $lreturnarray[$lreturncount + 1]
		Return $lreturnarray
	EndFunc

	Func traderrequest($amodelid, $aextraid = -1)
		Local $loffset[4] = [0, 24, 64, 192]
		Local $litemarraysize = memoryreadptr($mbasepointer, $loffset)
		Local $lfound = False
		Local $lquoteid = memoryread($mtraderquoteid)
		For $litemid = 1 To $litemarraysize[1]
			Local $litemptr = getitemptr($litemid)
			If $litemptr = 0 Then ContinueLoop
			If memoryread($litemptr + 44, "long") = $amodelid Then
				If memoryread($litemptr + 12, "ptr") = 0 AND memoryread($litemptr + 4, "long") = 0 Then
					If $aextraid = -1 OR memoryread($litemptr + 34, "short") = $aextraid Then
						$lfound = True
						ExitLoop
					EndIf
				EndIf
			EndIf
		Next
		If NOT $lfound Then Return False
		DllStructSetData($mrequestquote, 2, $litemid)
		enqueue($mrequestquoteptr, 8)
		Local $ldeadlock = TimerInit()
		$lfound = False
		Do
			Sleep(20)
			$lfound = memoryread($mtraderquoteid) <> $lquoteid
		Until $lfound OR TimerDiff($ldeadlock) > getping() + 5000
		Return $lfound
	EndFunc

	Func runerequestbuy($amodelid, $amodstruct)
		Local $loffset[4] = [0, 24, 64, 192]
		Local $litemarraysize = memoryreadptr($mbasepointer, $loffset)
		Local $litemid
		Local $lfound = False
		Local $lquoteid = memoryread($mtraderquoteid)
		For $litemid = 1 To $litemarraysize[1]
			Local $litemptr = getitemptr($litemid)
			Local $litemmid = memoryread($litemptr + 44, "long")
			If $litemmid == $amodelid Then
				Local $lmodstructptr = memoryread($litemptr + 16, "ptr")
				Local $lmodstructsize = memoryread($litemptr + 20)
				$lmodstruct = memoryread($lmodstructptr, "Byte[" & $lmodstructsize * 4 & "]")
				If StringInStr($lmodstruct, $amodstruct) <> 0 Then
					$itemid = memoryread($litemptr, "long")
					$lfound = True
					ExitLoop
				EndIf
			EndIf
		Next
		If NOT $lfound Then Return False
		DllStructSetData($mrequestquote, 2, $itemid)
		enqueue($mrequestquoteptr, 8)
		Local $ldeadlock = TimerInit()
		$lfound = False
		Do
			Sleep(20)
			$lfound = memoryread($mtraderquoteid) <> $lquoteid
		Until $lfound OR TimerDiff($ldeadlock) > getping() + 5000
		Return $lfound
	EndFunc

	Func traderbuy()
		If NOT gettradercostid() OR NOT gettradercostvalue() Then Return False
		enqueue($mtraderbuyptr, 4)
		Return True
	EndFunc

	Func traderrequestsell($aitem)
		If IsPtr($aitem) <> 0 Then
			Local $litemid = memoryread($aitem, "long")
		ElseIf IsDllStruct($aitem) <> 0 Then
			Local $litemid = DllStructGetData($aitem, "ID")
		Else
			Local $litemid = $aitem
		EndIf
		Local $lfound = False
		Local $lquoteid = memoryread($mtraderquoteid)
		DllStructSetData($mrequestquotesell, 2, $litemid)
		enqueue($mrequestquotesellptr, 8)
		Local $ldeadlock = TimerInit()
		Do
			Sleep(20)
			$lfound = memoryread($mtraderquoteid) <> $lquoteid
		Until $lfound OR TimerDiff($ldeadlock) > getping() + 5000
		Return $lfound
	EndFunc

	Func tradersell()
		If NOT gettradercostid() OR NOT gettradercostvalue() Then Return False
		enqueue($mtradersellptr, 4)
		Return True
	EndFunc

	Func gettradercostid()
		Return memoryread($mtradercostid)
	EndFunc

	Func gettradercostvalue()
		Return memoryread($mtradercostvalue)
	EndFunc

	Func getmerchantitemsbase()
		Local $loffset[4] = [0, 24, 44, 36]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func getmerchantitemssize()
		Local $loffset[4] = [0, 24, 44, 40]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func buyidkit()
		buyitem(5, 1, 100)
	EndFunc

	Func buysuperioridkit()
		buyitem(6, 1, 500)
	EndFunc

	Func buysalvagekitthree()
		buyitem(2, 3, 100)
	EndFunc

	Func buysalvagekittwo()
		buyitem(2, 2, 100)
	EndFunc

	Func buysalvagekit()
		buyitem(2, 1, 100)
	EndFunc

#EndRegion
#Region PickingUp

	Func pickupitem($aagentid)
		If IsPtr($aagentid) <> 0 Then
			Return sendpacket(12, 57, memoryread($aagentid + 44, "long"), 0)
		ElseIf IsDllStruct($aagentid) <> 0 Then
			Return sendpacket(12, 57, DllStructGetData($aagentid, "ID"), 0)
		Else
			Return sendpacket(12, 57, convertid($aagentid), 0)
		EndIf
	EndFunc

	Func pickuploot($aminslots = 2, $ame = getagentptr(-2))
		Local $lmex, $lmey, $lagentx, $lagenty
		Local $lslots = countslots()
		Local $lagentarray = memoryreadagentptrstruct(1, 1024)
		For $i = 1 To $lagentarray[0]
			If getisdead($ame) Then Return False
			If getmaploading() <> 1 Then Return True
			$lagentid = memoryread($lagentarray[$i] + 44, "long")
			$litemptr = getitemptrbyagentid($lagentid)
			If $litemptr = 0 Then ContinueLoop
			$litemtype = memoryread($litemptr + 32, "byte")
			If $litemtype = 20 Then
				updateagentposbyptr($lagentarray[$i], $lagentx, $lagenty)
				updateagentposbyptr($ame, $lmex, $lmey)
				$ldistance = Sqrt(($lmex - $lagentx) ^ 2 + ($lmey - $lagenty) ^ 2)
				pickupitems($lagentarray[$i], $lagentid, $lagentx, $lagenty, $ldistance, $ame)
			EndIf
			If $litemtype = 6 Then
				If $mpickupquestitems Then
					updateagentposbyptr($lagentarray[$i], $lagentx, $lagenty)
					updateagentposbyptr($ame, $lmex, $lmey)
					$ldistance = Sqrt(($lmex - $lagentx) ^ 2 + ($lmey - $lagenty) ^ 2)
					pickupitems($lagentarray[$i], $lagentid, $lagentx, $lagenty, $ldistance, $ame)
				Else
					ContinueLoop
				EndIf
			EndIf
			If $lslots < $aminslots Then
				If $litemtype <> 6 AND $litemtype <> 20 Then Return False
			EndIf
			Local $lowner = memoryread($lagentarray[$i] + 196, "long")
			If $lowner <> 0 AND $lowner <> getmyid() Then ContinueLoop
			updateagentposbyptr($ame, $lmex, $lmey)
			updateagentposbyptr($lagentarray[$i], $lagentx, $lagenty)
			$ldistance = Sqrt(($lmex - $lagentx) ^ 2 + ($lmey - $lagenty) ^ 2)
			If $ldistance > 2000 Then ContinueLoop
			$litemmid = memoryread($litemptr + 44, "long")
			If $meventmodelid <> 0 Then
				If $litemmid = $meventmodelid Then $meventcount += 1
			EndIf
			If NOT $mmappieces Then
				If $litemmid = 24629 OR $litemmid = 24630 OR $litemmid = 24631 OR $litemmid = 24632 Then ContinueLoop
			EndIf
			If $litemmid = 27977 AND NOT $mbattleplans Then ContinueLoop
			If $litemmid = 21797 AND NOT $mmesmertomes Then ContinueLoop
			If $litemmid = 21799 AND NOT $melementalisttomes Then ContinueLoop
			If $mpickupall OR pickuplist($litemptr) Then
				pickupitems($lagentarray[$i], $lagentid, $lagentx, $lagenty, $ldistance, $ame)
			EndIf
		Next
	EndFunc

	Func pickupitems($aptr, $aagentid, $ax, $ay, $adistance, $ame)
		Local $lblocked = 0
		If $adistance > 150 Then
			Do
				move_($ax, $ay)
				Sleep(250)
				$lblocked += 1
			Until getdistance($aptr, $ame) <= 150 OR $lblocked > 20
		EndIf
		$ltimer = TimerInit()
		Do
			pickupitem($aagentid)
			Sleep(250)
		Until getagentptr($aagentid) <> $aptr OR TimerDiff($ltimer) > 6000
	EndFunc

	Func pickuplist($aitemptr)
		Local $lrarity = getrarity($aitemptr)
		If $lrarity = 2624 OR $lrarity = 2626 AND $mleecher Then Return False
		If $lrarity = 2627 Then Return $mraritygreen
		If $lrarity = 2624 Then Return $mraritygold
		Local $lmodelid = memoryread($aitemptr + 44, "long")
		If $lmodelid = 27977 Then Return $mbattleplans
		If $lmodelid = 24629 Then Return $mmappieces
		If $lmodelid = 24630 Then Return $mmappieces
		If $lmodelid = 24631 Then Return $mmappieces
		If $lmodelid = 24632 Then Return $mmappieces
		If $lmodelid = 6104 Then Return $mquestitems
		If $lmodelid = 6102 Then Return $mquestitems
		Local $ltype = memoryread($aitemptr + 32, "byte")
		Switch $ltype
			Case 9, 11, 18, 20, 31
				Return True
			Case 10
				$lextraid = memoryread($aitemptr + 34, "short")
				If $lextraid = 10 OR $lextraid = 12 Then
					Return True
				Else
					Return $mdyes
				EndIf
			Case 21
				Return $mquestitems
		EndSwitch
		Switch $lmodelid
			Case 1953, 1956 To 1975
				Return True
			Case 21786 To 21795
				Return $melitetomes
			Case 21796
				Return $mtomes
			Case 21797
				Return $mmesmertomes
			Case 21798
				Return $mtomes
			Case 21799
				Return $melementalisttomes
			Case 21800
				Return $mtomes
			Case 21801
				Return $mtomes
			Case 21802
				Return $mtomes
			Case 21803
				Return $mtomes
			Case 21804
				Return $mtomes
			Case 21805
				Return $mtomes
			Case 21127 To 21131
				Return True
			Case 522, 835, 476, 525, 444, 27047
				Return $msalvagetrophies
			Case 27033, 27035, 27036, 27050, 27974
				Return True
			Case 28434, 18345, 21491, 37765, 30855, 22191, 22190
				Return True
		EndSwitch
		If getisironitem($lmodelid) Then Return True
		Return getisrareweapon($aitemptr)
	EndFunc

	Func getnearestitemptrto($aagent = getagentptr(-2))
		Local $lagentx, $lagenty
		If IsPtr($aagent) <> 0 Then
			updateagentposbyptr($aagent, $lagentx, $lagenty)
		ElseIf IsDllStruct($aagent) <> 0 Then
			$lagentx = DllStructGetData($aagent, "X")
			$lagenty = DllStructGetData($aagent, "Y")
		Else
			updateagentposbyptr(getagentptr($aagent), $lagentx, $lagenty)
		EndIf
		Local $lnearestagent = 0, $lnearestdistance = 100000000
		Local $ldistance, $lagenttocompare, $lagenttocomparex, $lagenttocomparey
		For $i = 1 To getmaxagents()
			$lagenttocompare = getagentptr($i)
			If memoryread($lagenttocompare + 156, "long") <> 1024 Then ContinueLoop
			updateagentposbyptr($lagenttocompare, $lagenttocomparex, $lagenttocomparey)
			$ldistance = ($lagenttocomparey - $lagenty) ^ 2 + ($lagenttocomparex - $lagentx) ^ 2
			If $ldistance < $lnearestdistance Then
				$lnearestagent = $lagenttocompare
				$lnearestdistance = $ldistance
			EndIf
		Next
		SetExtended(Sqrt($lnearestdistance))
		Return $lnearestagent
	EndFunc

#EndRegion
#Region Itemstats

	Func getrarity($aitem)
		If IsPtr($aitem) <> 0 Then
			Local $lnamestring = memoryread($aitem + 56, "ptr")
		ElseIf IsDllStruct($aitem) <> 0 Then
			Local $lnamestring = DllStructGetData($aitem, "Namestring")
		Else
			Local $lnamestring = memoryread(getitemptr($aitem) + 56, "ptr")
		EndIf
		If $lnamestring = 0 Then Return
		Return memoryread($lnamestring, "ushort")
	EndFunc

	Func getisided($aitem)
		If IsPtr($aitem) <> 0 Then
			Return BitAND(memoryread($aitem + 40, "short"), 1) > 0
		ElseIf IsDllStruct($aitem) <> 0 Then
			Return BitAND(DllStructGetData($aitem, "interaction"), 1) > 0
		Else
			Return BitAND(memoryread(getitemptr($aitem) + 40, "short"), 1) > 0
		EndIf
	EndFunc

	Func getisunided($aitem)
		If IsPtr($aitem) <> 0 Then
			Return BitAND(memoryread($aitem + 40, "long"), 8388608) > 0
		ElseIf IsDllStruct($aitem) <> 0 Then
			Return BitAND(DllStructGetData($aitem, "interaction"), 8388608) > 0
		Else
			Return BitAND(memoryread(getitemptr($aitem) + 40, "long"), 8388608) > 0
		EndIf
	EndFunc

	Func getitemreq($aitem)
		Local $lmod = getmodbyidentifier($aitem, "9827")
		Return $lmod[0]
	EndFunc

	Func getitemattribute($aitem)
		Local $lmod = getmodbyidentifier($aitem, "9827")
		Return $lmod[1]
	EndFunc

	Func getmodbyidentifier($aitem, $aidentifier)
		Local $lreturn[2]
		Local $lstring = StringTrimLeft(getmodstruct($aitem), 2)
		For $i = 0 To StringLen($lstring) / 8 - 2
			If StringMid($lstring, 8 * $i + 5, 4) == $aidentifier Then
				$lreturn[0] = Int("0x" & StringMid($lstring, 8 * $i + 1, 2))
				$lreturn[1] = Int("0x" & StringMid($lstring, 8 * $i + 3, 2))
				ExitLoop
			EndIf
		Next
		Return $lreturn
	EndFunc

	Func getmodstruct($aitem)
		Local $lmodstruct
		Local $lmodsize
		If IsPtr($aitem) <> 0 Then
			$lmodstruct = memoryread($aitem + 16, "ptr")
			$lmodsize = memoryread($aitem + 20, "long")
		ElseIf IsDllStruct($aitem) <> 0 Then
			$lmodstruct = DllStructGetData($aitem, "modstruct")
			$lmodsize = DllStructGetData($aitem, "modstructsize")
		Else
			Local $litemptr = getitemptr($aitem)
			$lmodstruct = memoryread($litemptr + 16, "ptr")
			$lmodsize = memoryread($litemptr + 20, "long")
		EndIf
		If $lmodstruct = 0 Then Return False
		Return memoryread($lmodstruct, "Byte[" & $lmodsize * 4 & "]")
	EndFunc

	Func getassignedtome($aagent)
		If IsPtr($aagent) <> 0 Then
			Local $lowner = memoryread($aagent + 196, "long")
		ElseIf IsDllStruct($aagent) <> 0 Then
			Local $lowner = DllStructGetData($aagent, "Owner")
		Else
			Local $lowner = memoryread(getagentptr($aagent) + 196, "long")
		EndIf
		If $lowner = 0 OR $lowner = getmyid() Then
			Return True
		Else
			Return False
		EndIf
	EndFunc

	Func getcanpickup($aagent)
		Return getassignedtome($aagent)
	EndFunc

	Func getattributebymod($amod)
		Switch $amod
			Case "3F"
				Return 3
			Case "40"
				Return 1
			Case "41"
				Return 2
			Case "42"
				Return 4
			Case "43"
				Return 5
			Case "44"
				Return 8
			Case "45"
				Return 6
			Case "46"
				Return 7
			Case "47"
				Return 9
			Case "48"
				Return 10
			Case "49"
				Return 13
			Case "4A"
				Return 11
			Case "4B"
				Return 12
			Case "4C"
				Return 17
			Case "4D"
				Return 14
			Case "4E"
				Return 16
			Case "4F"
				Return 15
			Case "50"
				Return 19
			Case "51"
				Return 20
			Case "53"
				Return 21
			Case "54"
				Return 18
			Case "55"
				Return 22
			Case "56"
				Return 23
			Case "57"
				Return 26
			Case "58"
				Return 24
			Case "59"
				Return 25
		EndSwitch
	EndFunc

	Func getitemmaxdmg($aitem)
		Local $lmodstring = getmodstruct($aitem)
		Local $lpos = StringInStr($lmodstring, "A8A7")
		If $lpos = 0 Then $lpos = StringInStr($lmodstring, "C867")
		If $lpos = 0 Then $lpos = StringInStr($lmodstring, "B8A7")
		If $lpos = 0 Then Return 0
		Return Int("0x" & StringMid($lmodstring, $lpos - 2, 2))
	EndFunc

	Func getisironitem($aitem)
		Local $litemmid
		If IsPtr($aitem) <> 0 Then
			$litemmid = memoryread($aitem + 44, "long")
		ElseIf IsDllStruct($aitem) <> 0 Then
			$litemmid = DllStructGetData($aitem, "ModelID")
		Else
			$litemmid = $aitem
		EndIf
		Switch $litemmid
			Case 109, 110, 111, 113, 116, 120, 121, 126, 149, 150, 151, 153, 201, 202, 206, 214, 216, 222, 251, 254, 255, 257, 258, 259, 261, 263, 265, 266
				Return True
			Case 269, 271, 274, 275, 278, 279, 282, 284, 285, 286, 288, 289, 290, 326, 327, 331, 334, 335, 336, 337, 338, 343, 345, 396, 400, 402, 405, 406
				Return True
			Case 407, 408, 412, 418, 419, 421, 1753, 1755, 1757, 1758, 1759, 1765, 1767, 1781, 1785, 1787, 1788, 1790, 1791, 1792, 1793, 1800, 1808, 1810, 1813
				Return True
			Case 1815, 1820, 1825, 1827, 1830, 1831, 1832, 1834, 1835, 1837, 1841, 1844, 1850, 1851, 1852, 1857, 1858, 1859, 1860, 1863, 1869, 1871, 1872, 1873
				Return True
			Case 1874, 1875, 1876, 1887, 1889, 1892, 1898, 1899, 1901, 1902, 1903, 1904, 1906, 1908, 1910, 1911, 1912, 1913, 1914, 1917, 1928, 1933, 1935, 1937
				Return True
			Case 1941, 1944, 1946, 1947, 1954, 2040, 2041, 2042, 2043, 2065, 2072, 2077, 2078, 2104, 2109, 2191, 2200, 2201, 2204, 2211, 2218, 2219, 2220, 2222
				Return True
			Case 2224, 2225, 2228, 2231, 2233, 2234, 2251, 2253, 2255, 2403, 2404, 2405, 2406, 2407, 2408, 2411, 2412
				Return True
			Case Else
				Return False
		EndSwitch
	EndFunc

	Func getisrareweapon($aitem)
		Local $attribute = getitemattribute($aitem)
		Local $requirement = getitemreq($aitem)
		Local $damage = getitemmaxdmg($aitem)
		If $attribute = 21 AND $requirement <= 8 AND $damage = 22 Then
			Return True
		ElseIf $attribute = 18 AND $requirement <= 8 AND $damage = 16 Then
			Return True
		ElseIf $attribute = 22 AND $requirement <= 8 AND $damage = 16 Then
			Return True
		ElseIf $attribute = 36 AND $requirement <= 8 AND $damage = 16 Then
			Return True
		ElseIf $attribute = 37 AND $requirement <= 8 AND $damage = 16 Then
			Return True
		EndIf
		Return False
	EndFunc

	Func getisnormalmaterial($aitem)
		If IsPtr($aitem) <> 0 Then
			Local $litemmid = memoryread($aitem + 44, "long")
		ElseIf IsDllStruct($aitem) <> 0 Then
			Local $litemmid = DllStructGetData($aitem, "ModelID")
		Else
			Local $litemmid = $aitem
		EndIf
		Switch $litemmid
			Case 921, 954, 925, 929, 933, 934, 955, 948, 953, 940, 946
				Return True
			Case Else
				Return False
		EndSwitch
	EndFunc

#EndRegion
#Region Gold

	Func getgoldstorage()
		Local $loffset[5] = [0, 24, 64, 248, 128]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func getgoldcharacter()
		Local $loffset[5] = [0, 24, 64, 248, 124]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func dropgold($aamount = 0)
		Local $lamount
		If $aamount > 0 Then
			$lamount = $aamount
		Else
			$lamount = getgoldcharacter()
		EndIf
		Return sendpacket(8, 41, $lamount)
	EndFunc

	Func depositgold($aamount = 0)
		Local $lamount
		Local $lstorage = getgoldstorage()
		Local $lcharacter = getgoldcharacter()
		If $aamount > 0 AND $lcharacter >= $aamount Then
			$lamount = $aamount
		Else
			$lamount = $lcharacter
		EndIf
		If $lstorage + $lamount > 1000000 Then $lamount = 1000000 - $lstorage
		changegold($lcharacter - $lamount, $lstorage + $lamount)
	EndFunc

	Func withdrawgold($aamount = 0)
		Local $lamount
		Local $lstorage = getgoldstorage()
		Local $lcharacter = getgoldcharacter()
		If $aamount > 0 AND $lstorage >= $aamount Then
			$lamount = $aamount
		Else
			$lamount = $lstorage
		EndIf
		If $lcharacter + $lamount > 100000 Then $lamount = 100000 - $lcharacter
		changegold($lcharacter + $lamount, $lstorage - $lamount)
	EndFunc

	Func changegold($acharacter, $astorage)
		Return sendpacket(12, 118, $acharacter, $astorage)
	EndFunc

	Func checkgold($awithdraw = 50000, $adeposit = 50000, $amingold = 20000, $amaxgold = 65000, $avariance = 10000)
		Local $gold = getgoldcharacter()
		Local $gold_storage = getgoldstorage()
		If $gold > Random($amaxgold - $avariance, $amaxgold + $avariance) Then
			If $gold_storage = 1000000 Then Return
			If $gold_storage + $adeposit > 1000000 Then
				depositgold(1000000 - $gold_storage)
			Else
				depositgold($adeposit)
			EndIf
			rndsleep(500)
		ElseIf $gold < $amingold Then
			If $gold_storage = 0 Then Return
			If $gold_storage < $awithdraw Then
				withdrawgold($gold_storage)
			Else
				withdrawgold($awithdraw)
			EndIf
			rndsleep(500)
		EndIf
	EndFunc

#EndRegion
#Region Misc

	Func findminipet()
		For $i = 4 To 1 Step -1
			$lbagptr = getbagptr($i)
			For $j = memoryread($lbagptr + 32, "long") To 1 Step -1
				$litemptr = getitemptrbyslot($lbagptr, $j)
				If memoryread($litemptr + 32, "byte") = 34 Then Return memoryread($litemptr, "long")
			Next
		Next
	EndFunc

	Func upgradearmor($aarmor, $aupgrade)
		If IsPtr($aarmor) <> 0 Then
			Local $larmorid = memoryread($aarmor, "long")
			Local $larmortype = memoryread($aarmor + 32, "byte")
		ElseIf IsDllStruct($aarmor) <> 0 Then
			Local $larmorid = DllStructGetData($aarmor, "ID")
			Local $larmortype = DllStructGetData($aarmor, "Type")
		Else
			Local $larmorid = $aarmor
			Local $lptr = getitemptr($larmorid)
			Local $larmortype = memoryread($lptr + 32, "byte")
		EndIf
		If IsPtr($aupgrade) <> 0 Then
			Local $lupgradeid = memoryread($aupgrade, "long")
			Local $lupgrademid = memoryread($aupgrade + 44, "long")
		ElseIf IsDllStruct($aupgrade) <> 0 Then
			Local $lupgradeid = DllStructGetData($aupgrade, "ID")
			Local $lupgrademid = DllStructGetData($aupgrade, "ModelID")
		Else
			Local $lupgradeid = $aupgrade
			Local $lptr = getitemptr($lupgradeid)
			Local $lupgrademid = memoryread($lptr + 44, "long")
		EndIf
		Local $larmormod = getmodstruct($aarmor)
		Local $lupgradetype = isruneorinsignia($lupgrademid)
		If $lupgradetype = 0 Then Return
		If $lupgradetype = 2 Then $lupgradetype = 0
		Local $loffset[4] = [0, 24, 44, 1580]
		Local $lsessionid = memoryreadptr($mbasepointer, $loffset)
		If isarmor($larmortype) = 0 Then Return False
		DllStructSetData($mupgrade, 2, $larmorid)
		DllStructSetData($mupgrade, 3, $lupgradeid)
		DllStructSetData($mupgrade, 4, $lupgradetype)
		enqueue($mupgradeptr, 16)
		sendpacket(12, 122, $lsessionid[1], $larmorid)
		pingsleep(125)
		sendpacket(4, 124)
	EndFunc

	Func isarmor($atype)
		Switch $atype
			Case 4, 7, 13, 16, 19
				Return $atype
			Case Else
				Return 0
		EndSwitch
	EndFunc

	Func isruneorinsignia($amodelid)
		Switch $amodelid
			Case 903, 5558, 5559
				Return 1
			Case 19152 To 19156
				Return 2
			Case 5560, 5561, 904
				Return 1
			Case 19157 To 19162
				Return 2
			Case 5556, 5557, 902
				Return 1
			Case 19149 To 19151
				Return 2
			Case 5552, 5553, 900
				Return 1
			Case 19138 To 19143
				Return 2
			Case 3612, 5549, 899
				Return 1
			Case 19128, 19130, 19129
				Return 2
			Case 5554, 5555, 901
				Return 1
			Case 19144 To 19148
				Return 2
			Case 6327 To 6329
				Return 1
			Case 19165 To 19167
				Return 2
			Case 6324 To 6326
				Return 1
			Case 19124 To 19127
				Return 2
			Case 15545 To 15547
				Return 1
			Case 19163 To 19164
				Return 2
			Case 15548 To 15550
				Return 1
			Case 19168
				Return 2
			Case 5550, 5551, 898
				Return 1
			Case 19131 To 19137
				Return 2
		EndSwitch
	EndFunc

#EndRegion
#Region TempStorage

	Func tempstorage()
		For $i = 1 To $mbags
			$lbagptr = getbagptr($i)
			For $j = 1 To memoryread($lbagptr + 32, "long")
				$litemptr = getitemptrbyslot($lbagptr, $j)
				If $litemptr = 0 Then Return True
				$ltype = memoryread($litemptr + 32, "byte")
				If $ltype = 29 Then ContinueLoop
				$lmapstate = getmaploading()
				If $lmapstate = 0 Then
					If NOT $mfoundchest Then Return False
					$lslot = openstorageslot()
					If $lslot <> 0 Then
						ReDim $mtempstorage[$mtempstorage[0][0] + 1][2]
						$mtempstorage[$mtempstorage[0][0]][0] = $lslot[0]
						$mtempstorage[$mtempstorage[0][0]][1] = $lslot[1]
						moveitem($litemptr, $lslot[0], $lslot[1])
						Sleep(getping() + Random(1000, 1500, 1))
						Return True
					EndIf
				ElseIf $lmapstate = 1 Then
					If salvageuses() < 2 Then Return False
					If memoryread($litemptr + 75, "byte") > 1 Then ContinueLoop
					If getrarity($litemptr) <> 2621 Then ContinueLoop
					Switch $ltype
						Case 2, 5, 12, 15, 22, 24, 26, 27, 32, 35, 36, 0
							dropitem($litemptr)
							Sleep(getping() + Random(1000, 1500, 1))
							Return True
						Case Else
							ContinueLoop
					EndSwitch
				EndIf
			Next
		Next
	EndFunc

	Func restorestorage()
		For $i = $mtempstorage[0][0] To 1 Step -1
			$litemptr = getitemptrbyslot($mtempstorage[$i][0], $mtempstorage[$i][1])
			$lslot = openbackpackslot()
			If $lslot = 0 Then Return False
			ReDim $mtempstorage[$mtempstorage[0][0]][2]
			$mtempstorage[0][0] -= 1
			moveitem($litemptr, $lslot[0], $lslot[1])
			Sleep(getping() + Random(1000, 1500, 1))
		Next
		If $lslot = 0 Then Return False
		Return True
	EndFunc

	Func openbackpackslot()
		For $i = 1 To $mbags
			$lbagptr = getbagptr($i)
			For $j = 1 To memoryread($lbagptr + 32, "long")
				If getitemptrbyslot($lbagptr, $j) = 0 Then
					Local $lreturnarray[2] = [$i, $j]
					Return $lreturnarray
				EndIf
			Next
		Next
	EndFunc

	Func openstorageslot()
		For $i = 8 To 16
			$lbagptr = getbagptr($i)
			If $lbagptr = 0 Then ExitLoop
			For $j = 1 To memoryread($lbagptr + 32, "long")
				If getitemptrbyslot($lbagptr, $j) = 0 Then
					Local $lreturnarray[2] = [$i, $j]
					Return $lreturnarray
				EndIf
			Next
		Next
	EndFunc

	Func findbackpackstack($amodelid)
		For $i = 1 To 4
			$lbagptr = getbagptr($i)
			For $j = 1 To memoryread($lbagptr + 32, "long")
				$litemptr = getitemptrbyslot($lbagptr, $j)
				If $litemptr = 0 Then ContinueLoop
				If memoryread($litemptr + 44, "long") = $amodelid AND memoryread($litemptr + 75, "byte") < 250 Then
					Local $lreturnarray[2] = [$i, $j]
					Return $lreturnarray
				EndIf
			Next
		Next
	EndFunc

	Func findstoragestack($amodelid, $aextraid = 0)
		For $i = 8 To 16
			$lbagptr = getbagptr($i)
			For $j = 1 To memoryread($lbagptr + 32, "long")
				$litemptr = getitemptrbyslot($lbagptr, $j)
				If $litemptr = 0 Then ContinueLoop
				If memoryread($litemptr + 44, "long") = $amodelid AND memoryread($litemptr + 34, "short") = $aextraid AND memoryread($litemptr + 75, "byte") < 250 Then
					Local $lreturnarray[2] = [$i, $j]
					Return $lreturnarray
				EndIf
			Next
		Next
	EndFunc

	Func moveitemfromstoragebymodelid($amodelid, $aamount = 250)
		Local $ltotalcount = 0
		If countiteminbagsbymodelid($amodelid) >= $aamount Then Return True
		For $i = 8 To 16
			$lbagptr = getbagptr($i)
			For $j = 1 To memoryread($lbagptr + 32, "long")
				$lbackpackslot = findbackpackstack($amodelid)
				If $lbackpackslot = 0 Then
					$lbackpackslot = openbackpackslot()
					If $lbackpackslot = 0 Then Return False
				Else
					$litemptr = getitemptrbyslot($lbackpackslot[0], $lbackpackslot[1])
					$lstartcount = memoryread($litemptr + 75, "byte")
				EndIf
				$litemptr = getitemptrbyslot($lbagptr, $j)
				$lstoragecount = memoryread($litemptr + 75, "byte")
				If memoryread($litemptr + 44, "long") = $amodelid Then
					$ltotalcount += $lstoragecount
					moveitem($litemptr, $lbackpackslot[0], $lbackpackslot[1])
					Sleep(getping() + Random(100, 150, 1))
					If $ltotalcount >= $aamount Then Return True
				EndIf
			Next
		Next
		Return True
	EndFunc

	Func getitemfromstorageiflow($amodelid, $minimumamount = 250)
		If countiteminbagsbymodelid($amodelid) < $minimumamount Then
			moveitemfromstoragebymodelid($amodelid, $minimumamount)
		EndIf
	EndFunc

#EndRegion
#Region Party Window
	#Region Invite

		Func inviteplayer($aplayername)
			Static $minviteplayer = DllStructCreate("ptr;dword;dword;wchar[20]")
			Static $minviteplayerptr = NULL
			If ($minviteplayerptr = NULL ) Then
				DllStructSetData($minviteplayer, 1, getvalue("CommandPacketSend"))
				DllStructSetData($minviteplayer, 2, 44)
				DllStructSetData($minviteplayer, 3, 155)
			EndIf
			DllStructSetData($minviteplayer, 4, $aplayername)
		EndFunc

		Func inviteplayerbyplayernumber($lplayernumber)
			Return sendpacket(8, 154, $lplayernumber)
		EndFunc

		Func inviteplayerbyid($aagentid)
			If IsPtr($aagentid) Then
				Local $lagentplayernumber = memoryread($aagentid + 244, "word")
			ElseIf IsDllStruct($aagentid) <> 0 Then
				Local $lagentplayernumber = DllStructGetData($aagentid, "Playernumber")
			Else
				Local $lagentplayernumber = memoryread(getagentptr($aagentid) + 244, "word")
			EndIf
			If $lagentplayernumber <> 0 Then Return sendpacket(8, 154, $lagentplayernumber)
		EndFunc

		Func invitetarget()
			Local $lpnum = memoryread(getagentptr(-1) + 244, "word")
			Return sendpacket(8, 154, $lpnum)
		EndFunc

		Func acceptinvite()
			Return sendpacket(8, 150)
		EndFunc

		Func getishardmode()
			Local $loffset[4] = [0, 24, 76, 20]
			Local $lbitmask = memoryreadptr($mbasepointer, $loffset)
			Return BitAND($lbitmask[1], 16) > 0
		EndFunc

		Func getpartyisdefeated()
			Local $loffset[4] = [0, 24, 76, 20]
			Local $lbitmask = memoryreadptr($mbasepointer, $loffset)
			Return BitAND($lbitmask[1], 32) > 0
		EndFunc

	#EndRegion
	#Region Leave/Kick

		Func leavegroup($akickheroes = True)
			If $akickheroes Then sendpacket(8, 24, 38)
			Return sendpacket(4, 156)
		EndFunc

	#EndRegion
	#Region Misc

		Func switchmode($amode)
			Return sendpacket(8, 149, $amode)
		EndFunc

	#EndRegion
#EndRegion
#Region Information

	Func getpartysize()
		Local $loffset[5] = [0, 24, 76, 100, 36]
		Local $lpartyptr = memoryreadptr($mbasepointer, $loffset)
		$loffset[3] = 84
		$loffset[4] = 12
		Local $lpartyplayerptr = memoryreadptr($mbasepointer, $loffset)
		Local $party1 = memoryread($lpartyptr[0], "long")
		Local $party2 = memoryread($lpartyptr[0] + 16, "long")
		Local $party3 = memoryread($lpartyplayerptr[0], "long")
		Local $lreturn = $party1 + $party2 + $party3
		If $lreturn > 12 OR $lreturn < 1 Then $lreturn = 8
		Return $lreturn
	EndFunc

	Func getmaxpartysize($amapid)
		Switch $amapid
			Case 293 To 296, 721, 368, 188, 467, 497
				Return 1
			Case 163 To 166
				Return 2
			Case 28 To 30, 32, 36, 39, 40, 81, 131, 135, 148, 189, 214, 242, 249, 251, 281, 282
				Return 4
			Case 431, 449, 479, 491, 502, 544, 555, 795, 796, 811, 815, 816, 818 To 820, 855, 856
				Return 4
			Case 10 To 12, 14 To 16, 19, 21, 25, 38, 49, 55, 57, 73, 109, 116, 117 To 119
				Return 6
			Case 132 To 134, 136, 137, 139 To 142, 152, 153, 154, 213, 250, 385, 808, 809, 810
				Return 6
			Case 266, 307
				Return 12
			Case Else
				Return 8
		EndSwitch
	EndFunc

	Func checkpartydead(ByRef $apartyarray)
		For $i = 1 To $apartyarray[0]
			Local $lanimation = memoryread($apartyarray[$i] + 220, "byte")
			If $lanimation <> 61 AND $lanimation <> 62 Then Return False
		Next
		Sleep(1000)
		resignandreturn()
	EndFunc

	Func ispartyarraydead()
		For $i = 1 To $mpartyarray[0]
			Local $lanimation = memoryread($mpartyarray[$i] + 220, "byte")
			If $lanimation <> 61 AND $lanimation <> 62 Then Return False
		Next
		Return True
	EndFunc

#EndRegion
Global Enum $arrayfill_force_default, $arrayfill_force_singleitem, $arrayfill_force_int, $arrayfill_force_number, $arrayfill_force_ptr, $arrayfill_force_hwnd, $arrayfill_force_string
Global Enum $arrayunique_nocount, $arrayunique_count
Global Enum $arrayunique_auto, $arrayunique_force32, $arrayunique_force64, $arrayunique_match, $arrayunique_distinct

Func _arrayadd(ByRef $aarray, $vvalue, $istart = 0, $sdelim_item = "|", $sdelim_row = @CRLF, $iforce = $arrayfill_force_default)
	If $istart = Default Then $istart = 0
	If $sdelim_item = Default Then $sdelim_item = "|"
	If $sdelim_row = Default Then $sdelim_row = @CRLF
	If $iforce = Default Then $iforce = $arrayfill_force_default
	If NOT IsArray($aarray) Then Return SetError(1, 0, -1)
	Local $idim_1 = UBound($aarray, $ubound_rows)
	Local $hdatatype = 0
	Switch $iforce
		Case $arrayfill_force_int
			$hdatatype = Int
		Case $arrayfill_force_number
			$hdatatype = Number
		Case $arrayfill_force_ptr
			$hdatatype = Ptr
		Case $arrayfill_force_hwnd
			$hdatatype = HWnd
		Case $arrayfill_force_string
			$hdatatype = String
	EndSwitch
	Switch UBound($aarray, $ubound_dimensions)
		Case 1
			If $iforce = $arrayfill_force_singleitem Then
				ReDim $aarray[$idim_1 + 1]
				$aarray[$idim_1] = $vvalue
				Return $idim_1
			EndIf
			If IsArray($vvalue) Then
				If UBound($vvalue, $ubound_dimensions) <> 1 Then Return SetError(5, 0, -1)
				$hdatatype = 0
			Else
				Local $atmp = StringSplit($vvalue, $sdelim_item, $str_nocount + $str_entiresplit)
				If UBound($atmp, $ubound_rows) = 1 Then
					$atmp[0] = $vvalue
				EndIf
				$vvalue = $atmp
			EndIf
			Local $iadd = UBound($vvalue, $ubound_rows)
			ReDim $aarray[$idim_1 + $iadd]
			For $i = 0 To $iadd - 1
				If IsFunc($hdatatype) Then
					$aarray[$idim_1 + $i] = $hdatatype($vvalue[$i])
				Else
					$aarray[$idim_1 + $i] = $vvalue[$i]
				EndIf
			Next
			Return $idim_1 + $iadd - 1
		Case 2
			Local $idim_2 = UBound($aarray, $ubound_columns)
			If $istart < 0 OR $istart > $idim_2 - 1 Then Return SetError(4, 0, -1)
			Local $ivaldim_1, $ivaldim_2 = 0, $icolcount
			If IsArray($vvalue) Then
				If UBound($vvalue, $ubound_dimensions) <> 2 Then Return SetError(5, 0, -1)
				$ivaldim_1 = UBound($vvalue, $ubound_rows)
				$ivaldim_2 = UBound($vvalue, $ubound_columns)
				$hdatatype = 0
			Else
				Local $asplit_1 = StringSplit($vvalue, $sdelim_row, $str_nocount + $str_entiresplit)
				$ivaldim_1 = UBound($asplit_1, $ubound_rows)
				Local $atmp[$ivaldim_1][0], $asplit_2
				For $i = 0 To $ivaldim_1 - 1
					$asplit_2 = StringSplit($asplit_1[$i], $sdelim_item, $str_nocount + $str_entiresplit)
					$icolcount = UBound($asplit_2)
					If $icolcount > $ivaldim_2 Then
						$ivaldim_2 = $icolcount
						ReDim $atmp[$ivaldim_1][$ivaldim_2]
					EndIf
					For $j = 0 To $icolcount - 1
						$atmp[$i][$j] = $asplit_2[$j]
					Next
				Next
				$vvalue = $atmp
			EndIf
			If UBound($vvalue, $ubound_columns) + $istart > UBound($aarray, $ubound_columns) Then Return SetError(3, 0, -1)
			ReDim $aarray[$idim_1 + $ivaldim_1][$idim_2]
			For $iwriteto_index = 0 To $ivaldim_1 - 1
				For $j = 0 To $idim_2 - 1
					If $j < $istart Then
						$aarray[$iwriteto_index + $idim_1][$j] = ""
					ElseIf $j - $istart > $ivaldim_2 - 1 Then
						$aarray[$iwriteto_index + $idim_1][$j] = ""
					Else
						If IsFunc($hdatatype) Then
							$aarray[$iwriteto_index + $idim_1][$j] = $hdatatype($vvalue[$iwriteto_index][$j - $istart])
						Else
							$aarray[$iwriteto_index + $idim_1][$j] = $vvalue[$iwriteto_index][$j - $istart]
						EndIf
					EndIf
				Next
			Next
		Case Else
			Return SetError(2, 0, -1)
	EndSwitch
	Return UBound($aarray, $ubound_rows) - 1
EndFunc

Func _arraybinarysearch(Const ByRef $aarray, $vvalue, $istart = 0, $iend = 0, $icolumn = 0)
	If $istart = Default Then $istart = 0
	If $iend = Default Then $iend = 0
	If $icolumn = Default Then $icolumn = 0
	If NOT IsArray($aarray) Then Return SetError(1, 0, -1)
	Local $idim_1 = UBound($aarray, $ubound_rows)
	If $idim_1 = 0 Then Return SetError(6, 0, -1)
	If $iend < 1 OR $iend > $idim_1 - 1 Then $iend = $idim_1 - 1
	If $istart < 0 Then $istart = 0
	If $istart > $iend Then Return SetError(4, 0, -1)
	Local $imid = Int(($iend + $istart) / 2)
	Switch UBound($aarray, $ubound_dimensions)
		Case 1
			If $aarray[$istart] > $vvalue OR $aarray[$iend] < $vvalue Then Return SetError(2, 0, -1)
			While $istart <= $imid AND $vvalue <> $aarray[$imid]
				If $vvalue < $aarray[$imid] Then
					$iend = $imid - 1
				Else
					$istart = $imid + 1
				EndIf
				$imid = Int(($iend + $istart) / 2)
			WEnd
			If $istart > $iend Then Return SetError(3, 0, -1)
		Case 2
			Local $idim_2 = UBound($aarray, $ubound_columns) - 1
			If $icolumn < 0 OR $icolumn > $idim_2 Then Return SetError(7, 0, -1)
			If $aarray[$istart][$icolumn] > $vvalue OR $aarray[$iend][$icolumn] < $vvalue Then Return SetError(2, 0, -1)
			While $istart <= $imid AND $vvalue <> $aarray[$imid][$icolumn]
				If $vvalue < $aarray[$imid][$icolumn] Then
					$iend = $imid - 1
				Else
					$istart = $imid + 1
				EndIf
				$imid = Int(($iend + $istart) / 2)
			WEnd
			If $istart > $iend Then Return SetError(3, 0, -1)
		Case Else
			Return SetError(5, 0, -1)
	EndSwitch
	Return $imid
EndFunc

Func _arraycoldelete(ByRef $aarray, $icolumn, $bconvert = False)
	If $bconvert = Default Then $bconvert = False
	If NOT IsArray($aarray) Then Return SetError(1, 0, -1)
	Local $idim_1 = UBound($aarray, $ubound_rows)
	If UBound($aarray, $ubound_dimensions) <> 2 Then Return SetError(2, 0, -1)
	Local $idim_2 = UBound($aarray, $ubound_columns)
	Switch $idim_2
		Case 2
			If $icolumn < 0 OR $icolumn > 1 Then Return SetError(3, 0, -1)
			If $bconvert Then
				Local $atemparray[$idim_1]
				For $i = 0 To $idim_1 - 1
					$atemparray[$i] = $aarray[$i][(NOT $icolumn)]
				Next
				$aarray = $atemparray
			Else
				ContinueCase
			EndIf
		Case Else
			If $icolumn < 0 OR $icolumn > $idim_2 - 1 Then Return SetError(3, 0, -1)
			For $i = 0 To $idim_1 - 1
				For $j = $icolumn To $idim_2 - 2
					$aarray[$i][$j] = $aarray[$i][$j + 1]
				Next
			Next
			ReDim $aarray[$idim_1][$idim_2 - 1]
	EndSwitch
	Return UBound($aarray, $ubound_columns)
EndFunc

Func _arraycolinsert(ByRef $aarray, $icolumn)
	If NOT IsArray($aarray) Then Return SetError(1, 0, -1)
	Local $idim_1 = UBound($aarray, $ubound_rows)
	Switch UBound($aarray, $ubound_dimensions)
		Case 1
			Local $atemparray[$idim_1][2]
			Switch $icolumn
				Case 0, 1
					For $i = 0 To $idim_1 - 1
						$atemparray[$i][(NOT $icolumn)] = $aarray[$i]
					Next
				Case Else
					Return SetError(3, 0, -1)
			EndSwitch
			$aarray = $atemparray
		Case 2
			Local $idim_2 = UBound($aarray, $ubound_columns)
			If $icolumn < 0 OR $icolumn > $idim_2 Then Return SetError(3, 0, -1)
			ReDim $aarray[$idim_1][$idim_2 + 1]
			For $i = 0 To $idim_1 - 1
				For $j = $idim_2 To $icolumn + 1 Step -1
					$aarray[$i][$j] = $aarray[$i][$j - 1]
				Next
				$aarray[$i][$icolumn] = ""
			Next
		Case Else
			Return SetError(2, 0, -1)
	EndSwitch
	Return UBound($aarray, $ubound_columns)
EndFunc

Func _arraycombinations(Const ByRef $aarray, $iset, $sdelimiter = "")
	If $sdelimiter = Default Then $sdelimiter = ""
	If NOT IsArray($aarray) Then Return SetError(1, 0, 0)
	If UBound($aarray, $ubound_dimensions) <> 1 Then Return SetError(2, 0, 0)
	Local $in = UBound($aarray)
	Local $ir = $iset
	Local $aidx[$ir]
	For $i = 0 To $ir - 1
		$aidx[$i] = $i
	Next
	Local $itotal = __array_combinations($in, $ir)
	Local $ileft = $itotal
	Local $aresult[$itotal + 1]
	$aresult[0] = $itotal
	Local $icount = 1
	While $ileft > 0
		__array_getnext($in, $ir, $ileft, $itotal, $aidx)
		For $i = 0 To $iset - 1
			$aresult[$icount] &= $aarray[$aidx[$i]] & $sdelimiter
		Next
		If $sdelimiter <> "" Then $aresult[$icount] = StringTrimRight($aresult[$icount], 1)
		$icount += 1
	WEnd
	Return $aresult
EndFunc

Func _arrayconcatenate(ByRef $aarraytarget, Const ByRef $aarraysource, $istart = 0)
	If $istart = Default Then $istart = 0
	If NOT IsArray($aarraytarget) Then Return SetError(1, 0, -1)
	If NOT IsArray($aarraysource) Then Return SetError(2, 0, -1)
	Local $idim_total_tgt = UBound($aarraytarget, $ubound_dimensions)
	Local $idim_total_src = UBound($aarraysource, $ubound_dimensions)
	Local $idim_1_tgt = UBound($aarraytarget, $ubound_rows)
	Local $idim_1_src = UBound($aarraysource, $ubound_rows)
	If $istart < 0 OR $istart > $idim_1_src - 1 Then Return SetError(6, 0, -1)
	Switch $idim_total_tgt
		Case 1
			If $idim_total_src <> 1 Then Return SetError(4, 0, -1)
			ReDim $aarraytarget[$idim_1_tgt + $idim_1_src - $istart]
			For $i = $istart To $idim_1_src - 1
				$aarraytarget[$idim_1_tgt + $i - $istart] = $aarraysource[$i]
			Next
		Case 2
			If $idim_total_src <> 2 Then Return SetError(4, 0, -1)
			Local $idim_2_tgt = UBound($aarraytarget, $ubound_columns)
			If UBound($aarraysource, $ubound_columns) <> $idim_2_tgt Then Return SetError(5, 0, -1)
			ReDim $aarraytarget[$idim_1_tgt + $idim_1_src - $istart][$idim_2_tgt]
			For $i = $istart To $idim_1_src - 1
				For $j = 0 To $idim_2_tgt - 1
					$aarraytarget[$idim_1_tgt + $i - $istart][$j] = $aarraysource[$i][$j]
				Next
			Next
		Case Else
			Return SetError(3, 0, -1)
	EndSwitch
	Return UBound($aarraytarget, $ubound_rows)
EndFunc

Func _arraydelete(ByRef $aarray, $vrange)
	If NOT IsArray($aarray) Then Return SetError(1, 0, -1)
	Local $idim_1 = UBound($aarray, $ubound_rows) - 1
	If IsArray($vrange) Then
		If UBound($vrange, $ubound_dimensions) <> 1 OR UBound($vrange, $ubound_rows) < 2 Then Return SetError(4, 0, -1)
	Else
		Local $inumber, $asplit_1, $asplit_2
		$vrange = StringStripWS($vrange, 8)
		$asplit_1 = StringSplit($vrange, ";")
		$vrange = ""
		For $i = 1 To $asplit_1[0]
			If NOT StringRegExp($asplit_1[$i], "^\d+(-\d+)?$") Then Return SetError(3, 0, -1)
			$asplit_2 = StringSplit($asplit_1[$i], "-")
			Switch $asplit_2[0]
				Case 1
					$vrange &= $asplit_2[1] & ";"
				Case 2
					If Number($asplit_2[2]) >= Number($asplit_2[1]) Then
						$inumber = $asplit_2[1] - 1
						Do
							$inumber += 1
							$vrange &= $inumber & ";"
						Until $inumber = $asplit_2[2]
					EndIf
			EndSwitch
		Next
		$vrange = StringSplit(StringTrimRight($vrange, 1), ";")
	EndIf
	If $vrange[1] < 0 OR $vrange[$vrange[0]] > $idim_1 Then Return SetError(5, 0, -1)
	Local $icopyto_index = 0
	Switch UBound($aarray, $ubound_dimensions)
		Case 1
			For $i = 1 To $vrange[0]
				$aarray[$vrange[$i]] = ChrW(64177)
			Next
			For $ireadfrom_index = 0 To $idim_1
				If $aarray[$ireadfrom_index] == ChrW(64177) Then
					ContinueLoop
				Else
					If $ireadfrom_index <> $icopyto_index Then
						$aarray[$icopyto_index] = $aarray[$ireadfrom_index]
					EndIf
					$icopyto_index += 1
				EndIf
			Next
			ReDim $aarray[$idim_1 - $vrange[0] + 1]
		Case 2
			Local $idim_2 = UBound($aarray, $ubound_columns) - 1
			For $i = 1 To $vrange[0]
				$aarray[$vrange[$i]][0] = ChrW(64177)
			Next
			For $ireadfrom_index = 0 To $idim_1
				If $aarray[$ireadfrom_index][0] == ChrW(64177) Then
					ContinueLoop
				Else
					If $ireadfrom_index <> $icopyto_index Then
						For $j = 0 To $idim_2
							$aarray[$icopyto_index][$j] = $aarray[$ireadfrom_index][$j]
						Next
					EndIf
					$icopyto_index += 1
				EndIf
			Next
			ReDim $aarray[$idim_1 - $vrange[0] + 1][$idim_2 + 1]
		Case Else
			Return SetError(2, 0, False)
	EndSwitch
	Return UBound($aarray, $ubound_rows)
EndFunc

Func _arraydisplay(Const ByRef $aarray, $stitle = Default, $sarrayrange = Default, $iflags = Default, $vuser_separator = Default, $sheader = Default, $imax_colwidth = Default, $ialt_color = Default, $huser_function = Default)
	If $stitle = Default Then $stitle = "ArrayDisplay"
	If $sarrayrange = Default Then $sarrayrange = ""
	If $iflags = Default Then $iflags = 0
	If $vuser_separator = Default Then $vuser_separator = ""
	If $sheader = Default Then $sheader = ""
	If $imax_colwidth = Default Then $imax_colwidth = 350
	If $ialt_color = Default Then $ialt_color = 0
	If $huser_function = Default Then $huser_function = 0
	Local $itranspose = BitAND($iflags, 1)
	Local $icolalign = BitAND($iflags, 6)
	Local $iverbose = BitAND($iflags, 8)
	Local $ibuttonmargin = ((BitAND($iflags, 32)) ? (0) : ((BitAND($iflags, 16)) ? (20) : (40)))
	Local $inorow = BitAND($iflags, 64)
	Local $smsg = "", $iret = 1
	If IsArray($aarray) Then
		Local $idimension = UBound($aarray, $ubound_dimensions), $irowcount = UBound($aarray, $ubound_rows), $icolcount = UBound($aarray, $ubound_columns)
		If $idimension > 2 Then
			$smsg = "Larger than 2D array passed to function"
			$iret = 2
		EndIf
	Else
		$smsg = "No array variable passed to function"
	EndIf
	If $smsg Then
		If $iverbose AND MsgBox($mb_systemmodal + $mb_iconerror + $mb_yesno, "ArrayDisplay Error: " & $stitle, $smsg & @CRLF & @CRLF & "Exit the script?") = $idyes Then
			Exit
		Else
			Return SetError($iret, 0, "")
		EndIf
	EndIf
	Local $icw_colwidth = Number($vuser_separator)
	Local $sad_separator = ChrW(64177)
	Local $scurr_separator = Opt("GUIDataSeparatorChar", $sad_separator)
	If $vuser_separator = "" Then $vuser_separator = $scurr_separator
	Local $vtmp, $irowlimit = 65525, $icollimit = 250
	Local $idatarow = $irowcount
	Local $idatacol = $icolcount
	Local $iitem_start = 0, $iitem_end = $irowcount - 1, $isubitem_start = 0, $isubitem_end = (($idimension = 2) ? ($icolcount - 1) : (0))
	Local $brange_flag = False, $avrangesplit
	If $sarrayrange Then
		Local $aarray_range = StringRegExp($sarrayrange & "||", "(?U)(.*)\|", 3)
		If $aarray_range[0] Then
			$avrangesplit = StringSplit($aarray_range[0], ":")
			If @error Then
				$iitem_end = Number($avrangesplit[1])
			Else
				$iitem_start = Number($avrangesplit[1])
				$iitem_end = Number($avrangesplit[2])
			EndIf
		EndIf
		If $iitem_start > $iitem_end Then
			$vtmp = $iitem_start
			$iitem_start = $iitem_end
			$iitem_end = $vtmp
		EndIf
		If $iitem_start < 0 Then $iitem_start = 0
		If $iitem_end > $irowcount - 1 Then $iitem_end = $irowcount - 1
		If $iitem_start <> 0 OR $iitem_end <> $irowcount - 1 Then $brange_flag = True
		If $idimension = 2 AND $aarray_range[1] Then
			$avrangesplit = StringSplit($aarray_range[1], ":")
			If @error Then
				$isubitem_end = Number($avrangesplit[1])
			Else
				$isubitem_start = Number($avrangesplit[1])
				$isubitem_end = Number($avrangesplit[2])
			EndIf
			If $isubitem_start > $isubitem_end Then
				$vtmp = $isubitem_start
				$isubitem_start = $isubitem_end
				$isubitem_end = $vtmp
			EndIf
			If $isubitem_start < 0 Then $isubitem_start = 0
			If $isubitem_end > $icolcount - 1 Then $isubitem_end = $icolcount - 1
			If $isubitem_start <> 0 OR $isubitem_end <> $icolcount - 1 Then $brange_flag = True
		EndIf
	EndIf
	Local $sdisplaydata = "[" & $idatarow
	Local $btruncated = False
	If $itranspose Then
		If $iitem_end - $iitem_start > $icollimit Then
			$btruncated = True
			$iitem_end = $iitem_start + $icollimit - 1
		EndIf
	Else
		If $iitem_end - $iitem_start > $irowlimit Then
			$btruncated = True
			$iitem_end = $iitem_start + $irowlimit - 1
		EndIf
	EndIf
	If $btruncated Then
		$sdisplaydata &= "*]"
	Else
		$sdisplaydata &= "]"
	EndIf
	If $idimension = 2 Then
		$sdisplaydata &= " [" & $idatacol
		If $itranspose Then
			If $isubitem_end - $isubitem_start > $irowlimit Then
				$btruncated = True
				$isubitem_end = $isubitem_start + $irowlimit - 1
			EndIf
		Else
			If $isubitem_end - $isubitem_start > $icollimit Then
				$btruncated = True
				$isubitem_end = $isubitem_start + $icollimit - 1
			EndIf
		EndIf
		If $btruncated Then
			$sdisplaydata &= "*]"
		Else
			$sdisplaydata &= "]"
		EndIf
	EndIf
	Local $stipdata = ""
	If $btruncated Then $stipdata &= "Truncated"
	If $brange_flag Then
		If $stipdata Then $stipdata &= " - "
		$stipdata &= "Range set"
	EndIf
	If $itranspose Then
		If $stipdata Then $stipdata &= " - "
		$stipdata &= "Transposed"
	EndIf
	Local $asheader = StringSplit($sheader, $scurr_separator, $str_nocount)
	If UBound($asheader) = 0 Then Local $asheader[1] = [""]
	$sheader = "Row"
	Local $iindex = $isubitem_start
	If $itranspose Then
		For $j = $iitem_start To $iitem_end
			$sheader &= $sad_separator & "Col " & $j
		Next
	Else
		If $asheader[0] Then
			For $iindex = $isubitem_start To $isubitem_end
				If $iindex >= UBound($asheader) Then ExitLoop
				$sheader &= $sad_separator & $asheader[$iindex]
			Next
		EndIf
		For $j = $iindex To $isubitem_end
			$sheader &= $sad_separator & "Col " & $j
		Next
	EndIf
	If $inorow Then $sheader = StringTrimLeft($sheader, 4)
	If $iverbose AND ($iitem_end - $iitem_start + 1) * ($isubitem_end - $isubitem_start + 1) > 10000 Then
		SplashTextOn("ArrayDisplay", "Preparing display" & @CRLF & @CRLF & "Please be patient", 300, 100)
	EndIf
	Local $ibuffer = 4094
	If $itranspose Then
		$vtmp = $iitem_start
		$iitem_start = $isubitem_start
		$isubitem_start = $vtmp
		$vtmp = $iitem_end
		$iitem_end = $isubitem_end
		$isubitem_end = $vtmp
	EndIf
	Local $avarraytext[$iitem_end - $iitem_start + 1]
	For $i = $iitem_start To $iitem_end
		If NOT $inorow Then $avarraytext[$i - $iitem_start] = "[" & $i & "]"
		For $j = $isubitem_start To $isubitem_end
			If $idimension = 1 Then
				If $itranspose Then
					Switch VarGetType($aarray[$j])
						Case "Array"
							$vtmp = "{Array}"
						Case Else
							$vtmp = $aarray[$j]
					EndSwitch
				Else
					Switch VarGetType($aarray[$i])
						Case "Array"
							$vtmp = "{Array}"
						Case Else
							$vtmp = $aarray[$i]
					EndSwitch
				EndIf
			Else
				If $itranspose Then
					Switch VarGetType($aarray[$j][$i])
						Case "Array"
							$vtmp = "{Array}"
						Case Else
							$vtmp = $aarray[$j][$i]
					EndSwitch
				Else
					Switch VarGetType($aarray[$i][$j])
						Case "Array"
							$vtmp = "{Array}"
						Case Else
							$vtmp = $aarray[$i][$j]
					EndSwitch
				EndIf
			EndIf
			If StringLen($vtmp) > $ibuffer Then $vtmp = StringLeft($vtmp, $ibuffer)
			$avarraytext[$i - $iitem_start] &= $sad_separator & $vtmp
		Next
		If $inorow Then $avarraytext[$i - $iitem_start] = StringTrimLeft($avarraytext[$i - $iitem_start], 1)
	Next
	Local Const $_arrayconstant_gui_dockbottom = 64
	Local Const $_arrayconstant_gui_dockborders = 102
	Local Const $_arrayconstant_gui_dockheight = 512
	Local Const $_arrayconstant_gui_dockleft = 2
	Local Const $_arrayconstant_gui_dockright = 4
	Local Const $_arrayconstant_gui_dockhcenter = 8
	Local Const $_arrayconstant_gui_event_close = -3
	Local Const $_arrayconstant_gui_focus = 256
	Local Const $_arrayconstant_gui_bkcolor_lv_alternate = -33554432
	Local Const $_arrayconstant_ss_center = 1
	Local Const $_arrayconstant_ss_centerimage = 512
	Local Const $_arrayconstant_lvm_getitemcount = (4096 + 4)
	Local Const $_arrayconstant_lvm_getitemrect = (4096 + 14)
	Local Const $_arrayconstant_lvm_getcolumnwidth = (4096 + 29)
	Local Const $_arrayconstant_lvm_setcolumnwidth = (4096 + 30)
	Local Const $_arrayconstant_lvm_getitemstate = (4096 + 44)
	Local Const $_arrayconstant_lvm_getselectedcount = (4096 + 50)
	Local Const $_arrayconstant_lvm_setextendedlistviewstyle = (4096 + 54)
	Local Const $_arrayconstant_lvs_ex_gridlines = 1
	Local Const $_arrayconstant_lvis_selected = 2
	Local Const $_arrayconstant_lvs_showselalways = 8
	Local Const $_arrayconstant_lvs_ex_fullrowselect = 32
	Local Const $_arrayconstant_ws_ex_clientedge = 512
	Local Const $_arrayconstant_ws_maximizebox = 65536
	Local Const $_arrayconstant_ws_minimizebox = 131072
	Local Const $_arrayconstant_ws_sizebox = 262144
	Local Const $_arrayconstant_wm_setredraw = 11
	Local Const $_arrayconstant_lvscw_autosize = -1
	Local $icoordmode = Opt("GUICoordMode", 1)
	Local $iorgwidth = 210, $iheight = 200, $iminsize = 250
	Local $hgui = GUICreate($stitle, $iorgwidth, $iheight, Default, Default, BitOR($_arrayconstant_ws_sizebox, $_arrayconstant_ws_minimizebox, $_arrayconstant_ws_maximizebox))
	Local $aiguisize = WinGetClientSize($hgui)
	Local $ibuttonwidth_2 = $aiguisize[0] / 2
	Local $ibuttonwidth_3 = $aiguisize[0] / 3
	Local $idlistview = GUICtrlCreateListView($sheader, 0, 0, $aiguisize[0], $aiguisize[1] - $ibuttonmargin, $_arrayconstant_lvs_showselalways)
	GUICtrlSetBkColor($idlistview, $_arrayconstant_gui_bkcolor_lv_alternate)
	GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_setextendedlistviewstyle, $_arrayconstant_lvs_ex_gridlines, $_arrayconstant_lvs_ex_gridlines)
	GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_setextendedlistviewstyle, $_arrayconstant_lvs_ex_fullrowselect, $_arrayconstant_lvs_ex_fullrowselect)
	GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_setextendedlistviewstyle, $_arrayconstant_ws_ex_clientedge, $_arrayconstant_ws_ex_clientedge)
	Local $idcopy_id = 9999, $idcopy_data = 99999, $iddata_label = 99999, $iduser_func = 99999, $idexit_script = 99999
	If $ibuttonmargin Then
		$idcopy_id = GUICtrlCreateButton("Copy Data && Hdr/Row", 0, $aiguisize[1] - $ibuttonmargin, $ibuttonwidth_2, 20)
		$idcopy_data = GUICtrlCreateButton("Copy Data Only", $ibuttonwidth_2, $aiguisize[1] - $ibuttonmargin, $ibuttonwidth_2, 20)
		If $ibuttonmargin = 40 Then
			Local $ibuttonwidth_var = $ibuttonwidth_2
			Local $ioffset = $ibuttonwidth_2
			If IsFunc($huser_function) Then
				$iduser_func = GUICtrlCreateButton("Run User Func", $ibuttonwidth_3, $aiguisize[1] - 20, $ibuttonwidth_3, 20)
				$ibuttonwidth_var = $ibuttonwidth_3
				$ioffset = $ibuttonwidth_3 * 2
			EndIf
			$idexit_script = GUICtrlCreateButton("Exit Script", $ioffset, $aiguisize[1] - 20, $ibuttonwidth_var, 20)
			$iddata_label = GUICtrlCreateLabel($sdisplaydata, 0, $aiguisize[1] - 20, $ibuttonwidth_var, 18, BitOR($_arrayconstant_ss_center, $_arrayconstant_ss_centerimage))
			Select
				Case $btruncated OR $itranspose OR $brange_flag
					GUICtrlSetColor($iddata_label, 16711680)
					GUICtrlSetTip($iddata_label, $stipdata)
			EndSelect
		EndIf
	EndIf
	GUICtrlSetResizing($idlistview, $_arrayconstant_gui_dockborders)
	GUICtrlSetResizing($idcopy_id, $_arrayconstant_gui_dockleft + $_arrayconstant_gui_dockbottom + $_arrayconstant_gui_dockheight)
	GUICtrlSetResizing($idcopy_data, $_arrayconstant_gui_dockright + $_arrayconstant_gui_dockbottom + $_arrayconstant_gui_dockheight)
	GUICtrlSetResizing($iddata_label, $_arrayconstant_gui_dockleft + $_arrayconstant_gui_dockbottom + $_arrayconstant_gui_dockheight)
	GUICtrlSetResizing($iduser_func, $_arrayconstant_gui_dockhcenter + $_arrayconstant_gui_dockbottom + $_arrayconstant_gui_dockheight)
	GUICtrlSetResizing($idexit_script, $_arrayconstant_gui_dockright + $_arrayconstant_gui_dockbottom + $_arrayconstant_gui_dockheight)
	GUICtrlSendMsg($idlistview, $_arrayconstant_wm_setredraw, 0, 0)
	Local $iditem
	For $i = 0 To UBound($avarraytext) - 1
		$iditem = GUICtrlCreateListViewItem($avarraytext[$i], $idlistview)
		If $ialt_color Then
			GUICtrlSetBkColor($iditem, $ialt_color)
		EndIf
	Next
	If $icolalign Then
		Local Const $_arrayconstant_lvcf_fmt = 1
		Local Const $_arrayconstant_lvm_setcolumnw = (4096 + 96)
		Local $tcolumn = DllStructCreate("uint Mask;int Fmt;int CX;ptr Text;int TextMax;int SubItem;int Image;int Order;int cxMin;int cxDefault;int cxIdeal")
		DllStructSetData($tcolumn, "Mask", $_arrayconstant_lvcf_fmt)
		DllStructSetData($tcolumn, "Fmt", $icolalign / 2)
		Local $pcolumn = DllStructGetPtr($tcolumn)
		For $i = 1 To $isubitem_end - $isubitem_start + 1
			GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_setcolumnw, $i, $pcolumn)
		Next
	EndIf
	GUICtrlSendMsg($idlistview, $_arrayconstant_wm_setredraw, 1, 0)
	Local $iborder = 45
	If UBound($avarraytext) > 20 Then
		$iborder += 20
	EndIf
	Local $iwidth = $iborder, $icolwidth = 0, $aicolwidth[$isubitem_end - $isubitem_start + 2], $imin_colwidth = 55
	For $i = 0 To $isubitem_end - $isubitem_start + 1
		GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_setcolumnwidth, $i, $_arrayconstant_lvscw_autosize)
		$icolwidth = GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_getcolumnwidth, $i, 0)
		If $icolwidth < $imin_colwidth Then
			GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_setcolumnwidth, $i, $imin_colwidth)
			$icolwidth = $imin_colwidth
		EndIf
		$iwidth += $icolwidth
		$aicolwidth[$i] = $icolwidth
	Next
	If $inorow Then $iwidth -= 55
	If $iwidth > @DesktopWidth - 100 Then
		$iwidth = $iborder
		For $i = 0 To $isubitem_end - $isubitem_start + 1
			If $aicolwidth[$i] > $imax_colwidth Then
				GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_setcolumnwidth, $i, $imax_colwidth)
				$iwidth += $imax_colwidth
			Else
				$iwidth += $aicolwidth[$i]
			EndIf
		Next
	EndIf
	If $iwidth > @DesktopWidth - 100 Then
		$iwidth = @DesktopWidth - 100
	ElseIf $iwidth < $iminsize Then
		$iwidth = $iminsize
	EndIf
	Local $trect = DllStructCreate("struct; long Left;long Top;long Right;long Bottom; endstruct")
	DllCall("user32.dll", "struct*", "SendMessageW", "hwnd", GUICtrlGetHandle($idlistview), "uint", $_arrayconstant_lvm_getitemrect, "wparam", 0, "struct*", $trect)
	Local $aiwin_pos = WinGetPos($hgui)
	Local $ailv_pos = ControlGetPos($hgui, "", $idlistview)
	$iheight = ((UBound($avarraytext) + 2) * (DllStructGetData($trect, "Bottom") - DllStructGetData($trect, "Top"))) + $aiwin_pos[3] - $ailv_pos[3]
	If $iheight > @DesktopHeight - 100 Then
		$iheight = @DesktopHeight - 100
	ElseIf $iheight < $iminsize Then
		$iheight = $iminsize
	EndIf
	If $iverbose Then SplashOff()
	GUISetState(@SW_HIDE, $hgui)
	WinMove($hgui, "", (@DesktopWidth - $iwidth) / 2, (@DesktopHeight - $iheight) / 2, $iwidth, $iheight)
	GUISetState(@SW_SHOW, $hgui)
	Local $ioneventmode = Opt("GUIOnEventMode", 0), $imsg
	While 1
		$imsg = GUIGetMsg()
		Switch $imsg
			Case $_arrayconstant_gui_event_close
				ExitLoop
			Case $idcopy_id, $idcopy_data
				Local $isel_count = GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_getselectedcount, 0, 0)
				If $iverbose AND (NOT $isel_count) AND ($iitem_end - $iitem_start) * ($isubitem_end - $isubitem_start) > 10000 Then
					SplashTextOn("ArrayDisplay", "Copying data" & @CRLF & @CRLF & "Please be patient", 300, 100)
				EndIf
				Local $sclip = "", $sitem, $asplit
				For $i = 0 To $iitem_end - $iitem_start
					If $isel_count AND NOT (GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_getitemstate, $i, $_arrayconstant_lvis_selected)) Then
						ContinueLoop
					EndIf
					$sitem = $avarraytext[$i]
					If $imsg = $idcopy_data Then
						$sitem = StringRegExpReplace($sitem, "^\[\d+\].(.*)$", "$1")
					EndIf
					If $icw_colwidth Then
						$asplit = StringSplit($sitem, $sad_separator)
						$sitem = ""
						For $j = 1 To $asplit[0]
							$sitem &= StringFormat("%-" & $icw_colwidth + 1 & "s", StringLeft($asplit[$j], $icw_colwidth))
						Next
					Else
						$sitem = StringReplace($sitem, $sad_separator, $vuser_separator)
					EndIf
					$sclip &= $sitem & @CRLF
				Next
				If $imsg = $idcopy_id Then
					If $icw_colwidth Then
						$asplit = StringSplit($sheader, $sad_separator)
						$sitem = ""
						For $j = 1 To $asplit[0]
							$sitem &= StringFormat("%-" & $icw_colwidth + 1 & "s", StringLeft($asplit[$j], $icw_colwidth))
						Next
					Else
						$sitem = StringReplace($sheader, $sad_separator, $vuser_separator)
					EndIf
					$sclip = $sitem & @CRLF & $sclip
				EndIf
				ClipPut($sclip)
				SplashOff()
				GUICtrlSetState($idlistview, $_arrayconstant_gui_focus)
			Case $iduser_func
				Local $aiselitems[$irowlimit] = [0]
				For $i = 0 To GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_getitemcount, 0, 0)
					If GUICtrlSendMsg($idlistview, $_arrayconstant_lvm_getitemstate, $i, $_arrayconstant_lvis_selected) Then
						$aiselitems[0] += 1
						$aiselitems[$aiselitems[0]] = $i + $iitem_start
					EndIf
				Next
				ReDim $aiselitems[$aiselitems[0] + 1]
				$huser_function($aarray, $aiselitems)
				GUICtrlSetState($idlistview, $_arrayconstant_gui_focus)
			Case $idexit_script
				GUIDelete($hgui)
				Exit
		EndSwitch
	WEnd
	GUIDelete($hgui)
	Opt("GUICoordMode", $icoordmode)
	Opt("GUIOnEventMode", $ioneventmode)
	Opt("GUIDataSeparatorChar", $scurr_separator)
	Return 1
EndFunc

Func _arrayextract(Const ByRef $aarray, $istart_row = -1, $iend_row = -1, $istart_col = -1, $iend_col = -1)
	If $istart_row = Default Then $istart_row = -1
	If $iend_row = Default Then $iend_row = -1
	If $istart_col = Default Then $istart_col = -1
	If $iend_col = Default Then $iend_col = -1
	If NOT IsArray($aarray) Then Return SetError(1, 0, -1)
	Local $idim_1 = UBound($aarray, $ubound_rows) - 1
	If $iend_row = -1 Then $iend_row = $idim_1
	If $istart_row = -1 Then $istart_row = 0
	If $istart_row < -1 OR $iend_row < -1 Then Return SetError(3, 0, -1)
	If $istart_row > $idim_1 OR $iend_row > $idim_1 Then Return SetError(3, 0, -1)
	If $istart_row > $iend_row Then Return SetError(4, 0, -1)
	Switch UBound($aarray, $ubound_dimensions)
		Case 1
			Local $aretarray[$iend_row - $istart_row + 1]
			For $i = 0 To $iend_row - $istart_row
				$aretarray[$i] = $aarray[$i + $istart_row]
			Next
			Return $aretarray
		Case 2
			Local $idim_2 = UBound($aarray, $ubound_columns) - 1
			If $iend_col = -1 Then $iend_col = $idim_2
			If $istart_col = -1 Then $istart_col = 0
			If $istart_col < -1 OR $iend_col < -1 Then Return SetError(5, 0, -1)
			If $istart_col > $idim_2 OR $iend_col > $idim_2 Then Return SetError(5, 0, -1)
			If $istart_col > $iend_col Then Return SetError(6, 0, -1)
			If $istart_col = $iend_col Then
				Local $aretarray[$iend_row - $istart_row + 1]
			Else
				Local $aretarray[$iend_row - $istart_row + 1][$iend_col - $istart_col + 1]
			EndIf
			For $i = 0 To $iend_row - $istart_row
				For $j = 0 To $iend_col - $istart_col
					If $istart_col = $iend_col Then
						$aretarray[$i] = $aarray[$i + $istart_row][$j + $istart_col]
					Else
						$aretarray[$i][$j] = $aarray[$i + $istart_row][$j + $istart_col]
					EndIf
				Next
			Next
			Return $aretarray
		Case Else
			Return SetError(2, 0, -1)
	EndSwitch
	Return 1
EndFunc

Func _arrayfindall(Const ByRef $aarray, $vvalue, $istart = 0, $iend = 0, $icase = 0, $icompare = 0, $isubitem = 0, $brow = False)
	If $istart = Default Then $istart = 0
	If $iend = Default Then $iend = 0
	If $icase = Default Then $icase = 0
	If $icompare = Default Then $icompare = 0
	If $isubitem = Default Then $isubitem = 0
	If $brow = Default Then $brow = False
	$istart = _arraysearch($aarray, $vvalue, $istart, $iend, $icase, $icompare, 1, $isubitem, $brow)
	If @error Then Return SetError(@error, 0, -1)
	Local $iindex = 0, $avresult[UBound($aarray, ($brow ? $ubound_columns : $ubound_rows))]
	Do
		$avresult[$iindex] = $istart
		$iindex += 1
		$istart = _arraysearch($aarray, $vvalue, $istart + 1, $iend, $icase, $icompare, 1, $isubitem, $brow)
	Until @error
	ReDim $avresult[$iindex]
	Return $avresult
EndFunc

Func _arrayinsert(ByRef $aarray, $vrange, $vvalue = "", $istart = 0, $sdelim_item = "|", $sdelim_row = @CRLF, $iforce = $arrayfill_force_default)
	If $vvalue = Default Then $vvalue = ""
	If $istart = Default Then $istart = 0
	If $sdelim_item = Default Then $sdelim_item = "|"
	If $sdelim_row = Default Then $sdelim_row = @CRLF
	If $iforce = Default Then $iforce = $arrayfill_force_default
	If NOT IsArray($aarray) Then Return SetError(1, 0, -1)
	Local $idim_1 = UBound($aarray, $ubound_rows) - 1
	Local $hdatatype = 0
	Switch $iforce
		Case $arrayfill_force_int
			$hdatatype = Int
		Case $arrayfill_force_number
			$hdatatype = Number
		Case $arrayfill_force_ptr
			$hdatatype = Ptr
		Case $arrayfill_force_hwnd
			$hdatatype = HWnd
		Case $arrayfill_force_string
			$hdatatype = String
	EndSwitch
	Local $asplit_1, $asplit_2
	If IsArray($vrange) Then
		If UBound($vrange, $ubound_dimensions) <> 1 OR UBound($vrange, $ubound_rows) < 2 Then Return SetError(4, 0, -1)
	Else
		Local $inumber
		$vrange = StringStripWS($vrange, 8)
		$asplit_1 = StringSplit($vrange, ";")
		$vrange = ""
		For $i = 1 To $asplit_1[0]
			If NOT StringRegExp($asplit_1[$i], "^\d+(-\d+)?$") Then Return SetError(3, 0, -1)
			$asplit_2 = StringSplit($asplit_1[$i], "-")
			Switch $asplit_2[0]
				Case 1
					$vrange &= $asplit_2[1] & ";"
				Case 2
					If Number($asplit_2[2]) >= Number($asplit_2[1]) Then
						$inumber = $asplit_2[1] - 1
						Do
							$inumber += 1
							$vrange &= $inumber & ";"
						Until $inumber = $asplit_2[2]
					EndIf
			EndSwitch
		Next
		$vrange = StringSplit(StringTrimRight($vrange, 1), ";")
	EndIf
	If $vrange[1] < 0 OR $vrange[$vrange[0]] > $idim_1 Then Return SetError(5, 0, -1)
	For $i = 2 To $vrange[0]
		If $vrange[$i] < $vrange[$i - 1] Then Return SetError(3, 0, -1)
	Next
	Local $icopyto_index = $idim_1 + $vrange[0]
	Local $iinsertpoint_index = $vrange[0]
	Local $iinsert_index = $vrange[$iinsertpoint_index]
	Switch UBound($aarray, $ubound_dimensions)
		Case 1
			If $iforce = $arrayfill_force_singleitem Then
				ReDim $aarray[$idim_1 + $vrange[0] + 1]
				For $ireadfromindex = $idim_1 To 0 Step -1
					$aarray[$icopyto_index] = $aarray[$ireadfromindex]
					$icopyto_index -= 1
					$iinsert_index = $vrange[$iinsertpoint_index]
					While $ireadfromindex = $iinsert_index
						$aarray[$icopyto_index] = $vvalue
						$icopyto_index -= 1
						$iinsertpoint_index -= 1
						If $iinsertpoint_index < 1 Then ExitLoop 2
						$iinsert_index = $vrange[$iinsertpoint_index]
					WEnd
				Next
				Return $idim_1 + $vrange[0] + 1
			EndIf
			ReDim $aarray[$idim_1 + $vrange[0] + 1]
			If IsArray($vvalue) Then
				If UBound($vvalue, $ubound_dimensions) <> 1 Then Return SetError(5, 0, -1)
				$hdatatype = 0
			Else
				Local $atmp = StringSplit($vvalue, $sdelim_item, $str_nocount + $str_entiresplit)
				If UBound($atmp, $ubound_rows) = 1 Then
					$atmp[0] = $vvalue
					$hdatatype = 0
				EndIf
				$vvalue = $atmp
			EndIf
			For $ireadfromindex = $idim_1 To 0 Step -1
				$aarray[$icopyto_index] = $aarray[$ireadfromindex]
				$icopyto_index -= 1
				$iinsert_index = $vrange[$iinsertpoint_index]
				While $ireadfromindex = $iinsert_index
					If $iinsertpoint_index <= UBound($vvalue, $ubound_rows) Then
						If IsFunc($hdatatype) Then
							$aarray[$icopyto_index] = $hdatatype($vvalue[$iinsertpoint_index - 1])
						Else
							$aarray[$icopyto_index] = $vvalue[$iinsertpoint_index - 1]
						EndIf
					Else
						$aarray[$icopyto_index] = ""
					EndIf
					$icopyto_index -= 1
					$iinsertpoint_index -= 1
					If $iinsertpoint_index = 0 Then ExitLoop 2
					$iinsert_index = $vrange[$iinsertpoint_index]
				WEnd
			Next
		Case 2
			Local $idim_2 = UBound($aarray, $ubound_columns)
			If $istart < 0 OR $istart > $idim_2 - 1 Then Return SetError(6, 0, -1)
			Local $ivaldim_1, $ivaldim_2
			If IsArray($vvalue) Then
				If UBound($vvalue, $ubound_dimensions) <> 2 Then Return SetError(7, 0, -1)
				$ivaldim_1 = UBound($vvalue, $ubound_rows)
				$ivaldim_2 = UBound($vvalue, $ubound_columns)
				$hdatatype = 0
			Else
				$asplit_1 = StringSplit($vvalue, $sdelim_row, $str_nocount + $str_entiresplit)
				$ivaldim_1 = UBound($asplit_1, $ubound_rows)
				StringReplace($asplit_1[0], $sdelim_item, "")
				$ivaldim_2 = @extended + 1
				Local $atmp[$ivaldim_1][$ivaldim_2]
				For $i = 0 To $ivaldim_1 - 1
					$asplit_2 = StringSplit($asplit_1[$i], $sdelim_item, $str_nocount + $str_entiresplit)
					For $j = 0 To $ivaldim_2 - 1
						$atmp[$i][$j] = $asplit_2[$j]
					Next
				Next
				$vvalue = $atmp
			EndIf
			If UBound($vvalue, $ubound_columns) + $istart > UBound($aarray, $ubound_columns) Then Return SetError(8, 0, -1)
			ReDim $aarray[$idim_1 + $vrange[0] + 1][$idim_2]
			For $ireadfromindex = $idim_1 To 0 Step -1
				For $j = 0 To $idim_2 - 1
					$aarray[$icopyto_index][$j] = $aarray[$ireadfromindex][$j]
				Next
				$icopyto_index -= 1
				$iinsert_index = $vrange[$iinsertpoint_index]
				While $ireadfromindex = $iinsert_index
					For $j = 0 To $idim_2 - 1
						If $j < $istart Then
							$aarray[$icopyto_index][$j] = ""
						ElseIf $j - $istart > $ivaldim_2 - 1 Then
							$aarray[$icopyto_index][$j] = ""
						Else
							If $iinsertpoint_index - 1 < $ivaldim_1 Then
								If IsFunc($hdatatype) Then
									$aarray[$icopyto_index][$j] = $hdatatype($vvalue[$iinsertpoint_index - 1][$j - $istart])
								Else
									$aarray[$icopyto_index][$j] = $vvalue[$iinsertpoint_index - 1][$j - $istart]
								EndIf
							Else
								$aarray[$icopyto_index][$j] = ""
							EndIf
						EndIf
					Next
					$icopyto_index -= 1
					$iinsertpoint_index -= 1
					If $iinsertpoint_index = 0 Then ExitLoop 2
					$iinsert_index = $vrange[$iinsertpoint_index]
				WEnd
			Next
		Case Else
			Return SetError(2, 0, -1)
	EndSwitch
	Return UBound($aarray, $ubound_rows)
EndFunc

Func _arraymax(Const ByRef $aarray, $icompnumeric = 0, $istart = -1, $iend = -1, $isubitem = 0)
	Local $iresult = _arraymaxindex($aarray, $icompnumeric, $istart, $iend, $isubitem)
	If @error Then Return SetError(@error, 0, "")
	If UBound($aarray, $ubound_dimensions) = 1 Then
		Return $aarray[$iresult]
	Else
		Return $aarray[$iresult][$isubitem]
	EndIf
EndFunc

Func _arraymaxindex(Const ByRef $aarray, $icompnumeric = 0, $istart = -1, $iend = -1, $isubitem = 0)
	If $icompnumeric = Default Then $icompnumeric = 0
	If $istart = Default Then $istart = -1
	If $iend = Default Then $iend = -1
	If $isubitem = Default Then $isubitem = 0
	Local $iret = __array_minmaxindex($aarray, $icompnumeric, $istart, $iend, $isubitem, __array_greaterthan)
	Return SetError(@error, 0, $iret)
EndFunc

Func _arraymin(Const ByRef $aarray, $icompnumeric = 0, $istart = -1, $iend = -1, $isubitem = 0)
	Local $iresult = _arrayminindex($aarray, $icompnumeric, $istart, $iend, $isubitem)
	If @error Then Return SetError(@error, 0, "")
	If UBound($aarray, $ubound_dimensions) = 1 Then
		Return $aarray[$iresult]
	Else
		Return $aarray[$iresult][$isubitem]
	EndIf
EndFunc

Func _arrayminindex(Const ByRef $aarray, $icompnumeric = 0, $istart = -1, $iend = -1, $isubitem = 0)
	If $icompnumeric = Default Then $icompnumeric = 0
	If $istart = Default Then $istart = -1
	If $iend = Default Then $iend = -1
	If $isubitem = Default Then $isubitem = 0
	Local $iret = __array_minmaxindex($aarray, $icompnumeric, $istart, $iend, $isubitem, __array_lessthan)
	Return SetError(@error, 0, $iret)
EndFunc

Func _arraypermute(ByRef $aarray, $sdelimiter = "")
	If $sdelimiter = Default Then $sdelimiter = ""
	If NOT IsArray($aarray) Then Return SetError(1, 0, 0)
	If UBound($aarray, $ubound_dimensions) <> 1 Then Return SetError(2, 0, 0)
	Local $isize = UBound($aarray), $ifactorial = 1, $aidx[$isize], $aresult[1], $icount = 1
	If UBound($aarray) Then
		For $i = 0 To $isize - 1
			$aidx[$i] = $i
		Next
		For $i = $isize To 1 Step -1
			$ifactorial *= $i
		Next
		ReDim $aresult[$ifactorial + 1]
		$aresult[0] = $ifactorial
		__array_exeterinternal($aarray, 0, $isize, $sdelimiter, $aidx, $aresult, $icount)
	Else
		$aresult[0] = 0
	EndIf
	Return $aresult
EndFunc

Func _arraypop(ByRef $aarray)
	If (NOT IsArray($aarray)) Then Return SetError(1, 0, "")
	If UBound($aarray, $ubound_dimensions) <> 1 Then Return SetError(2, 0, "")
	Local $iubound = UBound($aarray) - 1
	If $iubound = -1 Then Return SetError(3, 0, "")
	Local $slastval = $aarray[$iubound]
	If $iubound > -1 Then
		ReDim $aarray[$iubound]
	EndIf
	Return $slastval
EndFunc

Func _arraypush(ByRef $aarray, $vvalue, $idirection = 0)
	If $idirection = Default Then $idirection = 0
	If (NOT IsArray($aarray)) Then Return SetError(1, 0, 0)
	If UBound($aarray, $ubound_dimensions) <> 1 Then Return SetError(3, 0, 0)
	Local $iubound = UBound($aarray) - 1
	If IsArray($vvalue) Then
		Local $iubounds = UBound($vvalue)
		If ($iubounds - 1) > $iubound Then Return SetError(2, 0, 0)
		If $idirection Then
			For $i = $iubound To $iubounds Step -1
				$aarray[$i] = $aarray[$i - $iubounds]
			Next
			For $i = 0 To $iubounds - 1
				$aarray[$i] = $vvalue[$i]
			Next
		Else
			For $i = 0 To $iubound - $iubounds
				$aarray[$i] = $aarray[$i + $iubounds]
			Next
			For $i = 0 To $iubounds - 1
				$aarray[$i + $iubound - $iubounds + 1] = $vvalue[$i]
			Next
		EndIf
	Else
		If $iubound > -1 Then
			If $idirection Then
				For $i = $iubound To 1 Step -1
					$aarray[$i] = $aarray[$i - 1]
				Next
				$aarray[0] = $vvalue
			Else
				For $i = 0 To $iubound - 1
					$aarray[$i] = $aarray[$i + 1]
				Next
				$aarray[$iubound] = $vvalue
			EndIf
		EndIf
	EndIf
	Return 1
EndFunc

Func _arrayreverse(ByRef $aarray, $istart = 0, $iend = 0)
	If $istart = Default Then $istart = 0
	If $iend = Default Then $iend = 0
	If NOT IsArray($aarray) Then Return SetError(1, 0, 0)
	If UBound($aarray, $ubound_dimensions) <> 1 Then Return SetError(3, 0, 0)
	If NOT UBound($aarray) Then Return SetError(4, 0, 0)
	Local $vtmp, $iubound = UBound($aarray) - 1
	If $iend < 1 OR $iend > $iubound Then $iend = $iubound
	If $istart < 0 Then $istart = 0
	If $istart > $iend Then Return SetError(2, 0, 0)
	For $i = $istart To Int(($istart + $iend - 1) / 2)
		$vtmp = $aarray[$i]
		$aarray[$i] = $aarray[$iend]
		$aarray[$iend] = $vtmp
		$iend -= 1
	Next
	Return 1
EndFunc

Func _arraysearch(Const ByRef $aarray, $vvalue, $istart = 0, $iend = 0, $icase = 0, $icompare = 0, $iforward = 1, $isubitem = -1, $brow = False)
	If $istart = Default Then $istart = 0
	If $iend = Default Then $iend = 0
	If $icase = Default Then $icase = 0
	If $icompare = Default Then $icompare = 0
	If $iforward = Default Then $iforward = 1
	If $isubitem = Default Then $isubitem = -1
	If $brow = Default Then $brow = False
	If NOT IsArray($aarray) Then Return SetError(1, 0, -1)
	Local $idim_1 = UBound($aarray) - 1
	If $idim_1 = -1 Then Return SetError(3, 0, -1)
	Local $idim_2 = UBound($aarray, $ubound_columns) - 1
	Local $bcomptype = False
	If $icompare = 2 Then
		$icompare = 0
		$bcomptype = True
	EndIf
	If $brow Then
		If UBound($aarray, $ubound_dimensions) = 1 Then Return SetError(5, 0, -1)
		If $iend < 1 OR $iend > $idim_2 Then $iend = $idim_2
		If $istart < 0 Then $istart = 0
		If $istart > $iend Then Return SetError(4, 0, -1)
	Else
		If $iend < 1 OR $iend > $idim_1 Then $iend = $idim_1
		If $istart < 0 Then $istart = 0
		If $istart > $iend Then Return SetError(4, 0, -1)
	EndIf
	Local $istep = 1
	If NOT $iforward Then
		Local $itmp = $istart
		$istart = $iend
		$iend = $itmp
		$istep = -1
	EndIf
	Switch UBound($aarray, $ubound_dimensions)
		Case 1
			If NOT $icompare Then
				If NOT $icase Then
					For $i = $istart To $iend Step $istep
						If $bcomptype AND VarGetType($aarray[$i]) <> VarGetType($vvalue) Then ContinueLoop
						If $aarray[$i] = $vvalue Then Return $i
					Next
				Else
					For $i = $istart To $iend Step $istep
						If $bcomptype AND VarGetType($aarray[$i]) <> VarGetType($vvalue) Then ContinueLoop
						If $aarray[$i] == $vvalue Then Return $i
					Next
				EndIf
			Else
				For $i = $istart To $iend Step $istep
					If $icompare = 3 Then
						If StringRegExp($aarray[$i], $vvalue) Then Return $i
					Else
						If StringInStr($aarray[$i], $vvalue, $icase) > 0 Then Return $i
					EndIf
				Next
			EndIf
		Case 2
			Local $idim_sub
			If $brow Then
				$idim_sub = $idim_1
				If $isubitem > $idim_sub Then $isubitem = $idim_sub
				If $isubitem < 0 Then
					$isubitem = 0
				Else
					$idim_sub = $isubitem
				EndIf
			Else
				$idim_sub = $idim_2
				If $isubitem > $idim_sub Then $isubitem = $idim_sub
				If $isubitem < 0 Then
					$isubitem = 0
				Else
					$idim_sub = $isubitem
				EndIf
			EndIf
			For $j = $isubitem To $idim_sub
				If NOT $icompare Then
					If NOT $icase Then
						For $i = $istart To $iend Step $istep
							If $brow Then
								If $bcomptype AND VarGetType($aarray[$j][$j]) <> VarGetType($vvalue) Then ContinueLoop
								If $aarray[$j][$i] = $vvalue Then Return $i
							Else
								If $bcomptype AND VarGetType($aarray[$i][$j]) <> VarGetType($vvalue) Then ContinueLoop
								If $aarray[$i][$j] = $vvalue Then Return $i
							EndIf
						Next
					Else
						For $i = $istart To $iend Step $istep
							If $brow Then
								If $bcomptype AND VarGetType($aarray[$j][$i]) <> VarGetType($vvalue) Then ContinueLoop
								If $aarray[$j][$i] == $vvalue Then Return $i
							Else
								If $bcomptype AND VarGetType($aarray[$i][$j]) <> VarGetType($vvalue) Then ContinueLoop
								If $aarray[$i][$j] == $vvalue Then Return $i
							EndIf
						Next
					EndIf
				Else
					For $i = $istart To $iend Step $istep
						If $icompare = 3 Then
							If $brow Then
								If StringRegExp($aarray[$j][$i], $vvalue) Then Return $i
							Else
								If StringRegExp($aarray[$i][$j], $vvalue) Then Return $i
							EndIf
						Else
							If $brow Then
								If StringInStr($aarray[$j][$i], $vvalue, $icase) > 0 Then Return $i
							Else
								If StringInStr($aarray[$i][$j], $vvalue, $icase) > 0 Then Return $i
							EndIf
						EndIf
					Next
				EndIf
			Next
		Case Else
			Return SetError(2, 0, -1)
	EndSwitch
	Return SetError(6, 0, -1)
EndFunc

Func _arrayshuffle(ByRef $aarray, $istart_row = 0, $iend_row = 0, $icol = -1)
	If $istart_row = Default Then $istart_row = 0
	If $iend_row = Default Then $iend_row = 0
	If $icol = Default Then $icol = -1
	If NOT IsArray($aarray) Then Return SetError(1, 0, -1)
	Local $idim_1 = UBound($aarray, $ubound_rows)
	If $iend_row = 0 Then $iend_row = $idim_1 - 1
	If $istart_row < 0 OR $istart_row > $idim_1 - 1 Then Return SetError(3, 0, -1)
	If $iend_row < 1 OR $iend_row > $idim_1 - 1 Then Return SetError(3, 0, -1)
	If $istart_row > $iend_row Then Return SetError(4, 0, -1)
	Local $vtmp, $irand
	Switch UBound($aarray, $ubound_dimensions)
		Case 1
			For $i = $iend_row To $istart_row + 1 Step -1
				$irand = Random($istart_row, $i, 1)
				$vtmp = $aarray[$i]
				$aarray[$i] = $aarray[$irand]
				$aarray[$irand] = $vtmp
			Next
			Return 1
		Case 2
			Local $idim_2 = UBound($aarray, $ubound_columns)
			If $icol < -1 OR $icol > $idim_2 - 1 Then Return SetError(5, 0, -1)
			Local $icol_start, $icol_end
			If $icol = -1 Then
				$icol_start = 0
				$icol_end = $idim_2 - 1
			Else
				$icol_start = $icol
				$icol_end = $icol
			EndIf
			For $i = $iend_row To $istart_row + 1 Step -1
				$irand = Random($istart_row, $i, 1)
				For $j = $icol_start To $icol_end
					$vtmp = $aarray[$i][$j]
					$aarray[$i][$j] = $aarray[$irand][$j]
					$aarray[$irand][$j] = $vtmp
				Next
			Next
			Return 1
		Case Else
			Return SetError(2, 0, -1)
	EndSwitch
EndFunc

Func _arraysort(ByRef $aarray, $idescending = 0, $istart = 0, $iend = 0, $isubitem = 0, $ipivot = 0)
	If $idescending = Default Then $idescending = 0
	If $istart = Default Then $istart = 0
	If $iend = Default Then $iend = 0
	If $isubitem = Default Then $isubitem = 0
	If $ipivot = Default Then $ipivot = 0
	If NOT IsArray($aarray) Then Return SetError(1, 0, 0)
	Local $iubound = UBound($aarray) - 1
	If $iubound = -1 Then Return SetError(5, 0, 0)
	If $iend = Default Then $iend = 0
	If $iend < 1 OR $iend > $iubound OR $iend = Default Then $iend = $iubound
	If $istart < 0 OR $istart = Default Then $istart = 0
	If $istart > $iend Then Return SetError(2, 0, 0)
	If $idescending = Default Then $idescending = 0
	If $ipivot = Default Then $ipivot = 0
	If $isubitem = Default Then $isubitem = 0
	Switch UBound($aarray, $ubound_dimensions)
		Case 1
			If $ipivot Then
				__arraydualpivotsort($aarray, $istart, $iend)
			Else
				__arrayquicksort1d($aarray, $istart, $iend)
			EndIf
			If $idescending Then _arrayreverse($aarray, $istart, $iend)
		Case 2
			If $ipivot Then Return SetError(6, 0, 0)
			Local $isubmax = UBound($aarray, $ubound_columns) - 1
			If $isubitem > $isubmax Then Return SetError(3, 0, 0)
			If $idescending Then
				$idescending = -1
			Else
				$idescending = 1
			EndIf
			__arrayquicksort2d($aarray, $idescending, $istart, $iend, $isubitem, $isubmax)
		Case Else
			Return SetError(4, 0, 0)
	EndSwitch
	Return 1
EndFunc

Func __arrayquicksort1d(ByRef $aarray, Const ByRef $istart, Const ByRef $iend)
	If $iend <= $istart Then Return
	Local $vtmp
	If ($iend - $istart) < 15 Then
		Local $vcur
		For $i = $istart + 1 To $iend
			$vtmp = $aarray[$i]
			If IsNumber($vtmp) Then
				For $j = $i - 1 To $istart Step -1
					$vcur = $aarray[$j]
					If ($vtmp >= $vcur AND IsNumber($vcur)) OR (NOT IsNumber($vcur) AND StringCompare($vtmp, $vcur) >= 0) Then ExitLoop
					$aarray[$j + 1] = $vcur
				Next
			Else
				For $j = $i - 1 To $istart Step -1
					If (StringCompare($vtmp, $aarray[$j]) >= 0) Then ExitLoop
					$aarray[$j + 1] = $aarray[$j]
				Next
			EndIf
			$aarray[$j + 1] = $vtmp
		Next
		Return
	EndIf
	Local $l = $istart, $r = $iend, $vpivot = $aarray[Int(($istart + $iend) / 2)], $bnum = IsNumber($vpivot)
	Do
		If $bnum Then
			While ($aarray[$l] < $vpivot AND IsNumber($aarray[$l])) OR (NOT IsNumber($aarray[$l]) AND StringCompare($aarray[$l], $vpivot) < 0)
				$l += 1
			WEnd
			While ($aarray[$r] > $vpivot AND IsNumber($aarray[$r])) OR (NOT IsNumber($aarray[$r]) AND StringCompare($aarray[$r], $vpivot) > 0)
				$r -= 1
			WEnd
		Else
			While (StringCompare($aarray[$l], $vpivot) < 0)
				$l += 1
			WEnd
			While (StringCompare($aarray[$r], $vpivot) > 0)
				$r -= 1
			WEnd
		EndIf
		If $l <= $r Then
			$vtmp = $aarray[$l]
			$aarray[$l] = $aarray[$r]
			$aarray[$r] = $vtmp
			$l += 1
			$r -= 1
		EndIf
	Until $l > $r
	__arrayquicksort1d($aarray, $istart, $r)
	__arrayquicksort1d($aarray, $l, $iend)
EndFunc

Func __arrayquicksort2d(ByRef $aarray, Const ByRef $istep, Const ByRef $istart, Const ByRef $iend, Const ByRef $isubitem, Const ByRef $isubmax)
	If $iend <= $istart Then Return
	Local $vtmp, $l = $istart, $r = $iend, $vpivot = $aarray[Int(($istart + $iend) / 2)][$isubitem], $bnum = IsNumber($vpivot)
	Do
		If $bnum Then
			While ($istep * ($aarray[$l][$isubitem] - $vpivot) < 0 AND IsNumber($aarray[$l][$isubitem])) OR (NOT IsNumber($aarray[$l][$isubitem]) AND $istep * StringCompare($aarray[$l][$isubitem], $vpivot) < 0)
				$l += 1
			WEnd
			While ($istep * ($aarray[$r][$isubitem] - $vpivot) > 0 AND IsNumber($aarray[$r][$isubitem])) OR (NOT IsNumber($aarray[$r][$isubitem]) AND $istep * StringCompare($aarray[$r][$isubitem], $vpivot) > 0)
				$r -= 1
			WEnd
		Else
			While ($istep * StringCompare($aarray[$l][$isubitem], $vpivot) < 0)
				$l += 1
			WEnd
			While ($istep * StringCompare($aarray[$r][$isubitem], $vpivot) > 0)
				$r -= 1
			WEnd
		EndIf
		If $l <= $r Then
			For $i = 0 To $isubmax
				$vtmp = $aarray[$l][$i]
				$aarray[$l][$i] = $aarray[$r][$i]
				$aarray[$r][$i] = $vtmp
			Next
			$l += 1
			$r -= 1
		EndIf
	Until $l > $r
	__arrayquicksort2d($aarray, $istep, $istart, $r, $isubitem, $isubmax)
	__arrayquicksort2d($aarray, $istep, $l, $iend, $isubitem, $isubmax)
EndFunc

Func __arraydualpivotsort(ByRef $aarray, $ipivot_left, $ipivot_right, $bleftmost = True)
	If $ipivot_left > $ipivot_right Then Return
	Local $ilength = $ipivot_right - $ipivot_left + 1
	Local $i, $j, $k, $iai, $iak, $ia1, $ia2, $ilast
	If $ilength < 45 Then
		If $bleftmost Then
			$i = $ipivot_left
			While $i < $ipivot_right
				$j = $i
				$iai = $aarray[$i + 1]
				While $iai < $aarray[$j]
					$aarray[$j + 1] = $aarray[$j]
					$j -= 1
					If $j + 1 = $ipivot_left Then ExitLoop
				WEnd
				$aarray[$j + 1] = $iai
				$i += 1
			WEnd
		Else
			While 1
				If $ipivot_left >= $ipivot_right Then Return 1
				$ipivot_left += 1
				If $aarray[$ipivot_left] < $aarray[$ipivot_left - 1] Then ExitLoop
			WEnd
			While 1
				$k = $ipivot_left
				$ipivot_left += 1
				If $ipivot_left > $ipivot_right Then ExitLoop
				$ia1 = $aarray[$k]
				$ia2 = $aarray[$ipivot_left]
				If $ia1 < $ia2 Then
					$ia2 = $ia1
					$ia1 = $aarray[$ipivot_left]
				EndIf
				$k -= 1
				While $ia1 < $aarray[$k]
					$aarray[$k + 2] = $aarray[$k]
					$k -= 1
				WEnd
				$aarray[$k + 2] = $ia1
				While $ia2 < $aarray[$k]
					$aarray[$k + 1] = $aarray[$k]
					$k -= 1
				WEnd
				$aarray[$k + 1] = $ia2
				$ipivot_left += 1
			WEnd
			$ilast = $aarray[$ipivot_right]
			$ipivot_right -= 1
			While $ilast < $aarray[$ipivot_right]
				$aarray[$ipivot_right + 1] = $aarray[$ipivot_right]
				$ipivot_right -= 1
			WEnd
			$aarray[$ipivot_right + 1] = $ilast
		EndIf
		Return 1
	EndIf
	Local $iseventh = BitShift($ilength, 3) + BitShift($ilength, 6) + 1
	Local $ie1, $ie2, $ie3, $ie4, $ie5, $t
	$ie3 = Ceiling(($ipivot_left + $ipivot_right) / 2)
	$ie2 = $ie3 - $iseventh
	$ie1 = $ie2 - $iseventh
	$ie4 = $ie3 + $iseventh
	$ie5 = $ie4 + $iseventh
	If $aarray[$ie2] < $aarray[$ie1] Then
		$t = $aarray[$ie2]
		$aarray[$ie2] = $aarray[$ie1]
		$aarray[$ie1] = $t
	EndIf
	If $aarray[$ie3] < $aarray[$ie2] Then
		$t = $aarray[$ie3]
		$aarray[$ie3] = $aarray[$ie2]
		$aarray[$ie2] = $t
		If $t < $aarray[$ie1] Then
			$aarray[$ie2] = $aarray[$ie1]
			$aarray[$ie1] = $t
		EndIf
	EndIf
	If $aarray[$ie4] < $aarray[$ie3] Then
		$t = $aarray[$ie4]
		$aarray[$ie4] = $aarray[$ie3]
		$aarray[$ie3] = $t
		If $t < $aarray[$ie2] Then
			$aarray[$ie3] = $aarray[$ie2]
			$aarray[$ie2] = $t
			If $t < $aarray[$ie1] Then
				$aarray[$ie2] = $aarray[$ie1]
				$aarray[$ie1] = $t
			EndIf
		EndIf
	EndIf
	If $aarray[$ie5] < $aarray[$ie4] Then
		$t = $aarray[$ie5]
		$aarray[$ie5] = $aarray[$ie4]
		$aarray[$ie4] = $t
		If $t < $aarray[$ie3] Then
			$aarray[$ie4] = $aarray[$ie3]
			$aarray[$ie3] = $t
			If $t < $aarray[$ie2] Then
				$aarray[$ie3] = $aarray[$ie2]
				$aarray[$ie2] = $t
				If $t < $aarray[$ie1] Then
					$aarray[$ie2] = $aarray[$ie1]
					$aarray[$ie1] = $t
				EndIf
			EndIf
		EndIf
	EndIf
	Local $iless = $ipivot_left
	Local $igreater = $ipivot_right
	If (($aarray[$ie1] <> $aarray[$ie2]) AND ($aarray[$ie2] <> $aarray[$ie3]) AND ($aarray[$ie3] <> $aarray[$ie4]) AND ($aarray[$ie4] <> $aarray[$ie5])) Then
		Local $ipivot_1 = $aarray[$ie2]
		Local $ipivot_2 = $aarray[$ie4]
		$aarray[$ie2] = $aarray[$ipivot_left]
		$aarray[$ie4] = $aarray[$ipivot_right]
		Do
			$iless += 1
		Until $aarray[$iless] >= $ipivot_1
		Do
			$igreater -= 1
		Until $aarray[$igreater] <= $ipivot_2
		$k = $iless
		While $k <= $igreater
			$iak = $aarray[$k]
			If $iak < $ipivot_1 Then
				$aarray[$k] = $aarray[$iless]
				$aarray[$iless] = $iak
				$iless += 1
			ElseIf $iak > $ipivot_2 Then
				While $aarray[$igreater] > $ipivot_2
					$igreater -= 1
					If $igreater + 1 = $k Then ExitLoop 2
				WEnd
				If $aarray[$igreater] < $ipivot_1 Then
					$aarray[$k] = $aarray[$iless]
					$aarray[$iless] = $aarray[$igreater]
					$iless += 1
				Else
					$aarray[$k] = $aarray[$igreater]
				EndIf
				$aarray[$igreater] = $iak
				$igreater -= 1
			EndIf
			$k += 1
		WEnd
		$aarray[$ipivot_left] = $aarray[$iless - 1]
		$aarray[$iless - 1] = $ipivot_1
		$aarray[$ipivot_right] = $aarray[$igreater + 1]
		$aarray[$igreater + 1] = $ipivot_2
		__arraydualpivotsort($aarray, $ipivot_left, $iless - 2, True)
		__arraydualpivotsort($aarray, $igreater + 2, $ipivot_right, False)
		If ($iless < $ie1) AND ($ie5 < $igreater) Then
			While $aarray[$iless] = $ipivot_1
				$iless += 1
			WEnd
			While $aarray[$igreater] = $ipivot_2
				$igreater -= 1
			WEnd
			$k = $iless
			While $k <= $igreater
				$iak = $aarray[$k]
				If $iak = $ipivot_1 Then
					$aarray[$k] = $aarray[$iless]
					$aarray[$iless] = $iak
					$iless += 1
				ElseIf $iak = $ipivot_2 Then
					While $aarray[$igreater] = $ipivot_2
						$igreater -= 1
						If $igreater + 1 = $k Then ExitLoop 2
					WEnd
					If $aarray[$igreater] = $ipivot_1 Then
						$aarray[$k] = $aarray[$iless]
						$aarray[$iless] = $ipivot_1
						$iless += 1
					Else
						$aarray[$k] = $aarray[$igreater]
					EndIf
					$aarray[$igreater] = $iak
					$igreater -= 1
				EndIf
				$k += 1
			WEnd
		EndIf
		__arraydualpivotsort($aarray, $iless, $igreater, False)
	Else
		Local $ipivot = $aarray[$ie3]
		$k = $iless
		While $k <= $igreater
			If $aarray[$k] = $ipivot Then
				$k += 1
				ContinueLoop
			EndIf
			$iak = $aarray[$k]
			If $iak < $ipivot Then
				$aarray[$k] = $aarray[$iless]
				$aarray[$iless] = $iak
				$iless += 1
			Else
				While $aarray[$igreater] > $ipivot
					$igreater -= 1
				WEnd
				If $aarray[$igreater] < $ipivot Then
					$aarray[$k] = $aarray[$iless]
					$aarray[$iless] = $aarray[$igreater]
					$iless += 1
				Else
					$aarray[$k] = $ipivot
				EndIf
				$aarray[$igreater] = $iak
				$igreater -= 1
			EndIf
			$k += 1
		WEnd
		__arraydualpivotsort($aarray, $ipivot_left, $iless - 1, True)
		__arraydualpivotsort($aarray, $igreater + 1, $ipivot_right, False)
	EndIf
EndFunc

Func _arrayswap(ByRef $aarray, $iindex_1, $iindex_2, $bcol = False, $istart = -1, $iend = -1)
	If $bcol = Default Then $bcol = False
	If $istart = Default Then $istart = -1
	If $iend = Default Then $iend = -1
	If NOT IsArray($aarray) Then Return SetError(1, 0, -1)
	Local $idim_1 = UBound($aarray, $ubound_rows) - 1
	Local $idim_2 = UBound($aarray, $ubound_columns) - 1
	If $idim_2 = -1 Then
		$bcol = False
		$istart = -1
		$iend = -1
	EndIf
	If $istart > $iend Then Return SetError(5, 0, -1)
	If $bcol Then
		If $iindex_1 < 0 OR $iindex_2 > $idim_2 Then Return SetError(3, 0, -1)
		If $istart = -1 Then $istart = 0
		If $iend = -1 Then $iend = $idim_1
	Else
		If $iindex_1 < 0 OR $iindex_2 > $idim_1 Then Return SetError(3, 0, -1)
		If $istart = -1 Then $istart = 0
		If $iend = -1 Then $iend = $idim_2
	EndIf
	Local $vtmp
	Switch UBound($aarray, $ubound_dimensions)
		Case 1
			$vtmp = $aarray[$iindex_1]
			$aarray[$iindex_1] = $aarray[$iindex_2]
			$aarray[$iindex_2] = $vtmp
		Case 2
			If $istart < -1 OR $iend < -1 Then Return SetError(4, 0, -1)
			If $bcol Then
				If $istart > $idim_1 OR $iend > $idim_1 Then Return SetError(4, 0, -1)
				For $j = $istart To $iend
					$vtmp = $aarray[$j][$iindex_1]
					$aarray[$j][$iindex_1] = $aarray[$j][$iindex_2]
					$aarray[$j][$iindex_2] = $vtmp
				Next
			Else
				If $istart > $idim_2 OR $iend > $idim_2 Then Return SetError(4, 0, -1)
				For $j = $istart To $iend
					$vtmp = $aarray[$iindex_1][$j]
					$aarray[$iindex_1][$j] = $aarray[$iindex_2][$j]
					$aarray[$iindex_2][$j] = $vtmp
				Next
			EndIf
		Case Else
			Return SetError(2, 0, -1)
	EndSwitch
	Return 1
EndFunc

Func _arraytoclip(Const ByRef $aarray, $sdelim_col = "|", $istart_row = -1, $iend_row = -1, $sdelim_row = @CRLF, $istart_col = -1, $iend_col = -1)
	Local $sresult = _arraytostring($aarray, $sdelim_col, $istart_row, $iend_row, $sdelim_row, $istart_col, $iend_col)
	If @error Then Return SetError(@error, 0, 0)
	If ClipPut($sresult) Then Return 1
	Return SetError(-1, 0, 0)
EndFunc

Func _arraytostring(Const ByRef $aarray, $sdelim_col = "|", $istart_row = -1, $iend_row = -1, $sdelim_row = @CRLF, $istart_col = -1, $iend_col = -1)
	If $sdelim_col = Default Then $sdelim_col = "|"
	If $sdelim_row = Default Then $sdelim_row = @CRLF
	If $istart_row = Default Then $istart_row = -1
	If $iend_row = Default Then $iend_row = -1
	If $istart_col = Default Then $istart_col = -1
	If $iend_col = Default Then $iend_col = -1
	If NOT IsArray($aarray) Then Return SetError(1, 0, -1)
	Local $idim_1 = UBound($aarray, $ubound_rows) - 1
	If $istart_row = -1 Then $istart_row = 0
	If $iend_row = -1 Then $iend_row = $idim_1
	If $istart_row < -1 OR $iend_row < -1 Then Return SetError(3, 0, -1)
	If $istart_row > $idim_1 OR $iend_row > $idim_1 Then Return SetError(3, 0, "")
	If $istart_row > $iend_row Then Return SetError(4, 0, -1)
	Local $sret = ""
	Switch UBound($aarray, $ubound_dimensions)
		Case 1
			For $i = $istart_row To $iend_row
				$sret &= $aarray[$i] & $sdelim_col
			Next
			Return StringTrimRight($sret, StringLen($sdelim_col))
		Case 2
			Local $idim_2 = UBound($aarray, $ubound_columns) - 1
			If $istart_col = -1 Then $istart_col = 0
			If $iend_col = -1 Then $iend_col = $idim_2
			If $istart_col < -1 OR $iend_col < -1 Then Return SetError(5, 0, -1)
			If $istart_col > $idim_2 OR $iend_col > $idim_2 Then Return SetError(5, 0, -1)
			If $istart_col > $iend_col Then Return SetError(6, 0, -1)
			For $i = $istart_row To $iend_row
				For $j = $istart_col To $iend_col
					$sret &= $aarray[$i][$j] & $sdelim_col
				Next
				$sret = StringTrimRight($sret, StringLen($sdelim_col)) & $sdelim_row
			Next
			Return StringTrimRight($sret, StringLen($sdelim_row))
		Case Else
			Return SetError(2, 0, -1)
	EndSwitch
	Return 1
EndFunc

Func _arraytranspose(ByRef $aarray)
	Switch UBound($aarray, 0)
		Case 0
			Return SetError(2, 0, 0)
		Case 1
			Local $atemp[1][UBound($aarray)]
			For $i = 0 To UBound($aarray) - 1
				$atemp[0][$i] = $aarray[$i]
			Next
			$aarray = $atemp
		Case 2
			Local $idim_1 = UBound($aarray, 1), $idim_2 = UBound($aarray, 2)
			If $idim_1 <> $idim_2 Then
				Local $atemp[$idim_2][$idim_1]
				For $i = 0 To $idim_1 - 1
					For $j = 0 To $idim_2 - 1
						$atemp[$j][$i] = $aarray[$i][$j]
					Next
				Next
				$aarray = $atemp
			Else
				Local $velement
				For $i = 0 To $idim_1 - 1
					For $j = $i + 1 To $idim_2 - 1
						$velement = $aarray[$i][$j]
						$aarray[$i][$j] = $aarray[$j][$i]
						$aarray[$j][$i] = $velement
					Next
				Next
			EndIf
		Case Else
			Return SetError(1, 0, 0)
	EndSwitch
	Return 1
EndFunc

Func _arraytrim(ByRef $aarray, $itrimnum, $idirection = 0, $istart = 0, $iend = 0, $isubitem = 0)
	If $idirection = Default Then $idirection = 0
	If $istart = Default Then $istart = 0
	If $iend = Default Then $iend = 0
	If $isubitem = Default Then $isubitem = 0
	If NOT IsArray($aarray) Then Return SetError(1, 0, 0)
	Local $idim_1 = UBound($aarray, $ubound_rows) - 1
	If $iend = 0 Then $iend = $idim_1
	If $istart > $iend Then Return SetError(3, 0, -1)
	If $istart < 0 OR $iend < 0 Then Return SetError(3, 0, -1)
	If $istart > $idim_1 OR $iend > $idim_1 Then Return SetError(3, 0, -1)
	If $istart > $iend Then Return SetError(4, 0, -1)
	Switch UBound($aarray, $ubound_dimensions)
		Case 1
			If $idirection Then
				For $i = $istart To $iend
					$aarray[$i] = StringTrimRight($aarray[$i], $itrimnum)
				Next
			Else
				For $i = $istart To $iend
					$aarray[$i] = StringTrimLeft($aarray[$i], $itrimnum)
				Next
			EndIf
		Case 2
			Local $idim_2 = UBound($aarray, $ubound_columns) - 1
			If $isubitem < 0 OR $isubitem > $idim_2 Then Return SetError(5, 0, -1)
			If $idirection Then
				For $i = $istart To $iend
					$aarray[$i][$isubitem] = StringTrimRight($aarray[$i][$isubitem], $itrimnum)
				Next
			Else
				For $i = $istart To $iend
					$aarray[$i][$isubitem] = StringTrimLeft($aarray[$i][$isubitem], $itrimnum)
				Next
			EndIf
		Case Else
			Return SetError(2, 0, 0)
	EndSwitch
	Return 1
EndFunc

Func _arrayunique(Const ByRef $aarray, $icolumn = 0, $ibase = 0, $icase = 0, $icount = $arrayunique_count, $iinttype = $arrayunique_auto)
	If $icolumn = Default Then $icolumn = 0
	If $ibase = Default Then $ibase = 0
	If $icase = Default Then $icase = 0
	If $icount = Default Then $icount = $arrayunique_count
	If UBound($aarray, $ubound_rows) = 0 Then Return SetError(1, 0, 0)
	Local $idims = UBound($aarray, $ubound_dimensions), $inumcolumns = UBound($aarray, $ubound_columns)
	If $idims > 2 Then Return SetError(2, 0, 0)
	If $ibase < 0 OR $ibase > 1 OR (NOT IsInt($ibase)) Then Return SetError(3, 0, 0)
	If $icase < 0 OR $icase > 1 OR (NOT IsInt($icase)) Then Return SetError(3, 0, 0)
	If $icount < 0 OR $icount > 1 OR (NOT IsInt($icount)) Then Return SetError(4, 0, 0)
	If $iinttype < 0 OR $iinttype > 4 OR (NOT IsInt($iinttype)) Then Return SetError(5, 0, 0)
	If $icolumn < 0 OR ($inumcolumns = 0 AND $icolumn > 0) OR ($inumcolumns > 0 AND $icolumn >= $inumcolumns) Then Return SetError(6, 0, 0)
	If $iinttype = $arrayunique_auto Then
		Local $vfirstelem = (($idims = 1) ? ($aarray[$ibase]) : ($aarray[$icolumn][$ibase]))
		If IsInt($vfirstelem) Then
			Switch VarGetType($vfirstelem)
				Case "Int32"
					$iinttype = $arrayunique_force32
				Case "Int64"
					$iinttype = $arrayunique_force64
			EndSwitch
		Else
			$iinttype = $arrayunique_force32
		EndIf
	EndIf
	ObjEvent("AutoIt.Error", "__ArrayUnique_AutoErrFunc")
	Local $odictionary = ObjCreate("Scripting.Dictionary")
	$odictionary.comparemode = Number(NOT $icase)
	Local $velem, $stype, $vkey, $bcomerror = False
	For $i = $ibase To UBound($aarray) - 1
		If $idims = 1 Then
			$velem = $aarray[$i]
		Else
			$velem = $aarray[$i][$icolumn]
		EndIf
		Switch $iinttype
			Case $arrayunique_force32
				$odictionary.item($velem)
				If @error Then
					$bcomerror = True
					ExitLoop
				EndIf
			Case $arrayunique_force64
				$stype = VarGetType($velem)
				If $stype = "Int32" Then
					$bcomerror = True
					ExitLoop
				EndIf
				$vkey = "#" & $stype & "#" & String($velem)
				If NOT $odictionary.item($vkey) Then
					$odictionary($vkey) = $velem
				EndIf
			Case $arrayunique_match
				$stype = VarGetType($velem)
				If StringLeft($stype, 3) = "Int" Then
					$vkey = "#Int#" & String($velem)
				Else
					$vkey = "#" & $stype & "#" & String($velem)
				EndIf
				If NOT $odictionary.item($vkey) Then
					$odictionary($vkey) = $velem
				EndIf
			Case $arrayunique_distinct
				$vkey = "#" & VarGetType($velem) & "#" & String($velem)
				If NOT $odictionary.item($vkey) Then
					$odictionary($vkey) = $velem
				EndIf
		EndSwitch
	Next
	Local $avalues, $j = 0
	If $bcomerror Then
		Return SetError(7, 0, 0)
	ElseIf $iinttype <> $arrayunique_force32 Then
		Local $avalues[$odictionary.count]
		For $vkey In $odictionary.keys()
			$avalues[$j] = $odictionary($vkey)
			If StringLeft($vkey, 5) = "#Ptr#" Then
				$avalues[$j] = Ptr($avalues[$j])
			EndIf
			$j += 1
		Next
	Else
		$avalues = $odictionary.keys()
	EndIf
	If $icount Then
		_arrayinsert($avalues, 0, $odictionary.count)
	EndIf
	Return $avalues
EndFunc

Func _array1dtohistogram($aarray, $isizing = 100)
	If UBound($aarray, 0) > 1 Then Return SetError(1, 0, "")
	$isizing = $isizing * 8
	Local $t, $n, $imin = 0, $imax = 0, $ioffset = 0
	For $i = 0 To UBound($aarray) - 1
		$t = $aarray[$i]
		$t = IsNumber($t) ? Round($t) : 0
		If $t < $imin Then $imin = $t
		If $t > $imax Then $imax = $t
	Next
	Local $irange = Int(Round(($imax - $imin) / 8)) * 8
	Local $ispaceratio = 4
	For $i = 0 To UBound($aarray) - 1
		$t = $aarray[$i]
		If $t Then
			$n = Abs(Round(($isizing * $t) / $irange) / 8)
			$aarray[$i] = ""
			If $t > 0 Then
				If $imin Then
					$ioffset = Int(Abs(Round(($isizing * $imin) / $irange) / 8) / 8 * $ispaceratio)
					$aarray[$i] = __array_stringrepeat(ChrW(32), $ioffset)
				EndIf
			Else
				If $imin <> $t Then
					$ioffset = Int(Abs(Round(($isizing * ($t - $imin)) / $irange) / 8) / 8 * $ispaceratio)
					$aarray[$i] = __array_stringrepeat(ChrW(32), $ioffset)
				EndIf
			EndIf
			$aarray[$i] &= __array_stringrepeat(ChrW(9608), Int($n / 8))
			$n = Mod($n, 8)
			If $n > 0 Then $aarray[$i] &= ChrW(9608 + 8 - $n)
			$aarray[$i] &= " " & $t
		Else
			$aarray[$i] = ""
		EndIf
	Next
	Return $aarray
EndFunc

Func __array_stringrepeat($sstring, $irepeatcount)
	$irepeatcount = Int($irepeatcount)
	If StringLen($sstring) < 1 OR $irepeatcount <= 0 Then Return SetError(1, 0, "")
	Local $sresult = ""
	While $irepeatcount > 1
		If BitAND($irepeatcount, 1) Then $sresult &= $sstring
		$sstring &= $sstring
		$irepeatcount = BitShift($irepeatcount, 1)
	WEnd
	Return $sstring & $sresult
EndFunc

Func __array_exeterinternal(ByRef $aarray, $istart, $isize, $sdelimiter, ByRef $aidx, ByRef $aresult, ByRef $icount)
	If $istart == $isize - 1 Then
		For $i = 0 To $isize - 1
			$aresult[$icount] &= $aarray[$aidx[$i]] & $sdelimiter
		Next
		If $sdelimiter <> "" Then $aresult[$icount] = StringTrimRight($aresult[$icount], StringLen($sdelimiter))
		$icount += 1
	Else
		Local $itemp
		For $i = $istart To $isize - 1
			$itemp = $aidx[$i]
			$aidx[$i] = $aidx[$istart]
			$aidx[$istart] = $itemp
			__array_exeterinternal($aarray, $istart + 1, $isize, $sdelimiter, $aidx, $aresult, $icount)
			$aidx[$istart] = $aidx[$i]
			$aidx[$i] = $itemp
		Next
	EndIf
EndFunc

Func __array_combinations($in, $ir)
	Local $i_total = 1
	For $i = $ir To 1 Step -1
		$i_total *= ($in / $i)
		$in -= 1
	Next
	Return Round($i_total)
EndFunc

Func __array_getnext($in, $ir, ByRef $ileft, $itotal, ByRef $aidx)
	If $ileft == $itotal Then
		$ileft -= 1
		Return
	EndIf
	Local $i = $ir - 1
	While $aidx[$i] == $in - $ir + $i
		$i -= 1
	WEnd
	$aidx[$i] += 1
	For $j = $i + 1 To $ir - 1
		$aidx[$j] = $aidx[$i] + $j - $i
	Next
	$ileft -= 1
EndFunc

Func __array_minmaxindex(Const ByRef $aarray, $icompnumeric, $istart, $iend, $isubitem, $fucomparison)
	If $icompnumeric = Default Then $icompnumeric = 0
	If $icompnumeric <> 1 Then $icompnumeric = 0
	If $istart = Default Then $istart = 0
	If $iend = Default Then $iend = 0
	If $isubitem = Default Then $isubitem = 0
	If NOT IsArray($aarray) Then Return SetError(1, 0, -1)
	Local $idim_1 = UBound($aarray, $ubound_rows) - 1
	If $idim_1 < 0 Then Return SetError(1, 0, -1)
	If $iend = -1 Then $iend = $idim_1
	If $istart = -1 Then $istart = 0
	If $istart < -1 OR $iend < -1 Then Return SetError(3, 0, -1)
	If $istart > $idim_1 OR $iend > $idim_1 Then Return SetError(3, 0, -1)
	If $istart > $iend Then Return SetError(4, 0, -1)
	If $idim_1 < 0 Then Return SetError(5, 0, -1)
	Local $imaxminindex = $istart
	Switch UBound($aarray, $ubound_dimensions)
		Case 1
			If $icompnumeric Then
				For $i = $istart To $iend
					If $fucomparison(Number($aarray[$i]), Number($aarray[$imaxminindex])) Then $imaxminindex = $i
				Next
			Else
				For $i = $istart To $iend
					If $fucomparison($aarray[$i], $aarray[$imaxminindex]) Then $imaxminindex = $i
				Next
			EndIf
		Case 2
			If $isubitem < 0 OR $isubitem > UBound($aarray, $ubound_columns) - 1 Then Return SetError(6, 0, -1)
			If $icompnumeric Then
				For $i = $istart To $iend
					If $fucomparison(Number($aarray[$i][$isubitem]), Number($aarray[$imaxminindex][$isubitem])) Then $imaxminindex = $i
				Next
			Else
				For $i = $istart To $iend
					If $fucomparison($aarray[$i][$isubitem], $aarray[$imaxminindex][$isubitem]) Then $imaxminindex = $i
				Next
			EndIf
		Case Else
			Return SetError(2, 0, -1)
	EndSwitch
	Return $imaxminindex
EndFunc

Func __array_greaterthan($vvalue1, $vvalue2)
	Return $vvalue1 > $vvalue2
EndFunc

Func __array_lessthan($vvalue1, $vvalue2)
	Return $vvalue1 < $vvalue2
EndFunc

Func __arrayunique_autoerrfunc()
EndFunc

Func canuseskill($askillslot, $askillbar, $aenergy = 0, $asoftcounter = 0)
	If $mskillsoftcounter > $asoftcounter Then Return False
	If $menergy < $aenergy Then Return False
	Local $lskillptr = $mskillbarcacheptr[$askillslot]
	If getskillbarskillrecharge($askillslot, 0, $askillbar) = 0 Then
		If getskillbarskilladrenaline($askillslot, 0, $askillbar) < $mskillbarcachearray[$askillslot][7] Then Return False
		Switch $mskillbarcachearray[$askillslot][1]
			Case 14
				If $mblind Then Return False
				If $mattackhardcounter Then Return False
				If $mattacksoftcounter > $asoftcounter Then Return False
			Case 4, 5, 6, 9, 11, 24, 25
				If $mspellsoftcounter > $asoftcounter Then Return False
				If $mdazed Then
					If $mskillbarcachearray[$askillslot][8] > 0.25 Then Return False
				EndIf
				Switch $mskillbarcachearray[$askillslot][5]
					Case 3, 4
						If $mallyspellhardcounter Then Return False
					Case 5, 16
						If $menemyspellhardcounter Then Return False
				EndSwitch
		EndSwitch
		Return True
	EndIf
	Return False
EndFunc

Func rezparty($rezskill, $ame = getagentptr(-2))
	Local $lagentx, $lagenty, $lmex, $lmey
	Local $lblocked = 0
	If memoryread($mteamdead[1] + 433, "byte") = 1 Then
		Do
			death()
			updateagentposbyptr($mteamdead[1], $lagentx, $lagenty)
			move($lagentx, $lagenty, 250)
			rndsleep(500)
			If NOT getismoving($ame) Then
				$lblocked += 1
				updateagentposbyptr($mteamdead[1], $lagentx, $lagenty)
				move($lagentx, $lagenty, 250)
				Sleep(200)
				If Mod($lblocked, 5) = 0 AND NOT getismoving($ame) Then
					$theta = Random(0, 360)
					updateagentposbyptr($ame, $lmex, $lmey)
					move(200 * Cos($theta * 0.01745) + $lmex, 200 * Sin($theta * 0.01745) + $lmey, 0)
					pingsleep(500)
				EndIf
			EndIf
			updateagentposbyptr($ame, $lmex, $lmey)
		Until computedistance($lmex, $lmey, $lagentx, $lagenty) < 600 OR $lblocked > 50
		userezskillex($rezskill, $mteamdead[1])
	EndIf
EndFunc

Func checkskillbarcache()
	For $i = 1 To 8
		If $mskillbarcache[$i] <> getskillbarskillid($i) Then
			$mskillbarcache[0] = False
			Return False
		EndIf
	Next
	Return True
EndFunc

Func cacheskillbar()
	If $mskillbarcache[0] Then Return
	If $mskillbarcachestruct[0] Then Return
	$mskillbarptr = getskillbarptr()
	For $i = 1 To 8
		$mskillbarcache[$i] = getskillbarskillid($i)
		$mskillbarcacheptr[$i] = getskillptr($mskillbarcache[$i])
		Local $lskillstruct1 = memoryreadstruct($mskillbarcacheptr[$i] + 12, "long Type;long Special;long Effect1;long Condition")
		Local $lskillstruct2 = memoryreadstruct($mskillbarcacheptr[$i] + 56, "dword Adrenaline;float Activation;float Aftercast")
		$mskillbarcachearray[$i][0] = $mskillbarcache[$i]
		$mskillbarcachearray[$i][1] = DllStructGetData($lskillstruct1, "Type")
		$mskillbarcachearray[$i][2] = DllStructGetData($lskillstruct1, "Special")
		$mskillbarcachearray[$i][3] = DllStructGetData($lskillstruct1, "Effect1")
		$mskillbarcachearray[$i][4] = DllStructGetData($lskillstruct1, "Condition")
		$mskillbarcachearray[$i][5] = memoryread($mskillbarcacheptr[$i] + 49, "byte")
		$mskillbarcachearray[$i][7] = DllStructGetData($lskillstruct2, "Adrenaline")
		$mskillbarcachearray[$i][8] = DllStructGetData($lskillstruct2, "Activation")
		$mskillbarcachearray[$i][9] = DllStructGetData($lskillstruct2, "Aftercast")
		$mskillbarcachearray[$i][10] = memoryread($mskillbarcacheptr[$i] + 79, "long")
		If $mskillbarcachearray[$i][7] > 0 Then
			$skilladrenalinereq[$i] = $mskillbarcachearray[$i][7]
			$skilladrenalinereq[0] = True
			$mskillbarcacheenergyreq[$i] = 0
			update("Skill " & $i & " requires " & $mskillbarcachearray[$i][7] & " Adrenaline.", "Skills")
		Else
			$skilladrenalinereq[$i] = 0
			Local $lenergy = memoryread($mskillbarcacheptr[$i] + 53, "byte")
			Switch $lenergy
				Case 11
					$mskillbarcachearray[$i][6] = 15
				Case 12
					$mskillbarcachearray[$i][6] = 25
				Case Else
					$mskillbarcachearray[$i][6] = $lenergy
			EndSwitch
			$mskillbarcacheenergyreq[$i] = $mskillbarcachearray[$i][6]
			update("Skill " & $i & " requires " & $mskillbarcacheenergyreq[$i] & " energy.", "Skills")
		EndIf
		$mskillpriorityrating[$i][1] = 0
		$skilldamageamount[$i] = skilldamageamount($mskillbarcacheptr[$i])
		$mskillpriorityrating[$i][0] = $i
		If iseliteskill($mskillbarcacheptr[$i]) Then $mskillpriorityrating[$i][1] = 30
		If $mskillbarcache[$i] = 2358 Then
			$isymlad[$i] = True
			$isymlad[0] = True
			$ymladslot = $i
			$mskillpriorityrating[$i][1] = 120 - $i
			$mskillpriorityrating[$i][2] = 1
			update("Skill " & $i & " is YMLAD! Priority: " & $mskillpriorityrating[$i][1] & ".", "Skills")
			ContinueLoop
		EndIf
		If isinterruptskill($mskillbarcacheptr[$i]) Then
			$mskillpriorityrating[$i][1] += 110 - $i
			$mskillpriorityrating[$i][2] = 2
			$isinterrupt[$i] = True
			$isinterrupt[0] = True
			update("Skill " & $i & " is an Interrupt Skill, Priority: " & $mskillpriorityrating[$i][1] & ".", "Skills")
			ContinueLoop
		EndIf
		If ishexremovalskill($mskillbarcacheptr[$i]) Then
			$mskillpriorityrating[$i][1] = 55 - $i
			$mskillpriorityrating[$i][2] = 8
			update("Skill " & $i & " is a Hex Remover, Priority: " & $mskillpriorityrating[$i][1] & ".", "Skills")
			ContinueLoop
		EndIf
		If isconditionremovalskill($mskillbarcacheptr[$i]) Then
			$mskillpriorityrating[$i][1] = 50 - $i
			$mskillpriorityrating[$i][2] = 9
			update("Skill " & $i & " is a Condition Remover, Priority: " & $mskillpriorityrating[$i][1] & ".", "Skills")
			ContinueLoop
		EndIf
		If isresskill($mskillbarcacheptr[$i]) Then
			$mskillpriorityrating[$i][1] = 20 - $i
			$mskillpriorityrating[$i][2] = 13
			update("Skill " & $i & " is a Rez, Priority: " & $mskillpriorityrating[$i][1] & ".", "Skills")
			ContinueLoop
		EndIf
		If ishealskill($mskillbarcacheptr[$i]) Then
			If targetotherallyskill($mskillbarcacheptr[$i]) Then
				$mskillpriorityrating[$i][1] += 75 - $i
				$mskillpriorityrating[$i][2] = 4
				update("Skill " & $i & " heals other ally for " & $skilldamageamount[$i] & ", Priority: " & $mskillpriorityrating[$i][1] & ".", "Skills")
				ContinueLoop
			EndIf
			$ishealingspell[$i] = True
			$ishealingspell[0] = True
			$mskillpriorityrating[$i][1] += 80 - $i + $skilldamageamount[$i]
			$mskillpriorityrating[$i][2] = 3
			update("Skill " & $i & " heals ally for " & $skilldamageamount[$i] & ", Priority: " & $mskillpriorityrating[$i][1] & ".", "Skills")
			ContinueLoop
		EndIf
		If skillaoerange($mskillbarcacheptr[$i]) > 0 Then
			If targetenemyskill($mskillbarcacheptr[$i]) OR targetgroundskill($mskillbarcacheptr[$i]) Then
				$mskillpriorityrating[$i][1] += 70 - $i
				$mskillpriorityrating[$i][2] = 5
				update("Skill " & $i & " does AOE damage of " & $skilldamageamount[$i] & ", Priority: " & $mskillpriorityrating[$i][1] & ".", "Skills")
				ContinueLoop
			EndIf
		EndIf
		If $mskillbarcache[$i] = 1240 Then
			$issoultwistingspell[$i] = True
			$issoultwistingspell[0] = True
			$mskillpriorityrating[$i][1] = 65 - $i
			$mskillpriorityrating[$i][2] = 6
			update("Skill " & $i & " is Soul Twisting, Priority: " & $mskillpriorityrating[$i][1] & ".", "Skills")
			ContinueLoop
		EndIf
		If isspiritskill($mskillbarcacheptr[$i]) Then
			$mskillpriorityrating[$i][1] += 60 - $i
			$mskillpriorityrating[$i][2] = 7
			update("Skill " & $i & " is a Spirit Skill, Priority: " & $mskillpriorityrating[$i][1] & ".", "Skills")
			ContinueLoop
		EndIf
		If isweaponspell($mskillbarcacheptr[$i]) Then
			$isweaponspell[$i] = True
			$isweaponspell[0] = True
			$mskillpriorityrating[$i][1] += 40 - $i
			$mskillpriorityrating[$i][2] = 10
			update("Skill " & $i & " is a Weapon Skill, Priority: " & $mskillpriorityrating[$i][1] & ".", "Skills")
			ContinueLoop
		EndIf
		If isenchantmentstrip($mskillbarcacheptr[$i]) Then
			$mskillpriorityrating[$i][1] += 35 - $i
			$mskillpriorityrating[$i][2] = 11
			update("Skill " & $i & " is a Enchantment Strip, Priority: " & $mskillpriorityrating[$i][1] & ".", "Skills")
			ContinueLoop
		EndIf
		If targetenemyskill($mskillbarcacheptr[$i]) Then
			$mskillpriorityrating[$i][1] += 30 - $i
			If ispveskill($mskillbarcachestruct[$i]) Then $mskillpriorityrating[$i][1] += 100
			$mskillpriorityrating[$i][2] = 12
			update("Skill " & $i & " Vs. enemies for " & $skilldamageamount[$i] & " damage, Priority: " & $mskillpriorityrating[$i][1] & ".", "Skills")
			ContinueLoop
		EndIf
		If issummonskill($mskillbarcache[$i]) Then
			$issummonspell[$i] = True
			$issummonspell[0] = True
			$mskillpriorityrating[$i][1] = 0 - $i
			$mskillpriorityrating[$i][2] = 15
			update("Skill " & $i & " is a Summon, Priority: " & $mskillpriorityrating[$i][1] & ".", "Skills")
			ContinueLoop
		EndIf
		If targetselfskill($mskillbarcacheptr[$i]) Then
			$isselfcastingspell[$i] = True
			$isselfcastingspell[0] = True
			$mskillpriorityrating[$i][1] += 10 - $i
			$mskillpriorityrating[$i][2] = 14
			update("Skill " & $i & " is a Self Targeting Skill, Priority: " & $mskillpriorityrating[$i][1] & ".", "Skills")
			ContinueLoop
		EndIf
	Next
	$lmyprofession = getheroprofession(0)
	$lattrprimary = getprofprimaryattribute($lmyprofession)
	_arraysort($mskillpriorityrating, 0, 0, 0, 1)
	$mskillbarcache[0] = True
	$mskillbarcacheptr[0] = True
EndFunc

Func smartcast($ame = getagentptr(-2))
	#Region Variables
		If getisdead($ame) Then Return False
		If getmaploading() <> 1 Then Return True
		If NOT $mskillbarcache[0] Then
			cacheskillbar()
		EndIf
	#EndRegion Variables
	#Region Specific Skills
		If $ishealingspell[0] Then
			If haseffect(1219) Then
				If $maverageteamhp < 0.8 OR $mlowestallyhp < 0.3 Then
					dropbundle()
					Return
				EndIf
			EndIf
		EndIf
	#EndRegion Specific Skills
	For $r = 8 To 1 Step -1
		$i = $mskillpriorityrating[$r][0]
		If $skilladrenalinereq[$i] = 0 Then
			If getskillbarskillrecharge($i) OR NOT canuseskill($i, $mskillbarptr, $mskillbarcacheenergyreq[$i]) Then ContinueLoop
		ElseIf $skilladrenalinereq[$i] > getskillbarskilladrenaline($i) Then
			ContinueLoop
		EndIf
		Switch $mskillpriorityrating[$r][2]
			Case 1
				Switch $numberoffoesinattackrange
					Case 0
						ContinueLoop
					Case 1, 2
						If getdistance($mlowestenemy) < 1200 Then
							useskillex($i, $mlowestenemy)
							Return
						EndIf
					Case Else
						If getdistance($enemynonconditioned) < 1200 Then
							useskillex($i, $enemynonconditioned)
							Return
						EndIf
				EndSwitch
			Case 3
				If $mskillbarcache[$i] = 1219 Then
					If NOT haseffect(1219) Then
						useskillex($i, $ame)
						Return
					EndIf
				EndIf
				If $mlowestallyhp < 0.75 Then
					If $isweaponspell[$i] Then
						If $numberoffoesinattackrange AND NOT gethasweaponspell($mlowestally) Then
							useskillex($i, $mlowestally)
							Return
						EndIf
					Else
						useskillex($i, $mlowestally)
						Return
					EndIf
				EndIf
			Case 4
				If $mlowestotherallyhp < 0.75 Then
					If $isweaponspell[$i] Then
						If $numberoffoesinattackrange AND NOT gethasweaponspell($mlowestotherally) Then
							useskillex($i, $mlowestotherally)
							Return
						EndIf
					Else
						useskillex($i, $mlowestotherally)
						Return
					EndIf
				EndIf
			Case 5
				If NOT $numberoffoesinattackrange Then ContinueLoop
				If $mskillbarcache[$i] = 1657 Then
					If $enemyattacker <> 0 Then
						useskillex($i, $enemyattacker)
						Return
					EndIf
				Else
					If $bestaoetarget <> 0 Then
						useskillex($i, $bestaoetarget)
						Return
					EndIf
					If $enemyhealer <> 0 Then
						useskillex($i, $enemyhealer)
						Return
					EndIf
					If $mlowestenemy <> 0 Then
						useskillex($i, $mlowestenemy)
						Return
					EndIf
				EndIf
			Case 6
				If NOT haseffect(1240) Then
					useskillex($i, $ame)
					Return
				EndIf
			Case 7
				If NOT $numberoffoesinattackrange Then ContinueLoop
				If $issoultwistingspell[0] Then
					If haseffect(1240) AND NOT haseffect($mskillbarcache[$i]) Then
						useskillex($i, $ame)
						Return
					EndIf
				Else
					useskillex($i, $ame)
					Return
				EndIf
			Case 8
				If $hexedally <> 0 Then
					useskillex($i, $hexedally)
					Return
				EndIf
			Case 9
				If $conditionedally <> 0 Then
					useskillex($i, $conditionedally)
					Return
				EndIf
			Case 10
				If NOT $numberoffoesinattackrange Then ContinueLoop
			Case 11
				If $enemyenchanted <> 0 Then
					useskillex($i, $enemyenchanted)
					Return
				EndIf
			Case 12
				If NOT $numberoffoesinattackrange Then ContinueLoop
				If $enemyhealer <> 0 Then
					useskillex($i, $enemyhealer)
					Return
				EndIf
				$isantimeleeskill = isantimeleeskill($mskillbarcache[$i])
				$ishexingspell = ishexspell($mskillbarcacheptr[$i])
				$isconditioningspell = isconditionspell($mskillbarcacheptr[$i])
				$isbelow50 = isbelow50percentenemyskill($mskillbarcacheptr[$i])
				If $isantimeleeskill AND $enemyattacker <> 0 Then
					useskillex($i, $enemyattacker)
					Return
				EndIf
				If $isbelow50 AND $lowhpenemy <> 0 Then
					useskillex($i, $lowhpenemy)
					Return
				EndIf
				If $ishexingspell AND NOT $isconditioningspell AND NOT $isantimeleeskill AND $enemynonhexed <> 0 Then
					useskillex($i, $enemynonhexed)
					Return
				EndIf
				If $isconditioningspell AND NOT $ishexingspell AND NOT $isantimeleeskill AND $enemyconditioned <> 0 Then
					useskillex($i, $enemyconditioned)
					Return
				EndIf
				If $isconditioningspell AND $enemynonconditioned <> 0 Then
					useskillex($i, $enemynonconditioned)
					Return
				EndIf
				If $ishexingspell AND $enemynonhexed <> 0 Then
					useskillex($i, $enemynonhexed)
					Return
				EndIf
				If $mlowestenemy <> 0 AND NOT $isbelow50 Then
					useskillex($i, $mlowestenemy)
					Return
				EndIf
			Case 13
				If $mteamdead[0] > 0 Then
					rezparty($i, $ame)
					Return
				EndIf
			Case 14
				If NOT $numberoffoesinattackrange Then ContinueLoop
				If UBound($mspirits) < 3 AND $mskillbarcache[$i] = 2051 Then ContinueLoop
				If NOT haseffect($mskillbarcache[$i]) Then
					useskillex($i, $ame)
					Return
				EndIf
			Case 15
				If $numberoffoesinattackrange < 2 Then
					useskillex($i, $ame)
					Return
				EndIf
			Case Else
				ContinueLoop
		EndSwitch
	Next
EndFunc

Func updateworld(ByRef $aagentarray, $arange = 1350, $amyid = getmyid(), $ame = getagentptr($amyid))
	Local $lx, $ly, $lhp, $ldistance, $lcountaoe = 1, $teamcount = 1
	$arange = $arange ^ 2
	$mselfid = $amyid
	$mself = $ame
	If getisdead($mself) Then Return False
	If getmaploading() <> 1 Then Return True
	Local $lenergystruct = memoryreadstruct($mself + 284, "float EnergyPercent;long MaxEnergy")
	$menergy = DllStructGetData($lenergystruct, "EnergyPercent") * DllStructGetData($lenergystruct, "MaxEnergy")
	$meffects = geteffectsptr()
	$mdazed = False
	$mblind = False
	$mskillhardcounter = False
	$mskillsoftcounter = 0
	$mattackhardcounter = False
	$mattacksoftcounter = 0
	$mallyspellhardcounter = False
	$menemyspellhardcounter = False
	$mspellsoftcounter = 0
	$mblocking = False
	If IsArray($meffects) <> 0 Then
		For $i = 1 To $meffects[0]
			Switch memoryread($meffects[$i], "long")
				Case 485
					$mdazed = True
				Case 479
					$mblind = True
				Case 30, 764
					$mskillhardcounter = True
				Case 51, 127
					$mallyspellhardcounter = True
				Case 46, 979, 3191
					$menemyspellhardcounter = True
				Case 878, 3234
					$mskillsoftcounter += 1
					$mspellsoftcounter += 1
					$mattacksoftcounter += 1
				Case 28, 128
					$mspellsoftcounter += 1
				Case 47, 43, 1004, 2056, 3195
					$mattackhardcounter = True
				Case 123, 26, 3151, 121, 103, 66
					$mattacksoftcounter += 1
				Case 905, 380, 388, 345, 373, 376, 1700, 372, 387, 363, 378, 1698, 377, 425, 452, 448, 453
					$mblocking = True
				Case 1027, 1042, 793, 2208, 1764, 2201, 2417, 810, 176, 1500, 1727, 450, 1196, 11, 168, 1084, 233
					$mblocking = True
			EndSwitch
		Next
	EndIf
	$lteamsize = getpartysize()
	If $mteam[0] <> $lteamsize Then
		$mteam[0] = $lteamsize
		ReDim $mteam[$lteamsize + 1]
	EndIf
	Dim $mteamothers[1] = [0]
	Dim $mteamdead[1] = [0]
	Dim $mspirits[1] = [0]
	Dim $mminions[1] = [0]
	$mhighestally = $mself
	$mhighestallyhp = 2
	$mlowestally = $mself
	$mlowestallyhp = 2
	$mlowestotherally = 0
	$mlowestotherallyhp = 2
	$mlowestenemy = 0
	$mlowestenemyhp = 2
	$mclosestenemydist = $arange
	$maverageteamhp = 0
	$bestaoetarget = 0
	$hexedally = 0
	$conditionedally = 0
	$enemyhexed = 0
	$enemynonhexed = 0
	$enemyconditioned = 0
	$enemynonconditioned = 0
	$enemynonenchanted = 0
	$enemyenchanted = 0
	$enemyhealer = 0
	$lowhpenemy = 0
	$numberoffoesinattackrange = 0
	$numberoffoesinspellrange = 0
	updateagentposbyptr($mself, $lx, $ly)
	For $i = 1 To $aagentarray[0]
		Local $lagentx, $lagenty
		updateagentposbyptr($aagentarray[$i], $lagentx, $lagenty)
		$lhp = memoryread($aagentarray[$i] + 304, "float")
		$lagenteffects = memoryread($aagentarray[$i] + 312, "long")
		$ldistance = ($lx - $lagentx) ^ 2 + ($ly - $lagenty) ^ 2
		$lallegiance = memoryread($aagentarray[$i] + 433, "byte")
		Switch $lallegiance
			Case 1, 6
				If $lallegiance = 1 Then
					$mteam[$teamcount] = $aagentarray[$i]
					$teamcount += 1
				EndIf
				If issummonedcreature($aagentarray[$i]) Then ContinueLoop
				If NOT BitAND($lagenteffects, 16) Then
					$maverageteamhp += $lhp
					If $lhp < $mlowestallyhp Then
						$mlowestally = $aagentarray[$i]
						$mlowestallyhp = $lhp
					ElseIf $lhp = $mlowestallyhp Then
						If $ldistance < ($lx - memoryread($mlowestally + 116, "float")) ^ 2 + ($ly - memoryread($mlowestally + 120, "float")) ^ 2 Then
							$mlowestally = $aagentarray[$i]
							$mlowestallyhp = $lhp
						EndIf
					ElseIf $lhp > $mhighestallyhp Then
						$mhighestally = $aagentarray[$i]
						$mhighestallyhp = $lhp
					EndIf
					If gethashex($aagentarray[$i]) Then $hexedally = $aagentarray[$i]
					If gethascondition($aagentarray[$i]) Then $conditionedally = $aagentarray[$i]
					If $aagentarray[$i] <> $mself Then
						$mteamothers[0] += 1
						ReDim $mteamothers[$mteamothers[0] + 1]
						$mteamothers[$mteamothers[0]] = $aagentarray[$i]
						If $lhp < $mlowestotherallyhp Then
							$mlowestotherally = $aagentarray[$i]
							$mlowestotherallyhp = $lhp
						ElseIf $lhp = $mlowestotherallyhp Then
							If $ldistance < ($lx - memoryread($mlowestotherally + 116, "float")) ^ 2 + ($ly - memoryread($mlowestotherally + 120, "float")) ^ 2 Then
								$mlowestotherally = $aagentarray[$i]
								$mlowestotherallyhp = $lhp
							EndIf
						EndIf
					EndIf
				Else
					$mteamdead[0] += 1
					ReDim $mteamdead[$mteamdead[0] + 1]
					$mteamdead[$mteamdead[0]] = $aagentarray[$i]
				EndIf
			Case 3
				If BitAND($lagenteffects, 16) Then ContinueLoop
				If blacklisted(memoryread($aagentarray[$i] + 244, "word")) Then ContinueLoop
				If $ldistance <= $arange Then
					$numberoffoesinattackrange += 1
					If $lhp < $mlowestenemyhp Then
						$mlowestenemy = $aagentarray[$i]
						$mlowestenemyhp = $lhp
					ElseIf $lhp = $mlowestenemyhp Then
						If $ldistance < ($lx - memoryread($mlowestenemy + 116, "float")) ^ 2 + ($ly - memoryread($mlowestenemy + 120, "float")) ^ 2 Then
							$mlowestenemy = $aagentarray[$i]
							$mlowestenemyhp = $lhp
						EndIf
					EndIf
					If getnumberoffoesinrangeofagent_($aagentarray, $aagentarray[$i], 256) > $lcountaoe Then
						$bestaoetarget = $aagentarray[$i]
						$lcountaoe += 1
					EndIf
					If getisboss($aagentarray[$i]) Then
						$bestaoetarget = $aagentarray[$i]
						$lcountaoe += 5
					EndIf
					If gethashex($aagentarray[$i]) Then
						$enemyhexed = $aagentarray[$i]
					Else
						$enemynonhexed = $aagentarray[$i]
					EndIf
					If gethascondition($aagentarray[$i]) Then
						$enemyconditioned = $aagentarray[$i]
					Else
						$enemynonconditioned = $aagentarray[$i]
					EndIf
					If getishealer($aagentarray[$i]) Then $enemyhealer = $aagentarray[$i]
					If getisenchanted($aagentarray[$i]) Then
						$enemynonenchanted = $aagentarray[$i]
					Else
						$enemyenchanted = $aagentarray[$i]
					EndIf
				EndIf
				If $ldistance <= 1440000 Then
					$numberoffoesinspellrange += 1
					If memoryread($aagentarray[$i] + 304, "float") * memoryread($aagentarray[$i] + 308, "long") < 0.5 Then
						$lowhpenemy = $aagentarray[$i]
					EndIf
				EndIf
				If $ldistance < $mclosestenemydist Then
					$mclosestenemydist = $ldistance
					$mclosestenemy = $aagentarray[$i]
				EndIf
			Case 4
				If BitAND($lagenteffects, 16) Then ContinueLoop
				$mspirits[0] += 1
				ReDim $mspirits[$mspirits[0] + 1]
				$mspirits[$mspirits[0]] = $aagentarray[$i]
			Case 5
				If BitAND($lagenteffects, 16) Then ContinueLoop
				$mminions[0] += 1
				ReDim $mminions[$mminions[0] + 1]
				$mminions[$mminions[0]] = $aagentarray[$i]
		EndSwitch
	Next
	$mclosestenemydist = Sqrt($mclosestenemydist)
	$maverageteamhp /= $mteamothers[0] + 1
	If $numberoffoesinspellrange <= 0 Then
		$enemyattacker = 0
	Else
		$enemyattacker = $numberoffoesinspellrange
	EndIf
EndFunc

Func blacklisted($aplayernumber)
	Switch $aplayernumber
		Case 4110
			Return True
		Case 1377
			Return True
		Case 2220 To 2222
			Return True
		Case 2864 To 2872
			Return True
		Case 2875 To 2878
			Return True
		Case 3956, 3957, 4199, 4200
			Return True
		Case 4203 To 4222
			Return True
		Case 4224 To 4229
			Return True
		Case 5703, 5704
			Return True
		Case 5705 To 5713
			Return True
		Case 5842 To 5844
			Return True
		Case Else
			Return False
	EndSwitch
EndFunc

Func getnumberoffoesinrangeofagent_(ByRef $aagentarray, $aagent = getagentptr(-2), $amaxdistance = 4000, $modelid = 0)
	If IsPtr($aagent) <> 0 Then
		Local $lagentptr = $aagent
	ElseIf IsDllStruct($aagent) <> 0 Then
		Local $lagentid = DllStructGetData($aagent, "ID")
		Local $lagentptr = getagentptr($lagentid)
	Else
		Local $lagentid = $aagent
		Local $lagentptr = getagentptr($lagentid)
	EndIf
	Local $ldistance, $lcount = 0
	For $i = 1 To $aagentarray[0]
		If $modelid <> 0 AND memoryread($aagentarray[$i] + 244, "word") <> $modelid Then ContinueLoop
		$ldistance = getdistance($aagentarray[$i], $lagentptr)
		If $ldistance < $amaxdistance Then
			$lcount += 1
		EndIf
	Next
	Return $lcount
EndFunc

#Region PartyCommands

	Func addhero($aheroid)
		Return sendpacket(8, 23, $aheroid)
	EndFunc

	Func kickhero($aheroid)
		Return sendpacket(8, 24, $aheroid)
	EndFunc

	Func kickallheroes()
		Return sendpacket(8, 24, 38)
	EndFunc

	Func addnpc($anpcid)
		Return sendpacket(8, 153, $anpcid)
	EndFunc

	Func kicknpc($anpcid)
		Return sendpacket(8, 162, $anpcid)
	EndFunc

	Func cancelhero($aheronumber, $aagentid = getheroid($aheronumber))
		Return sendpacket(20, 19, $aagentid, 2139095040, 2139095040, 0)
	EndFunc

	Func cancelall()
		Return sendpacket(16, 20, 2139095040, 2139095040, 0)
	EndFunc

	Func commandhero($aheronumber, $ax, $ay, $aheroid = getheroid($aheronumber))
		Return sendpacket(20, 19, $aheroid, floattoint($ax), floattoint($ay), 0)
	EndFunc

	Func commandall($ax, $ay)
		Return sendpacket(16, 20, floattoint($ax), floattoint($ay), 0)
	EndFunc

	Func lockherotarget($aheronumber, $aagentid = 0, $aheroid = getheroid($aheronumber))
		Return sendpacket(12, 15, $aheroid, $aagentid)
	EndFunc

	Func setheroaggression($aheronumber, $aaggression, $aheroid = getheroid($aheronumber))
		Return sendpacket(12, 14, $aheroid, $aaggression)
	EndFunc

	Func clearpartycommands()
		Return performaction(219, 24)
	EndFunc

#EndRegion
#Region Hero Skillbar Interaction

	Func disableheroskillslot($aheronumber, $askillslot, $aptr = getskillbarptr($aheronumber), $aheroid = getheroid($aheronumber))
		If NOT getisheroskillslotdisabled($aheronumber, $askillslot, $aptr) Then changeheroskillslotstate($aheronumber, $askillslot, $aheroid)
		Return True
	EndFunc

	Func enableheroskillslot($aheronumber, $askillslot, $aptr = getskillbarptr($aheronumber), $aheroid = getheroid($aheronumber))
		If getisheroskillslotdisabled($aheronumber, $askillslot, $aptr) Then changeheroskillslotstate($aheronumber, $askillslot, $aheroid)
	EndFunc

	Func changeheroskillslotstate($aheronumber, $askillslot, $aheroid = getheroid($aheronumber))
		Return sendpacket(12, 18, $aheroid, $askillslot - 1)
	EndFunc

	Func getisheroskillslotdisabled($aheronumber, $askillslot, $aptr = getskillbarptr($aheronumber))
		Local $ldisabled = memoryread($aptr + 164, "dword")
		If $askillslot > 1 Then
			$lbitmask = 2 ^ ($askillslot - 1)
		Else
			$lbitmask = 1
		EndIf
		Return BitAND($lbitmask, $ldisabled) > 0
	EndFunc

	Func useheroskill($ahero, $askillslot, $atarget = -2)
		If IsPtr($atarget) <> 0 Then
			Local $ltargetid = memoryread($atarget + 44, "long")
		ElseIf IsDllStruct($atarget) <> 0 Then
			Local $ltargetid = DllStructGetData($atarget, "ID")
		Else
			Local $ltargetid = convertid($atarget)
		EndIf
		DllStructSetData($museheroskill, 2, getheroid($ahero))
		DllStructSetData($museheroskill, 3, $ltargetid)
		DllStructSetData($museheroskill, 4, $askillslot - 1)
		enqueue($museheroskillptr, 16)
	EndFunc

#EndRegion
#Region Information

	Func getherocount()
		Local $loffset[5] = [0, 24, 76, 84, 44]
		Local $lherocount = memoryreadptr($mbasepointer, $loffset)
		Return $lherocount[1]
	EndFunc

	Func getheroid($aheronumber)
		If $aheronumber = 0 Then Return getmyid()
		Local $loffset[6] = [0, 24, 76, 84, 36, 24 * ($aheronumber - 1)]
		Local $lagentid = memoryreadptr($mbasepointer, $loffset)
		Return $lagentid[1]
	EndFunc

	Func getheronumberbyagentid($aagentid)
		Local $lagentid
		Local $loffset[6] = [0, 24, 76, 84, 36, 0]
		For $i = 1 To getherocount()
			$loffset[5] = 24 * ($i - 1)
			$lagentid = memoryreadptr($mbasepointer, $loffset)
			If $lagentid[1] = convertid($aagentid) Then Return $i
		Next
	EndFunc

	Func getheronumberbyheroid($aheroid)
		Local $lagentid
		Local $loffset[6] = [0, 24, 76, 84, 36, 0]
		For $i = 1 To getherocount()
			$loffset[5] = 8 + 24 * ($i - 1)
			$lagentid = memoryreadptr($mbasepointer, $loffset)
			If $lagentid[1] = convertid($aheroid) Then Return $i
		Next
	EndFunc

	Func getheroprofession($aheronumber, $asecondary = False)
		Local $loffset[5] = [0, 24, 44, 1624, 0]
		Local $lbuffer
		$aheronumber = getheroid($aheronumber)
		For $i = 0 To getherocount()
			$lbuffer = memoryreadptr($mbasepointer, $loffset)
			If $lbuffer[1] = $aheronumber Then
				$loffset[4] += 4
				If $asecondary Then $loffset[4] += 4
				$lbuffer = memoryreadptr($mbasepointer, $loffset)
				Return $lbuffer[1]
			EndIf
			$loffset[4] += 20
		Next
	EndFunc

#EndRegion
#Region All

	Func donatefaction($afaction)
		If StringLeft($afaction, 1) = "k" Then
			Return sendpacket(16, 47, 0, 0, 5000)
		Else
			Return sendpacket(16, 47, 0, 1, 5000)
		EndIf
	EndFunc

#EndRegion
#Region Kurzick

	Func getkurzickfaction()
		Local $loffset[4] = [0, 24, 44, 1864]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func getmaxkurzickfaction()
		Local $loffset[4] = [0, 24, 44, 1976]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

#EndRegion
#Region Luxon

	Func getluxonfaction()
		Local $loffset[4] = [0, 24, 44, 1880]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func getmaxluxonfaction()
		Local $loffset[4] = [0, 24, 44, 1980]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

#EndRegion
#Region Imperial

	Func getimperialfaction()
		Local $loffset[4] = [0, 24, 44, 1800]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func getmaximperialfaction()
		Local $loffset[4] = [0, 24, 44, 1888]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

#EndRegion
#Region Balth

	Func getbalthazarfaction()
		Local $loffset[4] = [0, 24, 44, 1844]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func getmaxbalthazarfaction()
		Local $loffset[4] = [0, 24, 44, 1884]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

#EndRegion
#Region ChatControl

	Func writechat($amessage, $asender = "GWA²")
		Local $lmessage, $lsender
		Local $laddress = 256 * $mqueuecounter + $mqueuebase
		If $mqueuecounter = $mqueuesize Then
			$mqueuecounter = 0
		Else
			$mqueuecounter = $mqueuecounter + 1
		EndIf
		If StringLen($asender) > 19 Then
			$lsender = StringLeft($asender, 19)
		Else
			$lsender = $asender
		EndIf
		memorywrite($laddress + 4, $lsender, "wchar[20]")
		If StringLen($amessage) > 100 Then
			$lmessage = StringLeft($amessage, 100)
		Else
			$lmessage = $amessage
		EndIf
		memorywrite($laddress + 44, $lmessage, "wchar[101]")
		DllCall($mkernelhandle, "int", "WriteProcessMemory", "int", $mgwprochandle, "int", $laddress, "ptr", $mwritechatptr, "int", 4, "int", "")
		If StringLen($amessage) > 100 Then writechat(StringTrimLeft($amessage, 100), $asender)
	EndFunc

	Func sendwhisper($areceiver, $amessage)
		Local $ltotal = "whisper " & $areceiver & "," & $amessage
		Local $lmessage
		If StringLen($ltotal) > 120 Then
			$lmessage = StringLeft($ltotal, 120)
		Else
			$lmessage = $ltotal
		EndIf
		sendchat($lmessage, "/")
		If StringLen($ltotal) > 120 Then sendwhisper($areceiver, StringTrimLeft($ltotal, 120))
	EndFunc

	Func sendchat($amessage, $achannel = "!")
		Local $lmessage
		Local $laddress = 256 * $mqueuecounter + $mqueuebase
		If $mqueuecounter = $mqueuesize Then
			$mqueuecounter = 0
		Else
			$mqueuecounter = $mqueuecounter + 1
		EndIf
		If StringLen($amessage) > 120 Then
			$lmessage = StringLeft($amessage, 120)
		Else
			$lmessage = $amessage
		EndIf
		memorywrite($laddress + 8, $achannel & $lmessage, "wchar[122]")
		DllCall($mkernelhandle, "int", "WriteProcessMemory", "int", $mgwprochandle, "int", $laddress, "ptr", $msendchatptr, "int", 8, "int", "")
		If StringLen($amessage) > 120 Then sendchat(StringTrimLeft($amessage, 120), $achannel)
	EndFunc

	Func update($text, $flag = 0)
		$oldguitext = $text
		ConsoleWrite($text & @CRLF)
		$resttimer = TimerInit()
	EndFunc

#EndRegion Chat
#Region ChatSends

	Func resign()
		sendchat("resign", "/")
	EndFunc

	Func resignandreturn()
		Sleep(3000)
		update("Resigning")
		resign()
		Sleep(4000)
		returntooutpost()
		update("Returning To Outpost")
		waitmaploading()
		rndsleep(2000)
		main()
	EndFunc

	Func kneel()
		update("Kneel")
		sendchat("kneel", "/")
	EndFunc

	Func stuck()
		sendchat("stuck", "/")
	EndFunc

#EndRegion
#Region Titles

	Func getherotitle()
		Local $loffset[5] = [0, 24, 44, 2076, 4]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func getgladiatortitle()
		Local $loffset[5] = [0, 24, 44, 2076, 124]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func getkurzicktitle()
		Local $loffset[5] = [0, 24, 44, 2076, 204]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func getluxontitle()
		Local $loffset[5] = [0, 24, 44, 2076, 244]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func getdrunkardtitle()
		Local $loffset[5] = [0, 24, 44, 2076, 284]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func getsurvivortitle()
		Local $loffset[5] = [0, 24, 44, 2076, 364]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func getmaxtitles()
		Local $loffset[5] = [0, 24, 44, 2076, 404]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func getluckytitle()
		Local $loffset[5] = [0, 24, 44, 2076, 604]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func getunluckytitle()
		Local $loffset[5] = [0, 24, 44, 2076, 644]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func getsunspeartitle()
		Local $loffset[5] = [0, 24, 44, 2076, 684]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func getlightbringertitle()
		Local $loffset[5] = [0, 24, 44, 2076, 804]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func getcommandertitle()
		Local $loffset[5] = [0, 24, 44, 2076, 884]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func getgamertitle()
		Local $loffset[5] = [0, 24, 44, 2076, 924]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func getlegendaryguardiantitle()
		Local $loffset[5] = [0, 24, 44, 2076, 1244]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func getsweettitle()
		Local $loffset[5] = [0, 24, 44, 2076, 1364]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func getasuratitle()
		Local $loffset[5] = [0, 24, 44, 2076, 1524]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func getdeldrimortitle()
		Local $loffset[5] = [0, 24, 44, 2076, 1564]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func getvanguardtitle()
		Local $loffset[5] = [0, 24, 44, 2076, 1604]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func getnorntitle()
		Local $loffset[5] = [0, 24, 44, 2076, 1644]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func getnorthmasterytitle()
		Local $loffset[5] = [0, 24, 44, 2076, 1684]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func getpartytitle()
		Local $loffset[5] = [0, 24, 44, 2076, 1724]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func getzaishentitle()
		Local $loffset[5] = [0, 24, 44, 2076, 1764]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func gettreasuretitle()
		Local $loffset[5] = [0, 24, 44, 2076, 1804]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func getwisdomtitle()
		Local $loffset[5] = [0, 24, 44, 2076, 1844]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	#Region SetTitle

		Func setdisplayedtitle($atitle = 0)
			If $atitle Then
				Return sendpacket(8, 81, $atitle)
			Else
				Return sendpacket(4, 82)
			EndIf
		EndFunc

	#EndRegion
#EndRegion Titles
#Region Misc

	Func getskillpoints()
		Local $loffset[4] = [0, 24, 44, 1960]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

	Func getexperience()
		Local $loffset[4] = [0, 24, 44, 1856]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1]
	EndFunc

#EndRegion
#Region Windows

	Func closeallpanels()
		Return performaction(133, 24)
	EndFunc

	Func toggleherowindow()
		Return performaction(138, 24)
	EndFunc

	Func toggleinventory()
		Return performaction(139, 24)
	EndFunc

	Func toggleallbags()
		Return performaction(184, 24)
	EndFunc

	Func toggleworldmap()
		Return performaction(140, 24)
	EndFunc

	Func toggleoptions()
		Return performaction(141, 24)
	EndFunc

	Func togglequestwindow()
		Return performaction(142, 24)
	EndFunc

	Func toggleskillwindow()
		Return performaction(143, 24)
	EndFunc

	Func togglemissionmap()
		Return performaction(182, 24)
	EndFunc

	Func togglefriendlist()
		Return performaction(185, 24)
	EndFunc

	Func toggleguildwindow()
		Return performaction(186, 24)
	EndFunc

	Func togglepartywindow()
		Return performaction(191, 24)
	EndFunc

	Func togglescorechart()
		Return performaction(189, 24)
	EndFunc

	Func togglelayoutwindow()
		Return performaction(193, 24)
	EndFunc

	Func toggleminionlist()
		Return performaction(194, 24)
	EndFunc

	Func toggleheropanel($aheronumber)
		If $aheronumber < 4 Then
			Return performaction(219 + $aheronumber, 24)
		ElseIf $aheronumber < 8 Then
			Return performaction(254 + $aheronumber, 24)
		EndIf
	EndFunc

	Func toggleheropetpanel($aheronumber)
		If $aheronumber < 4 Then
			Return performaction(223 + $aheronumber, 24)
		ElseIf $aheronumber < 8 Then
			Return performaction(250 + $aheronumber, 24)
		EndIf
	EndFunc

	Func togglepetpanel()
		Return performaction(223, 24)
	EndFunc

	Func togglehelpwindow()
		Return performaction(228, 24)
	EndFunc

#EndRegion Windows
#Region Display

	Func enablerendering($asetstate = True)
		If $asetstate Then WinSetState($mgwhwnd, "", @SW_SHOW)
		$mrendering = True
		writebinary("8B15ECF9A300", getvalue("RenderHook"))
	EndFunc

	Func disablerendering($asetstate = True)
		If $asetstate Then WinSetState($mgwhwnd, "", @SW_HIDE)
		$mrendering = False
		writedetour("RenderHook", "NewDisableRenderingProc")
	EndFunc

	Func clearmemory()
		DllCall($mkernelhandle, "int", "SetProcessWorkingSetSize", "int", $mgwprochandle, "int", -1, "int", -1)
	EndFunc

	Func _reducememory($gwpid = WinGetProcess($mgwhwnd))
		If $gwpid <> -1 Then
			Local $ai_handle = DllCall("kernel32.dll", "int", "OpenProcess", "int", 2035711, "int", False, "int", $gwpid)
			Local $ai_return = DllCall("psapi.dll", "int", "EmptyWorkingSet", "long", $ai_handle[0])
			DllCall("kernel32.dll", "int", "CloseHandle", "int", $ai_handle[0])
		Else
			Local $ai_return = DllCall("psapi.dll", "int", "EmptyWorkingSet", "long", -1)
		EndIf
		Return $ai_return[0]
	EndFunc

	Func _purgehook()
		update("Purging engine hook")
		togglerendering()
		Sleep(Random(4000, 5000))
		togglerendering()
	EndFunc

	Func togglerendering()
		If $mrendering Then
			disablerendering()
			$mrendering = False
		Else
			enablerendering()
			$mrendering = True
		EndIf
	EndFunc

	Func closehandler()
		If NOT $mrendering Then
			AdlibUnRegister("_ReduceMemory")
		EndIf
		Exit
	EndFunc

	Func displayall($adisplay)
		displayallies($adisplay)
		displayenemies($adisplay)
	EndFunc

	Func displayallies($adisplay)
		If $adisplay Then
			Return performaction(137, 24)
		Else
			Return performaction(137, 26)
		EndIf
	EndFunc

	Func displayenemies($adisplay)
		If $adisplay Then
			Return performaction(148, 24)
		Else
			Return performaction(148, 26)
		EndIf
	EndFunc

#EndRegion Display
#Region Misc

	Func makescreenshot()
		Return performaction(174, 24)
	EndFunc

	Func skipcinematic()
		Return sendpacket(4, 93)
	EndFunc

	Func ensureenglish($aensure)
		If $aensure Then
			memorywrite($mensureenglish, 1)
		Else
			memorywrite($mensureenglish, 0)
		EndIf
	EndFunc

	Func togglelanguage()
		DllStructSetData($mtogglelanguage, 2, 24)
		enqueue($mtogglelanguageptr, 8)
	EndFunc

	Func changemaxzoom($azoom = 750)
		memorywrite($mzoomstill, $azoom, "float")
		memorywrite($mzoommoving, $azoom, "float")
	EndFunc

	Func setmaxmemory($amemory = 15728640)
		DllCall($mkernelhandle, "int", "SetProcessWorkingSetSizeEx", "int", $mgwprochandle, "int", 1, "int", $amemory, "int", 6)
	EndFunc

#EndRegion
#Region Skillbar

	Func setskillbarskill($aslot, $askillid, $aheronumber = 0)
		If $aheronumber = 0 Then
			Return sendpacket(20, 85, getmyid(), $aslot - 1, $askillid, 0)
		Else
			Local $loffset[6] = [0, 24, 76, 84, 36, 24 * ($aheronumber - 1)]
			Local $lagentid = memoryreadptr($mbasepointer, $loffset)
			Return sendpacket(20, 85, $lagentid[1], $aslot - 1, $askillid, 0)
		EndIf
	EndFunc

	Func loadskillbar($askill1 = 0, $askill2 = 0, $askill3 = 0, $askill4 = 0, $askill5 = 0, $askill6 = 0, $askill7 = 0, $askill8 = 0, $aheronumber = 0)
		If $aheronumber = 0 Then
			Return sendpacket(44, 86, getmyid(), 8, $askill1, $askill2, $askill3, $askill4, $askill5, $askill6, $askill7, $askill8)
		Else
			Local $loffset[6] = [0, 24, 76, 84, 36, 24 * ($aheronumber - 1)]
			Local $lagentid = memoryreadptr($mbasepointer, $loffset)
			Return sendpacket(44, 86, $lagentid[1], 8, $askill1, $askill2, $askill3, $askill4, $askill5, $askill6, $askill7, $askill8)
		EndIf
	EndFunc

	Func replaceskill($askill, $aslot, $aheronumber = 0)
		Return sendpacket(20, 85, getheroid($aheronumber), $aslot - 1, $askill, 0)
	EndFunc

	Func getskillbarskillrecharge($askillslot, $aheronumber = 0, $aptr = getskillbarptr($aheronumber))
		$askillslot -= 1
		$ltimestamp = memoryread($aptr + 12 + $askillslot * 20, "dword")
		If $ltimestamp = 0 Then Return 0
		Return $ltimestamp - getskilltimer()
	EndFunc

	Func getskillbarskilladrenaline($askillslot, $aheronumber = 0, $aptr = getskillbarptr($aheronumber))
		$askillslot -= 1
		Return memoryread($aptr + 4 + $askillslot * 20, "long")
	EndFunc

	#Region Ptr

		Func getskillbarptr($aheronumber = 0)
			Local $loffset[5] = [0, 24, 76, 84, 44]
			Local $lherocount = memoryreadptr($mbasepointer, $loffset)
			Local $loffset[5] = [0, 24, 44, 1776]
			For $i = 0 To $lherocount[1]
				$loffset[4] = $i * 188
				Local $lskillbarstructaddress = memoryreadptr($mbasepointer, $loffset)
				If $lskillbarstructaddress[1] = getheroid($aheronumber) Then Return $lskillbarstructaddress[0]
			Next
		EndFunc

		Func getskillbarptrbyheroid($aheroid)
			Local $loffset[5] = [0, 24, 76, 84, 44]
			Local $lherocount = memoryreadptr($mbasepointer, $loffset)
			Local $loffset[5] = [0, 24, 44, 1776]
			For $i = 0 To $lherocount[1]
				$loffset[4] = $i * 188
				Local $lskillbarstructaddress = memoryreadptr($mbasepointer, $loffset)
				If $lskillbarstructaddress[1] = $aheroid Then Return $lskillbarstructaddress[0]
			Next
		EndFunc

	#EndRegion Ptr
#EndRegion
#Region LoadSkilltemplate

	Func loadskilltemplate($atemplate, $aheronumber = 0)
		Local $lheroid = getheroid($aheronumber)
		Local $lsplittemplate = StringSplit($atemplate, "")
		Local $lattributestr = ""
		Local $lattributelevelstr = ""
		Local $ltemplatetype
		Local $lversionnumber
		Local $lprofbits
		Local $lprofprimary
		Local $lprofsecondary
		Local $lattributescount
		Local $lattributesbits
		Local $lskillsbits
		Local $lskills[8]
		Local $loptail
		$atemplate = ""
		For $i = 1 To $lsplittemplate[0]
			$atemplate &= base64tobin64($lsplittemplate[$i])
		Next
		$ltemplatetype = bin64todec(StringLeft($atemplate, 4))
		$atemplate = StringTrimLeft($atemplate, 4)
		If $ltemplatetype <> 14 Then Return False
		$lversionnumber = bin64todec(StringLeft($atemplate, 4))
		$atemplate = StringTrimLeft($atemplate, 4)
		$lprofbits = bin64todec(StringLeft($atemplate, 2)) * 2 + 4
		$atemplate = StringTrimLeft($atemplate, 2)
		$lprofprimary = bin64todec(StringLeft($atemplate, $lprofbits))
		$atemplate = StringTrimLeft($atemplate, $lprofbits)
		If $lprofprimary <> getheroprofession($aheronumber) Then Return False
		$lprofsecondary = bin64todec(StringLeft($atemplate, $lprofbits))
		$atemplate = StringTrimLeft($atemplate, $lprofbits)
		$lattributescount = bin64todec(StringLeft($atemplate, 4))
		$atemplate = StringTrimLeft($atemplate, 4)
		$lattributesbits = bin64todec(StringLeft($atemplate, 4)) + 4
		$atemplate = StringTrimLeft($atemplate, 4)
		For $i = 1 To $lattributescount
			$lattributestr &= bin64todec(StringLeft($atemplate, $lattributesbits))
			If $i <> $lattributescount Then $lattributestr &= "|"
			$atemplate = StringTrimLeft($atemplate, $lattributesbits)
			$lattributelevelstr &= bin64todec(StringLeft($atemplate, 4))
			If $i <> $lattributescount Then $lattributelevelstr &= "|"
			$atemplate = StringTrimLeft($atemplate, 4)
		Next
		$lskillsbits = bin64todec(StringLeft($atemplate, 4)) + 8
		$atemplate = StringTrimLeft($atemplate, 4)
		For $i = 0 To 7
			$lskills[$i] = bin64todec(StringLeft($atemplate, $lskillsbits))
			$atemplate = StringTrimLeft($atemplate, $lskillsbits)
		Next
		$loptail = bin64todec($atemplate)
		changesecondprofession($lprofsecondary, $aheronumber)
		setattributes($lattributestr, $lattributelevelstr, $aheronumber)
		loadskillbar($lskills[0], $lskills[1], $lskills[2], $lskills[3], $lskills[4], $lskills[5], $lskills[6], $lskills[7], $aheronumber)
	EndFunc

	Func base64tobin64($acharacter)
		Select
			Case $acharacter == "A"
				Return "000000"
			Case $acharacter == "B"
				Return "100000"
			Case $acharacter == "C"
				Return "010000"
			Case $acharacter == "D"
				Return "110000"
			Case $acharacter == "E"
				Return "001000"
			Case $acharacter == "F"
				Return "101000"
			Case $acharacter == "G"
				Return "011000"
			Case $acharacter == "H"
				Return "111000"
			Case $acharacter == "I"
				Return "000100"
			Case $acharacter == "J"
				Return "100100"
			Case $acharacter == "K"
				Return "010100"
			Case $acharacter == "L"
				Return "110100"
			Case $acharacter == "M"
				Return "001100"
			Case $acharacter == "N"
				Return "101100"
			Case $acharacter == "O"
				Return "011100"
			Case $acharacter == "P"
				Return "111100"
			Case $acharacter == "Q"
				Return "000010"
			Case $acharacter == "R"
				Return "100010"
			Case $acharacter == "S"
				Return "010010"
			Case $acharacter == "T"
				Return "110010"
			Case $acharacter == "U"
				Return "001010"
			Case $acharacter == "V"
				Return "101010"
			Case $acharacter == "W"
				Return "011010"
			Case $acharacter == "X"
				Return "111010"
			Case $acharacter == "Y"
				Return "000110"
			Case $acharacter == "Z"
				Return "100110"
			Case $acharacter == "a"
				Return "010110"
			Case $acharacter == "b"
				Return "110110"
			Case $acharacter == "c"
				Return "001110"
			Case $acharacter == "d"
				Return "101110"
			Case $acharacter == "e"
				Return "011110"
			Case $acharacter == "f"
				Return "111110"
			Case $acharacter == "g"
				Return "000001"
			Case $acharacter == "h"
				Return "100001"
			Case $acharacter == "i"
				Return "010001"
			Case $acharacter == "j"
				Return "110001"
			Case $acharacter == "k"
				Return "001001"
			Case $acharacter == "l"
				Return "101001"
			Case $acharacter == "m"
				Return "011001"
			Case $acharacter == "n"
				Return "111001"
			Case $acharacter == "o"
				Return "000101"
			Case $acharacter == "p"
				Return "100101"
			Case $acharacter == "q"
				Return "010101"
			Case $acharacter == "r"
				Return "110101"
			Case $acharacter == "s"
				Return "001101"
			Case $acharacter == "t"
				Return "101101"
			Case $acharacter == "u"
				Return "011101"
			Case $acharacter == "v"
				Return "111101"
			Case $acharacter == "w"
				Return "000011"
			Case $acharacter == "x"
				Return "100011"
			Case $acharacter == "y"
				Return "010011"
			Case $acharacter == "z"
				Return "110011"
			Case $acharacter == "0"
				Return "001011"
			Case $acharacter == "1"
				Return "101011"
			Case $acharacter == "2"
				Return "011011"
			Case $acharacter == "3"
				Return "111011"
			Case $acharacter == "4"
				Return "000111"
			Case $acharacter == "5"
				Return "100111"
			Case $acharacter == "6"
				Return "010111"
			Case $acharacter == "7"
				Return "110111"
			Case $acharacter == "8"
				Return "001111"
			Case $acharacter == "9"
				Return "101111"
			Case $acharacter == "+"
				Return "011111"
			Case $acharacter == "/"
				Return "111111"
		EndSelect
	EndFunc

	Func bin64todec($abinary)
		Local $lreturn = 0
		For $i = 1 To StringLen($abinary)
			If StringMid($abinary, $i, 1) == 1 Then $lreturn += 2 ^ ($i - 1)
		Next
		Return $lreturn
	EndFunc

#EndRegion
#Region Attributes

	Func loadattributes($aattributesarray, $aheronumber = 0)
		Local $lprimaryattribute
		Local $ldeadlock
		Local $lheroid = getheroid($aheronumber)
		$lprimaryattribute = getprofprimaryattribute(getheroprofession($aheronumber))
		If $aattributesarray[0][0] <> 0 AND getheroprofession($aheronumber, True) <> $aattributesarray[0][0] AND getheroprofession($aheronumber) <> $aattributesarray[0][0] Then
			Do
				$ldeadlock = TimerInit()
				changesecondprofession($aattributesarray[0][0], $aheronumber)
				Do
					Sleep(20)
				Until getheroprofession($aheronumber, True) = $aattributesarray[0][0] OR TimerDiff($ldeadlock) > 5000
			Until getheroprofession($aheronumber, True) = $aattributesarray[0][0]
		EndIf
		$aattributesarray[0][0] = $lprimaryattribute
		For $i = 0 To UBound($aattributesarray) - 1
			If $aattributesarray[$i][1] > 12 Then $aattributesarray[$i][1] = 12
			If $aattributesarray[$i][1] < 0 Then $aattributesarray[$i][1] = 0
		Next
		While getattributebyid($lprimaryattribute, False, $aheronumber) > $aattributesarray[0][1]
			$llevel = getattributebyid($lprimaryattribute, False, $aheronumber)
			$ldeadlock = TimerInit()
			decreaseattribute($lprimaryattribute, $aheronumber)
			Do
				Sleep(20)
			Until getattributebyid($lprimaryattribute, False, $aheronumber) < $llevel OR TimerDiff($ldeadlock) > 5000
			tolsleep()
		WEnd
		For $i = 1 To UBound($aattributesarray) - 1
			While getattributebyid($aattributesarray[$i][0], False, $aheronumber) > $aattributesarray[$i][1]
				$llevel = getattributebyid($aattributesarray[$i][0], False, $aheronumber)
				$ldeadlock = TimerInit()
				decreaseattribute($aattributesarray[$i][0], $aheronumber)
				Do
					Sleep(20)
				Until getattributebyid($aattributesarray[$i][0], False, $aheronumber) < $llevel OR TimerDiff($ldeadlock) > 5000
				tolsleep()
			WEnd
		Next
		For $i = 0 To 44
			If getattributebyid($i, False, $aheronumber) > 0 Then
				If $i = $lprimaryattribute Then ContinueLoop
				For $j = 1 To UBound($aattributesarray) - 1
					If $i = $aattributesarray[$j][0] Then ContinueLoop 2
					Local $ldummy
				Next
				While getattributebyid($i, False, $aheronumber) > 0
					$llevel = getattributebyid($i, False, $aheronumber)
					$ldeadlock = TimerInit()
					decreaseattribute($i, $aheronumber)
					Do
						Sleep(20)
					Until getattributebyid($i, False, $aheronumber) < $llevel OR TimerDiff($ldeadlock) > 5000
					tolsleep()
				WEnd
			EndIf
		Next
		While getattributebyid($lprimaryattribute, False, $aheronumber) < $aattributesarray[0][1]
			$llevel = getattributebyid($lprimaryattribute, False, $aheronumber)
			$ldeadlock = TimerInit()
			increaseattribute($lprimaryattribute, $aheronumber)
			Do
				Sleep(20)
			Until getattributebyid($lprimaryattribute, False, $aheronumber) > $llevel OR TimerDiff($ldeadlock) > 5000
			tolsleep()
		WEnd
		For $i = 1 To UBound($aattributesarray) - 1
			While getattributebyid($aattributesarray[$i][0], False, $aheronumber) < $aattributesarray[$i][1]
				$llevel = getattributebyid($aattributesarray[$i][0], False, $aheronumber)
				$ldeadlock = TimerInit()
				increaseattribute($aattributesarray[$i][0], $aheronumber)
				Do
					Sleep(20)
				Until getattributebyid($aattributesarray[$i][0], False, $aheronumber) > $llevel OR TimerDiff($ldeadlock) > 5000
				tolsleep()
			WEnd
		Next
	EndFunc

	Func increaseattribute($aattributeid, $aheronumber = 0)
		DllStructSetData($mincreaseattribute, 2, $aattributeid)
		DllStructSetData($mincreaseattribute, 3, getheroid($aheronumber))
		enqueue($mincreaseattributeptr, 12)
	EndFunc

	Func decreaseattribute($aattributeid, $aheronumber = 0)
		DllStructSetData($mdecreaseattribute, 2, $aattributeid)
		DllStructSetData($mdecreaseattribute, 3, getheroid($aheronumber))
		enqueue($mdecreaseattributeptr, 12)
	EndFunc

	Func setattributes($fattsid, $fattslevel, $aheronumber = 0)
		Local $lattsid = StringSplit(String($fattsid), "|")
		Local $lattslevel = StringSplit(String($fattslevel), "|")
		DllStructSetData($msetattributes, 4, getheroid($aheronumber))
		DllStructSetData($msetattributes, 5, $lattsid[0])
		DllStructSetData($msetattributes, 22, $lattsid[0])
		For $i = 1 To $lattsid[0]
			DllStructSetData($msetattributes, 5 + $i, $lattsid[$i])
		Next
		For $i = 1 To $lattslevel[0]
			DllStructSetData($msetattributes, 22 + $i, $lattslevel[$i])
		Next
		enqueue($msetattributesptr, 152)
	EndFunc

	Func maxattributes($aatt1id, $aatt2id = 255, $aheronumber = 0)
		DllStructSetData($mmaxattributes, 4, getheroid($aheronumber))
		DllStructSetData($mmaxattributes, 6, $aatt1id)
		DllStructSetData($mmaxattributes, 7, $aatt2id)
		enqueue($mmaxattributesptr, 152)
	EndFunc

	Func clearattributes($aheronumber = 0)
		Local $llevel
		If getmaploading() <> 0 Then Return
		For $i = 0 To 44
			If getattributebyid($i, False, $aheronumber) > 0 Then
				Do
					$llevel = getattributebyid($i, False, $aheronumber)
					$ldeadlock = TimerInit()
					decreaseattribute($i, $aheronumber)
					Do
						Sleep(20)
					Until $llevel > getattributebyid($i, False, $aheronumber) OR TimerDiff($ldeadlock) > 5000
					Sleep(100)
				Until getattributebyid($i, False, $aheronumber) = 0
			EndIf
		Next
	EndFunc

	Func getprofessionbyattribute($aattr)
		Switch $aattr
			Case 0, 1, 2, 3
				Return 5
			Case 4, 5, 6, 7
				Return 4
			Case 8, 9, 10, 11, 12
				Return 6
			Case 13, 14, 15, 16
				Return 3
			Case 17, 18, 19, 20, 21
				Return 1
			Case 22, 23, 24, 25
				Return 2
			Case 29, 30, 31, 35
				Return 7
			Case 32, 33, 36, 36
				Return 8
			Case 37, 38, 39, 40
				Return 9
			Case 41, 42, 43, 44
				Return 10
			Case Else
				Return 0
		EndSwitch
	EndFunc

	Func getsecondaryattributesbyprofession($aprof)
		Switch $aprof
			Case 0
				Local $ret[1] = [0]
			Case 5
				Local $ret[4] = [3, 2, 1, 3]
			Case 4
				Local $ret[4] = [3, 4, 5, 7]
			Case 6
				Local $ret[5] = [4, 8, 9, 10, 11]
			Case 3
				Local $ret[4] = [3, 13, 14, 15]
			Case 1
				Local $ret[5] = [4, 18, 19, 20, 21]
			Case 2
				Local $ret[4] = [3, 22, 24, 25]
			Case 7
				Local $ret[4] = [3, 29, 30, 31]
			Case 8
				Local $ret[4] = [3, 32, 33, 34]
			Case 9
				Local $ret[4] = [3, 37, 38, 39]
			Case 10
				Local $ret[4] = [3, 41, 42, 43]
		EndSwitch
		Return $ret
	EndFunc

	Func getattributebyid($aattributeid, $awithrunes = False, $aheronumber = 0)
		Local $lagentid = getheroid($aheronumber)
		Local $lbuffer
		Local $loffset[5] = [0, 24, 44, 172]
		For $i = 0 To getherocount()
			$loffset[4] = 984 * $i
			$lbuffer = memoryreadptr($mbasepointer, $loffset)
			If $lbuffer[1] = $lagentid Then
				If $awithrunes Then
					$loffset[4] = 984 * $i + 20 * $aattributeid + 12
				Else
					$loffset[4] = 984 * $i + 20 * $aattributeid + 8
				EndIf
				$lbuffer = memoryreadptr($mbasepointer, $loffset)
				Return $lbuffer[1]
			EndIf
		Next
	EndFunc

	Func getprofprimaryattribute($aprofession)
		Switch $aprofession
			Case 1
				Return 17
			Case 2
				Return 23
			Case 3
				Return 16
			Case 4
				Return 6
			Case 5
				Return 0
			Case 6
				Return 12
			Case 7
				Return 35
			Case 8
				Return 36
			Case 9
				Return 40
			Case 10
				Return 44
		EndSwitch
	EndFunc

#EndRegion
#Region Single Skills

	Func isrecharged($askillslot, $aheronumber = 0, $aptr = getskillbarptr($aheronumber))
		Return getskillbarskillrecharge($askillslot, $aheronumber, $aptr) = 0
	EndFunc

	Func getskillbarskillid($askillslot, $aheronumber = 0, $aptr = getskillbarptr($aheronumber))
		$askillslot -= 1
		Return memoryread($aptr + 16 + $askillslot * 20, "dword")
	EndFunc

	Func getskilltimer()
		Static Local $lexestart = memoryread($mskilltimer, "DWORD")
		Local $ltickcount = DllCall($mkernelhandle, "DWORD", "GetTickCount")[0]
		Return Int($ltickcount + $lexestart, 1)
	EndFunc

	Func skilldamageamount($askill)
		If IsPtr($askill) <> 0 Then
			Return memoryread($askill + 96, "long")
		ElseIf IsDllStruct($askill) <> 0 Then
			Return DllStructGetData($askill, "Scale15")
		Else
			Return memoryread(getskillptr($askill) + 96, "long")
		EndIf
	EndFunc

	Func skillaoerange($askill)
		If IsPtr($askill) <> 0 Then
			Return memoryread($askill + 108, "float")
		ElseIf IsDllStruct($askill) <> 0 Then
			Return DllStructGetData($askill, "AoERange")
		Else
			Return memoryread(getskillptr($askill) + 108, "float")
		EndIf
	EndFunc

	Func skillrecharge($askill)
		If IsPtr($askill) <> 0 Then
			Return memoryread($askill + 76, "long")
		ElseIf IsDllStruct($askill) <> 0 Then
			Return DllStructGetData($askill, "Recharge")
		Else
			Return memoryread(getskillptr($askill) + 76, "long")
		EndIf
	EndFunc

	Func skillactivation($askill)
		If IsPtr($askill) <> 0 Then
			Return memoryread($askill + 60, "float")
		ElseIf IsDllStruct($askill) <> 0 Then
			Return DllStructGetData($askill, "Activation")
		Else
			Return memoryread(getskillptr($askill) + 60, "float")
		EndIf
	EndFunc

	Func skillattribute($askill)
		If IsPtr($askill) <> 0 Then
			Return memoryread($askill + 41, "byte")
		ElseIf IsDllStruct($askill) <> 0 Then
			Return DllStructGetData($askill, "Attribute")
		Else
			Return memoryread(getskillptr($askill) + 41, "byte")
		EndIf
	EndFunc

	#Region Type

		Func ishexspell($askill)
			If IsPtr($askill) <> 0 Then
				Return memoryread($askill + 12, "long") = 4
			ElseIf IsDllStruct($askill) <> 0 Then
				Return DllStructGetData($askill, "Type") = 4
			Else
				Return memoryread(getskillptr($askill) + 12, "long") = 4
			EndIf
		EndFunc

		Func isconditionspell($askill)
			If IsPtr($askill) <> 0 Then
				Return memoryread($askill + 12, "long") = 8
			ElseIf IsDllStruct($askill) <> 0 Then
				Return DllStructGetData($askill, "Type") = 8
			Else
				Return memoryread(getskillptr($askill) + 12, "long") = 8
			EndIf
		EndFunc

		Func isenchantmentskill($askill)
			If IsPtr($askill) <> 0 Then
				Return memoryread($askill + 12, "long") = 6
			ElseIf IsDllStruct($askill) <> 0 Then
				Return DllStructGetData($askill, "Type") = 6
			Else
				Return memoryread(getskillptr($askill) + 12, "long") = 6
			EndIf
		EndFunc

		Func isattackskill($askill)
			If IsPtr($askill) <> 0 Then
				Return memoryread($askill + 12, "long") = 14
			ElseIf IsDllStruct($askill) <> 0 Then
				Return DllStructGetData($askill, "Type") = 14
			Else
				Return memoryread(getskillptr($askill) + 12, "long") = 14
			EndIf
		EndFunc

	#EndRegion
	#Region Requirements

		Func skillrequiresbleeding($askill)
			If IsPtr($askill) <> 0 Then
				Return BitAND(memoryread($askill + 28, "long"), 1)
			ElseIf IsDllStruct($askill) <> 0 Then
				Return BitAND(DllStructGetData($askill, "Condition"), 1)
			Else
				Return BitAND(memoryread(getskillptr($askill) + 28, "long"), 1)
			EndIf
		EndFunc

		Func skillrequiresburning($askill)
			If IsPtr($askill) <> 0 Then
				Return BitAND(memoryread($askill + 28, "long"), 4)
			ElseIf IsDllStruct($askill) <> 0 Then
				Return BitAND(DllStructGetData($askill, "Condition"), 4)
			Else
				Return BitAND(memoryread(getskillptr($askill) + 28, "long"), 4)
			EndIf
		EndFunc

		Func skillrequirescripple($askill)
			If IsPtr($askill) <> 0 Then
				Return BitAND(memoryread($askill + 28, "long"), 8)
			ElseIf IsDllStruct($askill) <> 0 Then
				Return BitAND(DllStructGetData($askill, "Condition"), 8)
			Else
				Return BitAND(memoryread(getskillptr($askill) + 28, "long"), 8)
			EndIf
		EndFunc

		Func skillrequiresdeepwound($askill)
			If IsPtr($askill) <> 0 Then
				Return BitAND(memoryread($askill + 28, "long"), 16)
			ElseIf IsDllStruct($askill) <> 0 Then
				Return BitAND(DllStructGetData($askill, "Condition"), 16)
			Else
				Return BitAND(memoryread(getskillptr($askill) + 28, "long"), 16)
			EndIf
		EndFunc

		Func skillrequiresearthhex($askill)
			If IsPtr($askill) <> 0 Then
				Return BitAND(memoryread($askill + 28, "long"), 64)
			ElseIf IsDllStruct($askill) <> 0 Then
				Return BitAND(DllStructGetData($askill, "Condition"), 64)
			Else
				Return BitAND(memoryread(getskillptr($askill) + 28, "long"), 64)
			EndIf
		EndFunc

		Func skillrequiresknockdown($askill)
			If IsPtr($askill) <> 0 Then
				Return BitAND(memoryread($askill + 28, "long"), 128)
			ElseIf IsDllStruct($askill) <> 0 Then
				Return BitAND(DllStructGetData($askill, "Condition"), 128)
			Else
				Return BitAND(memoryread(getskillptr($askill) + 28, "long"), 128)
			EndIf
		EndFunc

		Func skillrequiresweakness($askill)
			If IsPtr($askill) <> 0 Then
				Return BitAND(memoryread($askill + 28, "long"), 1024)
			ElseIf IsDllStruct($askill) <> 0 Then
				Return BitAND(DllStructGetData($askill, "Condition"), 1024)
			Else
				Return BitAND(memoryread(getskillptr($askill) + 28, "long"), 1024)
			EndIf
		EndFunc

		Func skillrequireswaterhex($askill)
			If IsPtr($askill) <> 0 Then
				Return BitAND(memoryread($askill + 28, "long"), 2048)
			ElseIf IsDllStruct($askill) <> 0 Then
				Return BitAND(DllStructGetData($askill, "Condition"), 2048)
			Else
				Return BitAND(memoryread(getskillptr($askill) + 28, "long"), 2048)
			EndIf
		EndFunc

		Func isinterruptskill($askill)
			If IsPtr($askill) <> 0 Then
				Local $lskillid = memoryread($askill, "long")
			ElseIf IsDllStruct($askill) <> 0 Then
				Local $lskillid = DllStructGetData($askill, "ID")
			Else
				Local $lskillid = $askill
			EndIf
			Switch $lskillid
				Case 2358
					Return True
				Case 2066
					Return True
				Case 340
					Return True
				Case 325
					Return True
				Case 399
					Return True
				Case 2194
					Return True
				Case 390
					Return True
				Case 329
					Return True
				Case 2143
					Return True
				Case 1726
					Return True
				Case 409
					Return True
				Case 426
					Return True
				Case 61
					Return True
				Case 1057
					Return True
				Case 1350
					Return True
				Case 228
					Return True
				Case 1025
					Return True
				Case 975
					Return True
				Case 1538
					Return True
				Case 1512
					Return True
				Case 445
					Return True
				Case 932
					Return True
				Case 57
					Return True
				Case 1053
					Return True
				Case 1342
					Return True
				Case 1344
					Return True
				Case 571
					Return True
				Case 860
					Return True
				Case 1992
					Return True
				Case 988
					Return True
				Case 5
					Return True
				Case 25
					Return True
				Case 953
					Return True
				Case 24
					Return True
				Case 803
					Return True
				Case 1994
					Return True
				Case 931
					Return True
				Case 23
					Return True
				Case Else
					Return False
			EndSwitch
		EndFunc

		Func isweaponspell($askill)
			If IsPtr($askill) <> 0 Then
				Return memoryread($askill + 12, "long") = 25
			ElseIf IsDllStruct($askill) <> 0 Then
				Return DllStructGetData($askill, "Type") = 25
			Else
				Return memoryread(getskillptr($askill) + 12, "long") = 25
			EndIf
		EndFunc

		Func skillrequirescondition($askill)
			If IsPtr($askill) <> 0 Then
				Local $lskillid = memoryread($askill, "long")
			ElseIf IsDllStruct($askill) <> 0 Then
				Local $lskillid = DllStructGetData($askill, "ID")
			Else
				Local $lskillid = $askill
			EndIf
			Switch $lskillid
				Case 365
					Return True
				Case 1137
					Return True
				Case 870
					Return True
				Case 440
					Return True
				Case 1471
					Return True
				Case 817
					Return True
				Case 864
					Return True
				Case 1950
					Return True
				Case 828
					Return True
				Case 107
					Return True
				Case 78
					Return True
				Case 1333
					Return True
				Case 55
					Return True
				Case 19
					Return True
				Case 1334
					Return True
				Case 217
					Return True
				Case 786
					Return True
				Case 1633
					Return True
				Case 1991
					Return True
				Case 1034
					Return True
				Case 2186
					Return True
				Case 1036
					Return True
				Case 1604
					Return True
				Case 1957
					Return True
				Case 1602
					Return True
				Case 1515
					Return True
				Case 1486
					Return True
				Case Else
					Return False
			EndSwitch
		EndFunc

		Func skillrequireshex($askill)
			If IsPtr($askill) <> 0 Then
				Local $lskillid = memoryread($askill, "long")
			ElseIf IsDllStruct($askill) <> 0 Then
				Local $lskillid = DllStructGetData($askill, "ID")
			Else
				Local $lskillid = $askill
			EndIf
			Switch $lskillid
				Case 303
					Return True
				Case 2003
					Return True
				Case 1692
					Return True
				Case 848
					Return True
				Case 302
					Return True
				Case 1337
					Return True
				Case 1059
					Return True
				Case 1348
					Return True
				Case 22
					Return True
				Case 1049
					Return True
				Case 27
					Return True
				Case 67
					Return True
				Case Else
					Return False
			EndSwitch
		EndFunc

		Func issummonskill($askill)
			If IsPtr($askill) <> 0 Then
				Local $lskillid = memoryread($askill, "long")
			ElseIf IsDllStruct($askill) <> 0 Then
				Local $lskillid = DllStructGetData($askill, "ID")
			Else
				Local $lskillid = $askill
			EndIf
			Switch $lskillid
				Case 2226
					Return True
				Case 2224
					Return True
				Case 2227
					Return True
				Case 2225
					Return True
				Case Else
					Return False
			EndSwitch
		EndFunc

		Func isantimeleeskill($askill)
			If IsPtr($askill) <> 0 Then
				Local $lskillid = memoryread($askill, "long")
			ElseIf IsDllStruct($askill) <> 0 Then
				Local $lskillid = DllStructGetData($askill, "ID")
			Else
				Local $lskillid = $askill
			EndIf
			Switch $lskillid
				Case 1130
					Return True
				Case 240
					Return True
				Case 2006
					Return True
				Case 296
					Return True
				Case 1657
					Return True
				Case 294
					Return True
				Case 47
					Return True
				Case 43
					Return True
				Case 2056
					Return True
				Case Else
					Return False
			EndSwitch
		EndFunc

	#EndRegion
	#Region Special

		Func iseliteskill($askill)
			If IsPtr($askill) <> 0 Then
				Return memoryread($askill + 16, "long") = 4
			ElseIf IsDllStruct($askill) <> 0 Then
				Return DllStructGetData($askill, "Special") = 4
			Else
				Return memoryread(getskillptr($askill) + 16, "long") = 4
			EndIf
		EndFunc

		Func ispveskill($askill)
			If IsPtr($askill) <> 0 Then
				Return BitAND(memoryread($askill + 16, "long"), 524288)
			ElseIf IsDllStruct($askill) <> 0 Then
				Return BitAND(DllStructGetData($askill, "Special"), 524288)
			Else
				Return BitAND(memoryread(getskillptr($askill) + 16, "long"), 524288)
			EndIf
		EndFunc

	#EndRegion
	#Region Skilltypes

		Func isspiritskill($askill)
			If IsPtr($askill) <> 0 Then
				Local $lskillid = memoryread($askill, "long")
			ElseIf IsDllStruct($askill) <> 0 Then
				Local $lskillid = DllStructGetData($askill, "ID")
			Else
				Local $lskillid = $askill
			EndIf
			Switch $lskillid
				Case 1239
					Return True
				Case 2205
					Return True
				Case 1745
					Return True
				Case 1253
					Return True
				Case 2656
					Return True
				Case 920
					Return True
				Case 923
					Return True
				Case 1249
					Return True
				Case 921
					Return True
				Case 1252
					Return True
				Case 1747
					Return True
				Case 1734
					Return True
				Case 1251
					Return True
				Case 1901
					Return True
				Case 1247
					Return True
				Case 1250
					Return True
				Case 1748
					Return True
				Case 981
					Return True
				Case 2204
					Return True
				Case 963
					Return True
				Case 871
					Return True
				Case 982
					Return True
				Case 1266
					Return True
				Case 911
					Return True
				Case 2110
					Return True
				Case 1255
					Return True
				Case Else
					Return False
			EndSwitch
		EndFunc

		Func isenchantmentstrip($askill)
			If IsPtr($askill) <> 0 Then
				Local $lskillid = memoryread($askill, "long")
			ElseIf IsDllStruct($askill) <> 0 Then
				Local $lskillid = DllStructGetData($askill, "ID")
			Else
				Local $lskillid = $askill
			EndIf
			Switch $lskillid
				Case 144
					Return True
				Case 1362
					Return True
				Case 936
					Return True
				Case 763
					Return True
				Case 1359
					Return True
				Case 141
					Return True
				Case 955
					Return True
				Case 143
					Return True
				Case 1656
					Return True
				Case 1347
					Return True
				Case 68
					Return True
				Case 1061
					Return True
				Case 21
					Return True
				Case 877
					Return True
				Case 1349
					Return True
				Case 1048
					Return True
				Case 69
					Return True
				Case 933
					Return True
				Case 882
					Return True
				Case 1643
					Return True
				Case 990
					Return True
				Case 1645
					Return True
				Case 1634
					Return True
				Case 1648
					Return True
				Case 1534
					Return True
				Case 1545
					Return True
				Case Else
					Return False
			EndSwitch
		EndFunc

		Func ishealskill($askill)
			If IsPtr($askill) <> 0 Then
				If BitAND(memoryread($askill + 24, "long"), 4096) Then Return True
				Local $lskilleffect2 = memoryread($askill + 32, "long")
				If BitAND($lskilleffect2, 2) OR BitAND($lskilleffect2, 4) Then Return True
				Local $lskillattribute = memoryread($askill + 41, "byte")
			ElseIf IsDllStruct($askill) <> 0 Then
				If BitAND(DllStructGetData($askill, "Effect1"), 4096) Then Return True
				Local $lskilleffect2 = DllStructGetData($askill, "Effect2")
				If BitAND($lskilleffect2, 2) OR BitAND($lskilleffect2, 4) Then Return True
				Local $lskillattribute = DllStructGetData($askill, "Attribute")
			Else
				Local $lptr = getagentptr($askill)
				If BitAND(memoryread($lptr + 24, "long"), 4096) Then Return True
				Local $lskilleffect2 = memoryread($lptr + 32, "long")
				If BitAND($lskilleffect2, 2) OR BitAND($lskilleffect2, 4) Then Return True
				Local $lskillattribute = memoryread($lptr + 41, "byte")
			EndIf
			Switch $lskillattribute
				Case 13, 15, 16
					Return True
				Case Else
					Return False
			EndSwitch
		EndFunc

		Func isresskill($askill)
			If IsPtr($askill) <> 0 Then
				Local $lskillid = memoryread($askill, "long")
			ElseIf IsDllStruct($askill) <> 0 Then
				Local $lskillid = DllStructGetData($askill, "ID")
			Else
				Local $lskillid = $askill
			EndIf
			Switch $lskillid
				Case 2217
					Return True
				Case 1592
					Return True
				Case 2872
					Return True
				Case 2109
					Return True
				Case 791
					Return True
				Case 1865
					Return True
				Case 304
					Return True
				Case 1222
					Return True
				Case 306
					Return True
				Case 1263
					Return True
				Case 963
					Return True
				Case 314
					Return True
				Case 305
					Return True
				Case 1128
					Return True
				Case 2
					Return True
				Case 1778
					Return True
				Case 1816
					Return True
				Case 268
					Return True
				Case 315
					Return True
				Case Else
					Return False
			EndSwitch
		EndFunc

		Func isbelow50percentenemyskill($askill)
			If IsPtr($askill) <> 0 Then
				Local $lskillid = memoryread($askill, "long")
			ElseIf IsDllStruct($askill) <> 0 Then
				Local $lskillid = DllStructGetData($askill, "ID")
			Else
				Local $lskillid = $askill
			EndIf
			Switch $lskillid
				Case 2353
					Return True
				Case 385
					Return True
				Case 444
					Return True
				Case 1197
					Return True
				Case 282
					Return True
				Case 1687
					Return True
				Case 1365
					Return True
				Case 1069
					Return True
				Case 1646
					Return True
				Case Else
					Return False
			EndSwitch
		EndFunc

		Func ishexremovalskill($askill)
			If IsPtr($askill) <> 0 Then
				Return BitAND(memoryread($askill + 32, "long"), 2048)
			ElseIf IsDllStruct($askill) <> 0 Then
				Return BitAND(DllStructGetData($askill, "Effect2"), 2048)
			Else
				Return BitAND(memoryread(getskillptr($askill) + 32, "long"), 2048)
			EndIf
		EndFunc

		Func isconditionremovalskill($askill)
			If IsPtr($askill) <> 0 Then
				Return BitAND(memoryread($askill + 32, "long"), 4096)
			ElseIf IsDllStruct($askill) <> 0 Then
				Return BitAND(DllStructGetData($askill, "Effect2"), 4096)
			Else
				Return BitAND(memoryread(getskillptr($askill) + 32, "long"), 4096)
			EndIf
		EndFunc

	#EndRegion
	#Region Target

		Func targetselfskill($askill)
			If IsPtr($askill) <> 0 Then
				Return memoryread($askill + 49, "byte") = 0
			ElseIf IsDllStruct($askill) <> 0 Then
				Return DllStructGetData($askill, "Target") = 0
			Else
				Return memoryread(getskillptr($askill) + 49, "byte") = 0
			EndIf
		EndFunc

		Func targetspiritskill($askill)
			If IsPtr($askill) <> 0 Then
				Return memoryread($askill + 49, "byte") = 1
			ElseIf IsDllStruct($askill) <> 0 Then
				Return DllStructGetData($askill, "Target") = 1
			Else
				Return memoryread(getskillptr($askill) + 49, "byte") = 1
			EndIf
		EndFunc

		Func targetallyskill($askill)
			If IsPtr($askill) <> 0 Then
				Return memoryread($askill + 49, "byte") = 3
			ElseIf IsDllStruct($askill) <> 0 Then
				Return DllStructGetData($askill, "Target") = 3
			Else
				Return memoryread(getskillptr($askill) + 49, "byte") = 3
			EndIf
		EndFunc

		Func targetotherallyskill($askill)
			If IsPtr($askill) <> 0 Then
				Return memoryread($askill + 49, "byte") = 4
			ElseIf IsDllStruct($askill) <> 0 Then
				Return DllStructGetData($askill, "Target") = 4
			Else
				Return memoryread(getskillptr($askill) + 49, "byte") = 4
			EndIf
		EndFunc

		Func targetenemyskill($askill)
			If IsPtr($askill) <> 0 Then
				Return memoryread($askill + 49, "byte") = 5
			ElseIf IsDllStruct($askill) <> 0 Then
				Return DllStructGetData($askill, "Target") = 5
			Else
				Return memoryread(getskillptr($askill) + 49, "byte") = 5
			EndIf
		EndFunc

		Func targetdeadallyskill($askill)
			If IsPtr($askill) <> 0 Then
				Return memoryread($askill + 49, "byte") = 6
			ElseIf IsDllStruct($askill) <> 0 Then
				Return DllStructGetData($askill, "Target") = 6
			Else
				Return memoryread(getskillptr($askill) + 49, "byte") = 6
			EndIf
		EndFunc

		Func targetminionskill($askill)
			If IsPtr($askill) <> 0 Then
				Return memoryread($askill + 49, "byte") = 14
			ElseIf IsDllStruct($askill) <> 0 Then
				Return DllStructGetData($askill, "Target") = 14
			Else
				Return memoryread(getskillptr($askill) + 49, "byte") = 14
			EndIf
		EndFunc

		Func targetgroundskill($askill)
			If IsPtr($askill) <> 0 Then
				Return memoryread($askill + 49, "byte") = 16
			ElseIf IsDllStruct($askill) <> 0 Then
				Return DllStructGetData($askill, "Target") = 16
			Else
				Return memoryread(getskillptr($askill) + 49, "byte") = 16
			EndIf
		EndFunc

	#EndRegion
	#Region Ptr

		Func getskillptr($askillid)
			Local $skillptr = $mskillbase + 160 * $askillid
			Return Ptr($skillptr)
		EndFunc

	#EndRegion Ptr
#EndRegion
#Region UseSkill

	Func useskill($askillslot, $atarget, $acalltarget = False)
		If IsPtr($atarget) <> 0 Then
			Local $ltargetid = memoryread($atarget + 44, "long")
		ElseIf IsDllStruct($atarget) <> 0 Then
			Local $ltargetid = DllStructGetData($atarget, "ID")
		Else
			Local $ltargetid = convertid($atarget)
		EndIf
		DllStructSetData($museskill, 2, $askillslot)
		DllStructSetData($museskill, 3, $ltargetid)
		DllStructSetData($museskill, 4, $acalltarget)
		enqueue($museskillptr, 16)
	EndFunc

	Func useskillex($askillslot, $atarget = -2, $atimeout = 3000, $askillbarptr = getskillbarptr(0), $ame = getagentptr(-2))
		If IsPtr($atarget) <> 0 Then
			Local $ltargetptr = $atarget
		Else
			Local $ltargetptr = getagentptr($atarget)
		EndIf
		If $ltargetptr = 0 Then Return
		If getskillbarskillrecharge($askillslot, 0, $askillbarptr) <> 0 Then Return
		$ldeadlock = TimerInit()
		changetarget($atarget)
		Local $lskillptr = getskillptr(getskillbarskillid($askillslot, 0, $askillbarptr))
		useskill($askillslot, $atarget)
		update("Using skill " & $askillslot & ".")
		Do
			Sleep(50)
			If getisdead($ame) Then Return
			If getisdead($ltargetptr) Then Return
			If getenergy($ame) < memoryread($lskillptr + 53, "byte") Then Return
			If TimerDiff($ldeadlock) > $atimeout Then Return
		Until getskillbarskillrecharge($askillslot, 0, $askillbarptr) <> 0
		Return True
	EndFunc

	Func useskillbyid($askillid, $aagentid = 0, $askillbarptr = getskillbarptr(0), $ame = getagentptr(-2))
		For $i = 0 To 7
			If getskillbarskillid($i, 0, $askillbarptr) = $askillid Then
				Return useskillex($i + 1, $aagentid, Default, $askillbarptr, $ame)
			EndIf
		Next
	EndFunc

	Func useskillbyskillid($askillid, $atargettype = 0, $aagentid = -2)
		If $atargettype = 0 Then
			Return sendpacket(20, 64, $askillid, 0, convertid($aagentid), 0)
		Else
			Return sendpacket(20, 33, $askillid, 0, convertid($aagentid), 0)
		EndIf
	EndFunc

	Func useburningspeed()
		useskillbyskillid(823)
	EndFunc

	Func userezskillex($askillslot, $atarget, $atimeout = 7000, $askillbarptr = getskillbarptr(0), $ame = getagentptr(-2))
		If IsPtr($atarget) <> 0 Then
			$ltargetid = memoryread($atarget + 44, "long")
			$ltarget = $atarget
		ElseIf IsDllStruct($atarget) <> 0 Then
			$ltargetid = DllStructGetData($atarget, "ID")
			$ltarget = getagentptr($ltargetid)
		Else
			$ltargetid = convertid($atarget)
			$ltarget = getagentptr($ltargetid)
		EndIf
		$ldeadlock = TimerInit()
		changetarget($ltargetid)
		useskill($askillslot, $ltargetid)
		Do
			Sleep(50)
			death($ame)
			If TimerDiff($ldeadlock) > $atimeout Then Return
		Until getskillbarskillrecharge($askillslot, 0, $askillbarptr) <> 0 OR NOT getisdead($ltarget)
		If getiscasting($ame) Then cancelaction()
	EndFunc

	Func removehexskillex($askillslot, $atarget, $atimeout = 3500, $askillbarptr = getskillbarptr(0), $ame = getagentptr(-2))
		If IsPtr($atarget) <> 0 Then
			$ltargetid = memoryread($atarget + 44, "long")
			$ltarget = $atarget
		ElseIf IsDllStruct($atarget) <> 0 Then
			$ltargetid = DllStructGetData($atarget, "ID")
			$ltarget = getagentptr($ltargetid)
		Else
			$ltargetid = convertid($atarget)
			$ltarget = getagentptr($ltargetid)
		EndIf
		$ldeadlock = TimerInit()
		changetarget($ltargetid)
		useskill($askillslot, $ltargetid)
		Do
			Sleep(50)
			death($ame)
			If TimerDiff($ldeadlock) > $atimeout Then Return
		Until getskillbarskillrecharge($askillslot, 0, $askillbarptr) <> 0 OR NOT gethashex($ltarget) OR getisdead($ltarget)
		If getiscasting($ame) Then cancelaction()
	EndFunc

#EndRegion
#Region Buffs
	#Region Ptr

		Func getbuffptr($abuffnumber, $aheronumber = 0, $aheroid = getheroid($aheronumber))
			Local $loffset[4] = [0, 24, 44, 1296]
			Local $lcount = memoryreadptr($mbasepointer, $loffset)
			ReDim $loffset[5]
			$loffset[3] = 1288
			Local $lbuffer
			For $i = 0 To $lcount[1] - 1
				$loffset[4] = 36 * $i
				$lbuffer = memoryreadptr($mbasepointer, $loffset)
				If $lbuffer[1] = $aheroid Then
					$loffset[4] = 4 + 36 * $i
					ReDim $loffset[6]
					$loffset[5] = 16 * ($abuffnumber - 1)
					$lbuffstructaddress = memoryreadptr($mbasepointer, $loffset, "ptr")
					Return $lbuffstructaddress[0]
				EndIf
			Next
		EndFunc

	#EndRegion Ptr

	Func getbuffcount($aheronumber = 0, $aheroid = getheroid($aheronumber))
		Local $loffset[4] = [0, 24, 44, 1296]
		Local $lcount = memoryreadptr($mbasepointer, $loffset)
		ReDim $loffset[5]
		$loffset[3] = 1288
		Local $lbuffer
		For $i = 0 To $lcount[1] - 1
			$loffset[4] = 36 * $i
			$lbuffer = memoryreadptr($mbasepointer, $loffset)
			If $lbuffer[1] = $aheroid Then Return memoryread($lbuffer[0] + 12)
		Next
	EndFunc

	Func getistargetbuffed($askillid, $aagentid, $aheronumber = 0, $aheroid = getheroid($aheronumber))
		Local $lbuffcount = getbuffcount($aheronumber)
		For $i = 0 To $lbuffcount - 1
			$lptr = getbuffptr($i, $aheronumber, $aheroid)
			If memoryread($lptr, "long") = $askillid AND memoryread($lptr + 12, "long") = convertid($aagentid) Then
				Return $i + 1
			EndIf
		Next
	EndFunc

	Func dropbuff($askillid, $aagentid, $aheronumber = 0, $aheroid = getheroid($aheronumber))
		Local $lbuffcount = getbuffcount($aheronumber, $aheroid)
		Local $loffset[4] = [0, 24, 44, 1296]
		Local $lcount = memoryreadptr($mbasepointer, $loffset)
		ReDim $loffset[5]
		$loffset[3] = 1288
		For $i = 0 To $lcount[1] - 1
			$loffset[4] = 36 * $i
			$lbuffer = memoryreadptr($mbasepointer, $loffset)
			If $lbuffer[1] = $aheroid Then
				$loffset[4] = 4 + 36 * $i
				ReDim $loffset[6]
				For $j = 0 To $lbuffcount - 1
					$loffset[5] = 0 + 16 * $j
					$lbuffaddress = memoryreadptr($mbasepointer, $loffset)
					If $lbuffaddress[1] = $askillid AND memoryread($lbuffaddress[0] + 12, "long") = convertid($aagentid) Then
						Return sendpacket(8, 35, memoryread($lbuffaddress[0] + 8, "long"))
						ExitLoop 2
					EndIf
				Next
			EndIf
		Next
	EndFunc

	Func dropallbonds($aheronumber = 0, $aheroid = getheroid($aheronumber))
		Local $lbuffcount = getbuffcount($aheronumber, $aheroid)
		Local $loffset[4] = [0, 24, 44, 1296]
		Local $lcount = memoryreadptr($mbasepointer, $loffset)
		ReDim $loffset[5]
		$loffset[3] = 1288
		For $i = 0 To $lcount[1] - 1
			$loffset[4] = 36 * $i
			$lbuffer = memoryreadptr($mbasepointer, $loffset)
			If $lbuffer[1] = $aheroid Then
				$loffset[4] = 4 + 36 * $i
				ReDim $loffset[6]
				For $j = 0 To $lbuffcount - 1
					$loffset[5] = 0 + 16 * $j
					$lbuffaddress = memoryreadptr($mbasepointer, $loffset, "long")
					Switch $lbuffaddress[1]
						Case 263, 244, 242
							sendpacket(8, 35, memoryread($lbuffaddress[0] + 8, "long"))
					EndSwitch
				Next
			EndIf
		Next
	EndFunc

	Func dropallbuffs($aheronumber = 0, $aheroid = getheroid($aheronumber))
		Local $lbuffcount = getbuffcount($aheronumber, $aheroid)
		Local $loffset[4] = [0, 24, 44, 1296]
		Local $lcount = memoryreadptr($mbasepointer, $loffset)
		ReDim $loffset[5]
		$loffset[3] = 1288
		For $i = 0 To $lcount[1] - 1
			$loffset[4] = 36 * $i
			$lbuffer = memoryreadptr($mbasepointer, $loffset)
			If $lbuffer[1] = $aheroid Then
				$loffset[4] = 4 + 36 * $i
				ReDim $loffset[6]
				For $j = 0 To $lbuffcount - 1
					$loffset[5] = 0 + 16 * $j
					$lbuffaddress = memoryreadptr($mbasepointer, $loffset, "long")
					sendpacket(8, 35, memoryread($lbuffaddress[0] + 8, "long"))
				Next
			EndIf
		Next
	EndFunc

#EndRegion
#Region SkillEffects and co.
	#Region Ptr

		Func getskilleffectptr($askillid, $aheronumber = 0, $aheroid = getheroid($aheronumber))
			Local $loffset[4] = [0, 24, 44, 1296]
			Local $lcount = memoryreadptr($mbasepointer, $loffset)
			ReDim $loffset[5]
			$loffset[3] = 1288
			Local $lbuffer
			For $i = 0 To $lcount[1] - 1
				$loffset[4] = 36 * $i
				$lbuffer = memoryreadptr($mbasepointer, $loffset)
				If $lbuffer[1] = $aheroid Then
					$loffset[4] = 28 + 36 * $i
					$leffectcount = memoryreadptr($mbasepointer, $loffset)
					$loffset[4] = 20 + 36 * $i
					$leffectstructaddress = memoryreadptr($mbasepointer, $loffset, "ptr")
					For $j = 0 To $leffectcount[1] - 1
						$leffectskillid = memoryread($leffectstructaddress[1] + 24 * $j, "long")
						If $leffectskillid = $askillid Then Return Ptr($leffectstructaddress[1] + 24 * $j)
					Next
				EndIf
			Next
		EndFunc

		Func getskilleffectptrbyeffectnumber($aeffectnumber, $aheronumber = 0, $aheroid = getheroid($aheronumber))
			Local $loffset[4] = [0, 24, 44, 1296]
			Local $lcount = memoryreadptr($mbasepointer, $loffset)
			ReDim $loffset[5]
			$loffset[3] = 1288
			Local $lbuffer
			For $i = 0 To $lcount[1] - 1
				$loffset[4] = 36 * $i
				$lbuffer = memoryreadptr($mbasepointer, $loffset)
				If $lbuffer[1] = $aheroid Then
					$loffset[4] = 28 + 36 * $i
					$leffectcount = memoryreadptr($mbasepointer, $loffset)
					$loffset[4] = 20 + 36 * $i
					ReDim $loffset[6]
					$loffset[5] = 0
					$leffectstructaddress = memoryreadptr($mbasepointer, $loffset)
					Return Ptr($leffectstructaddress[0] + 24 * $aeffectnumber)
				EndIf
			Next
		EndFunc

		Func geteffectsptr($askillid = 0, $aheronumber = 0, $aheroid = getheroid($aheronumber))
			Local $leffectcount, $leffectstructaddress, $lbuffer
			Local $lamount = 0
			Local $loffset[4] = [0, 24, 44, 1296]
			Local $lcount = memoryreadptr($mbasepointer, $loffset)
			ReDim $loffset[5]
			$loffset[3] = 1288
			For $i = 0 To $lcount[1] - 1
				$loffset[4] = 36 * $i
				$lbuffer = memoryreadptr($mbasepointer, $loffset)
				If $lbuffer[1] = $aheroid Then
					$loffset[4] = 28 + 36 * $i
					$leffectcount = memoryreadptr($mbasepointer, $loffset)
					ReDim $loffset[6]
					$loffset[4] = 20 + 36 * $i
					$loffset[5] = 0
					$leffectstructaddress = memoryreadptr($mbasepointer, $loffset)
					If $askillid = 0 Then
						Local $lreturnarray[$leffectcount[1] + 1]
						$lreturnarray[0] = $leffectcount[1]
						For $i = 1 To $leffectcount[1]
							$lreturnarray[$i] = Ptr($leffectstructaddress[0] + 24 * ($i - 1))
						Next
						Return $lreturnarray
					Else
						Local $lreturnarray[2] = [0, 0]
						For $i = 0 To $leffectcount[1] - 1
							$lreturn = $leffectstructaddress[0] + 24 * $i
							If memoryread($lreturn, "long") = $askillid Then
								$lreturnarray[0] = 1
								$lreturnarray[1] = Ptr($lreturn)
								Return $lreturnarray
							EndIf
						Next
					EndIf
				EndIf
			Next
		EndFunc

	#EndRegion Ptr

	Func haseffect($aeffectskillid, $aheronumber = 0, $aheroid = getheroid($aheronumber))
		Return getskilleffectptr($aeffectskillid, $aheronumber, $aheroid) <> 0
	EndFunc

	Func geteffecttimeremaining($aeffect)
		If IsArray($aeffect) Then Return 0
		If $aeffect = 0 Then Return 0
		If IsPtr($aeffect) <> 0 Then
			$ltimestamp = memoryread($aeffect + 20, "long")
			$lduration = memoryread($aeffect + 16, "float")
		ElseIf IsDllStruct($aeffect) <> 0 Then
			$ltimestamp = DllStructGetData($aeffect, "TimeStamp")
			$lduration = DllStructGetData($aeffect, "Duration")
		Else
			Local $lptr = getskilleffectptr($aeffect)
			If $lptr = 0 Then Return 0
			$ltimestamp = memoryread($lptr + 20, "long")
			$lduration = memoryread($lptr + 16, "float")
		EndIf
		$lreturn = $lduration * 1000 - (getskilltimer() - $ltimestamp)
		Return $lreturn
	EndFunc

#EndRegion
#Region Misc

	Func changesecondprofession($aprofession, $aheronumber = 0, $aheroid = getheroid($aheronumber))
		Return sendpacket(12, 59, $aheroid, $aprofession)
	EndFunc

	Func getmorale($aheronumber = 0, $aheroid = getheroid($aheronumber))
		Local $loffset[4] = [0, 24, 44, 1592]
		Local $lindex = memoryreadptr($mbasepointer, $loffset)
		Local $loffset[6] = [0, 24, 44, 1580, 8 + 12 * BitAND($aheroid, $lindex[1]), 24]
		Local $lreturn = memoryreadptr($mbasepointer, $loffset)
		Return $lreturn[1] - 100
	EndFunc

#EndRegion
#Region Ptr

	Func getquestptrbyid($aquestid)
		Local $loffset[4] = [0, 24, 44, 1332]
		$lquestlogsize = memoryreadptr($mbasepointer, $loffset)
		Local $lquestid
		Local $loffset[5] = [0, 24, 44, 1324, 0]
		If $aquestid = 0 Then
			$loffset[3] = 1220
			$lquestid = memoryreadptr($mbasepointer, $loffset)
			Return Ptr($lquestid[0])
		EndIf
		For $i = 0 To $lquestlogsize[1]
			$loffset[4] = 52 * $i
			$lquestptr = memoryreadptr($mbasepointer, $loffset, "long")
			If $lquestptr[1] = $aquestid Then Return Ptr($lquestptr[0])
		Next
	EndFunc

	Func getquestptrbylognumber($alognumber)
		$alognumber -= 1
		Local $loffset[5] = [0, 24, 44, 1324, 52 * $alognumber]
		$lquestptr = memoryreadptr($mbasepointer, $loffset, "ptr")
		Return $lquestptr[0]
	EndFunc

#EndRegion Ptr
#Region Dialogs

	Func acceptquest($aquestid)
		Return sendpacket(8, 53, "0x008" & Hex($aquestid, 3) & "01")
	EndFunc

	Func questreward($aquestid)
		Return sendpacket(8, 53, "0x008" & Hex($aquestid, 3) & "07")
	EndFunc

	Func abandonquest($aquestid)
		Return sendpacket(8, 10, $aquestid)
	EndFunc

#EndRegion
#Region QuestState

	Func updatequest($aquestid)
		togglequestwindow()
		togglequestwindow()
	EndFunc

#EndRegion

Func tradeplayer($aagent)
	If IsPtr($aagent) <> 0 Then
		Local $lagentid = memoryread($aagent + 44, "long")
	ElseIf IsDllStruct($aagent) <> 0 Then
		Local $lagentid = DllStructGetData($aagent, "ID")
	Else
		Local $lagentid = convertid($aagent)
	EndIf
	sendpacket(8, 67, $lagentid)
EndFunc

Func accepttrade()
	Return sendpacket(4, 180)
EndFunc

Func canceltrade()
	Return sendpacket(4, 174)
EndFunc

Func changeoffer()
	Return sendpacket(4, 179)
EndFunc

Func submitoffer($agold = 0)
	Return sendpacket(8, 176, $agold)
EndFunc

Func offeritem($aitemid, $aquantity = 1)
	If IsPtr($aitemid) <> 0 Then
		Local $litemid = memoryread($aitemid, "long")
		Local $lquantity = memoryread($aitemid + 75, "byte")
	ElseIf IsDllStruct($aitemid) <> 0 Then
		Local $litemid = DllStructGetData($aitemid, "ID")
		Local $lquantity = DllStructGetData($aitemid, "Quantity")
	Else
		Local $litemid = $aitemid
		Local $lquantity = memoryread(getitemptr($aitemid) + 75, "byte")
	EndIf
	If $aquantity > $lquantity Then
		Return sendpacket(12, 175, $litemid, $lquantity)
	Else
		Return sendpacket(12, 175, $litemid, $aquantity)
	EndIf
EndFunc

Func emoting()
	Switch (Random(1, 6, 1))
		Case 1
			dance()
		Case 2
			clap()
		Case 3
			excited()
		Case 4
			drum()
		Case 5
			flute()
		Case 6
			violin()
	EndSwitch
EndFunc

Func dance()
	sendchat("dance", "/")
EndFunc

Func clap()
	sendchat("clap", "/")
EndFunc

Func excited()
	sendchat("excited", "/")
EndFunc

Func drum()
	sendchat("drum", "/")
EndFunc

Func flute()
	sendchat("flute", "/")
EndFunc

Func violin()
	sendchat("violin", "/")
EndFunc

Func jump()
	sendchat("jump", "/")
EndFunc

Func _guiroundcorners($h_win, $isize)
	Local $xs_pos, $xs_ret
	$xs_pos = WinGetPos($h_win)
	$xs_ret = DllCall("gdi32.dll", "long", "CreateRoundRectRgn", "long", 0, "long", 0, "long", $xs_pos[2] + 1, "long", $xs_pos[3] + 1, "long", $isize, "long", $isize)
	If $xs_ret[0] Then
		DllCall("user32.dll", "long", "SetWindowRgn", "hwnd", $h_win, "long", $xs_ret[0], "int", 1)
	EndIf
EndFunc

Global Const $math_isnotdivisible = 1
Global Const $math_isdivisible = 2
Global Const $math_degrees = 57.2957795130823

Func _degree($iradians)
	Return IsNumber($iradians) ? $iradians * $math_degrees : SetError(1, 0, "")
EndFunc

Func _mathcheckdiv($inum1, $inum2 = 2)
	If NOT (IsInt($inum1) AND IsInt($inum2)) Then
		Return SetError(1, 0, -1)
	EndIf
	Return (Mod($inum1, $inum2) = 0) ? $math_isdivisible : $math_isnotdivisible
EndFunc

Func _max($inum1, $inum2)
	If NOT IsNumber($inum1) Then Return SetError(1, 0, 0)
	If NOT IsNumber($inum2) Then Return SetError(2, 0, 0)
	Return ($inum1 > $inum2) ? $inum1 : $inum2
EndFunc

Func _min($inum1, $inum2)
	If NOT IsNumber($inum1) Then Return SetError(1, 0, 0)
	If NOT IsNumber($inum2) Then Return SetError(2, 0, 0)
	Return ($inum1 > $inum2) ? $inum2 : $inum1
EndFunc

Func _radian($idegrees)
	Return Number($idegrees) ? $idegrees / $math_degrees : SetError(1, 0, "")
EndFunc

#Region Configuration
	Local Const $version = "1.1"
	Local Const $pickupall = True
#EndRegion
#Region Build
	Local Const $skillbartemplate_player = "OgcTcZ885RgNB1ZHQWZoT48cAA"
	Local Const $skill_return = [1, 15, 770]
	Local Const $skill_serpent = [2, 5, 456]
	Local Const $skill_shadowform = [3, 5, 826]
	Local Const $skill_shroud = [4, 10, 1031]
	Local Const $skill_storm = [5, 5, 1474]
	Local Const $skill_soh = [6, 5, 929]
	Local Const $skill_whirling = [7, 10, 450]
	Local Const $skill_winnowing = [8, 5, 463]
#EndRegion
#Region Variables
	Global $xs_n
	Local $dyetosell
	Local $nbruns = 0
	Local $nbfails = 0
	Local $brunning = False
	Local $binitialized = False
	Local $bresignrdy = False
#EndRegion
#Region Constants
	Local Const $mapid_anjeka = 349
	Local Const $mapid_drazach = 195
	Local Const $modeid_breambelrecurve = 934
	Local Const $modeid_breambellong = 868
	Local Const $modeid_breambelshort = 957
	Local Const $modeid_breambelflat = 904
	Local Const $modeid_breambelhorn = 906
	Local Const $modelid_echovald = 945
	Local Const $modelid_gothic = 951
	Local Const $modelid_amber = 940
	Local Const $modelid_ornate = 954
	Local Const $modelid_dragonmoss = 3718
	Local Const $modelid_dragonroots = 819
#EndRegion
#Region GUI
	Opt("GUIOnEventMode", 1)
	Local Const $maingui = GUICreate("Dragon Moss" & $version, 309, 175)
	Local Const $gsettings = GUICtrlCreateGroup("Settings", 5, 2, 135, 80)
	Local Const $lblname = GUICtrlCreateLabel("Character :", 6, 18, 129, 15, $ss_center)
	Local $txtname = GUICtrlCreateCombo("", 8, 35, 129, 25, BitOR($cbs_dropdown, $cbs_autohscroll))
	GUICtrlSetData(-1, getloggedcharnames(), $mfirstchar)
	Local Const $cbdisablegraphics = GUICtrlCreateCheckbox("Disable Graphics", 10, 60, 97, 17)
	Local Const $lbllog = GUICtrlCreateEdit("", 142, 5, 162, 165, BitOR($es_autovscroll, $es_readonly, $es_wantreturn, $ws_vscroll), 0)
	Local Const $gstats = GUICtrlCreateGroup("Stats", 5, 85, 135, 55)
	Local Const $lblsuccruns = GUICtrlCreateLabel("Success Runs :", 10, 102, 75, 17)
	Local Const $stsuccruns = GUICtrlCreateLabel("0", 90, 102, 49, 17, $ss_center)
	Local Const $lblfailruns = GUICtrlCreateLabel("Fail Runs : ", 10, 120, 75, 17)
	Local Const $stfailruns = GUICtrlCreateLabel("0", 90, 120, 49, 17, $ss_center)
	Local Const $btstart = GUICtrlCreateButton("Start", 4, 145, 67, 25, $bs_vcenter)
	Local Const $bexit = GUICtrlCreateButton("Exit", 74, 145, 67, 25, $bs_vcenter)
	GUISetOnEvent($gui_event_close, "EventHandler")
	GUICtrlSetOnEvent($cbdisablegraphics, "EventHandler")
	GUICtrlSetOnEvent($btstart, "EventHandler")
	GUICtrlSetOnEvent($bexit, "EventHandler")
	TraySetIcon("icon.ico")
	GUISetIcon("icon.ico")
	GUISetState(@SW_SHOW)
#EndRegion
#Region Loops
	Do
		Sleep(100)
	Until $binitialized
	initpacket()
	While 1
		If $brunning Then
			manageinventory()
			If getmapid() <> $mapid_anjeka Then
				travelto($mapid_anjeka)
				$bresignrdy = False
			EndIf
			If NOT $bresignrdy Then
				getresignready()
			EndIf
			If dojob() Then
				$nbruns += 1
				GUICtrlSetData($stsuccruns, $nbruns)
			Else
				$nbfails += 1
				GUICtrlSetData($stfailruns, $nbfails)
			EndIf
			If NOT $brunning Then _travelgh()
			If Mod($nbruns, 20) = 0 AND NOT $mrendering Then _purgehook()
		EndIf
		Sleep(250)
	WEnd

	Func eventhandler()
		Switch @GUI_CtrlId
			Case $gui_event_close
				If NOT $mrendering Then togglerendering()
				Exit
			Case $bexit
				If NOT $mrendering Then togglerendering()
				Exit
			Case $btstart
				If $brunning Then
					GUICtrlSetData($btstart, "Resume")
					$brunning = False
				ElseIf $binitialized Then
					GUICtrlSetData($btstart, "Pause")
					$brunning = True
				Else
					$brunning = True
					GUICtrlSetData($btstart, "Initializing...")
					GUICtrlSetState($btstart, $gui_disable)
					GUICtrlSetState($txtname, $gui_disable)
					WinSetTitle($maingui, "", GUICtrlRead($txtname))
					TraySetToolTip(GUICtrlRead($txtname))
					If GUICtrlRead($txtname) = "" Then
						If initialize(ProcessExists("gw.exe"), True, True, False) = False Then
							MsgBox(0, "Error", "Guild Wars it not running.")
							Exit
						EndIf
					Else
						If initialize(GUICtrlRead($txtname), True, True, False) = False Then
							MsgBox(0, "Error", "Can't find a Guild Wars client with that character name.")
							Exit
						EndIf
					EndIf
					GUICtrlSetData($btstart, "Pause")
					GUICtrlSetState($btstart, $gui_enable)
					$binitialized = True
				EndIf
			Case $cbdisablegraphics
				togglerendering()
		EndSwitch
	EndFunc

#EndRegion

Func getresignready()
	LoadSkillTemplate("OgcTcZ885RgNB1ZHQWZoT48cAA")
	out("Preparing resign")
	move(-11209, -23100)
	waitmaploading($mapid_drazach, 45000)
	move(-11229, 20150)
	waitmaploading($mapid_anjeka, 45000)
	switchmode(1)
	$bresignrdy = True
EndFunc

Func dojob()
	Local $ldeadlock
	out("Going outside")
	move(-11209, -23100)
	waitmaploading($mapid_drazach)
	If getmapid() <> $mapid_drazach Then Return False
	initpointers()
	targetnearestally()
	Sleep(50)
	useskill(2, -2)
	_useskillex($skill_return[0], -1, 8000)
	moveto(-7924, 18281)
	useskill($skill_serpent[0], $myptr)
	_useskillex($skill_shadowform[0])
	_useskillex($skill_shroud[0])


	out("Balling dragons")
	moveto(-7086, 17979)
	_useskillex($skill_storm[0])
	moveto(-6153, 16621)
	moveto(-5404, 15538)
	moveto(-6111, 17160, 5)
	out("SoH")
	useskill($skill_soh[0], $myptr)
	moveto(-6604, 18585, 5)
	useskillex($skill_winnowing[0])
	Do
	Sleep(250)
	Until GetSkillbarSkillRecharge(3) = 0
	useskillex($skill_shadowform[0])
	Out("Killing.")
	Sleep(250)
	If NOT getisdead($myptr) Then out("Killing")
	useskill($skill_whirling[0], $myptr)

	$ldeadlock = TimerInit()
	Do
		Sleep(500)
	Until getnumberoffoesinrangeofagent($myptr, $range_adjacent, $modelid_dragonmoss) = 0 OR getisdead($myptr) OR TimerDiff($ldeadlock) > 20000
	rndsleep(250)
	_pickuploot()
	If getisdead($myptr) Then
		out("Failed")
		resigntooutpost(True)
		Return False
	Else
		resigntooutpost(False)
		Return True
	EndIf
EndFunc

#Region CastEngine

	Func _useskillex($askillslot, $atarget = $myptr, $atimeout = 3000, $askillbarptr = $skillbar)
		Local $lskillptr = getskillptr(getskillbarskillid($askillslot, 0, $askillbarptr))
		Local $laftercast = memoryread($lskillptr + 64, "float") * 1000
		useskill($askillslot, $atarget)
		Local $ltimer = TimerInit()
		Do
			Sleep(50)
			If getisdead($myptr) Then Return
		Until getskillbarskillrecharge($askillslot, 0, $askillbarptr) <> 0 OR TimerDiff($ltimer) > $atimeout
	EndFunc

#EndRegion
#Region PickUp

	Func _pickuploot($aminslots = 2)
		Local $lmex, $lmey, $lagentx, $lagenty
		Local $lslots = countslots()
		Local $lagentarray = memoryreadagentptrstruct(1, 1024)
		For $i = 1 To $lagentarray[0]
			If getisdead($myptr) Then Return False
			$lagentid = memoryread($lagentarray[$i] + 44, "long")
			$litemptr = getitemptrbyagentid($lagentid)
			If $litemptr = 0 Then ContinueLoop
			$litemtype = memoryread($litemptr + 32, "byte")
			If $lslots < $aminslots Then
				If $litemtype <> 11 AND $litemtype <> 20 Then ContinueLoop
			EndIf
			If NOT canpickup($litemptr) Then ContinueLoop
			updateagentposbyptr($myptr, $lmex, $lmey)
			updateagentposbyptr($lagentarray[$i], $lagentx, $lagenty)
			$ldistance = Sqrt(($lmex - $lagentx) ^ 2 + ($lmey - $lagenty) ^ 2)
			If $ldistance > 2000 Then ContinueLoop
			pickupitems($lagentarray[$i], $lagentid, $lagentx, $lagenty, $ldistance, $myptr)
		Next
	EndFunc

	Func canpickup($aitemptr)
		Local $lmodelid = memoryread($aitemptr + 44, "long")
		Local $litemtype = memoryread($aitemptr + 32, "byte")
		If $litemtype = 20 Then Return True
		If $pickupall Then
			If $lmodelid = 146 Then
				$extra = memoryread($aitemptr + 34, "short")
				If $extra = 10 OR $extra = 12 Then Return True
				Return False
			EndIf
			If $lmodelid = 21799 Then Return False
			Return True
		EndIf
		Switch $lmodelid
			Case $modelid_dragonroots
				Return True
			Case $modeid_breambellong, $modeid_breambelrecurve, $modeid_breambelshort, $modeid_breambelflat, $modeid_breambelhorn
				Return True
			Case 22751
				Return True
			Case 146
				$extra = memoryread($litemptr + 34, "short")
				If $extra = 10 OR $extra = 12 Then Return True
			Case $modelid_amber, $modelid_echovald, $modelid_gothic, $modelid_ornate
				If getrarity($aitemptr) = $rarity_gold Then Return True
		EndSwitch
		Return False
	EndFunc

#EndRegion
#Region Inventory

	Func manageinventory()
		LoadSkilltemplate("OgcTcZ885RgNB1ZHQWZoT48cAA")
		Local $lmapid_hall
		out("Checking Inventory")
		If getgoldcharacter() > 90000 Then depositgold()
		If countslots() < 5 Then
			_travelgh()
			$lmapid_hall = getmapid()
			gotonpc(getplayerptrbyplayernumber(getmerchant($lmapid_hall)))
			_inventory()
		EndIf
	EndFunc

	Func _inventory()
		_identify()
		_sell()
		_salvage()
		_store()
		depositgold()
		Sleep(getping() + 500)
	EndFunc

	Func _identify()
		Local $lbag, $litem
		For $j = 1 To 4
			out("Identifying bag " & $j)
			$lbag = getbagptr($j)
			For $i = 1 To memoryread($lbag + 32, "long")
				idkit()
				$litem = getitemptrbyslot($lbag, $i)
				If NOT memoryread($litem) Then ContinueLoop
				If getisunided($litem) Then
					identifyitem($litem)
				EndIf
				Sleep(getping() * 3)
			Next
		Next
	EndFunc

	Func _salvage()
		Local $lquantityold, $loldvalue
		salvagekit()
		Local $lsalvagekitid = findsalvagekit(1, 4)
		Local $lsalvagekitptr = getitemptr($lsalvagekitid)
		For $bag = 1 To 4
			$lbagptr = getbagptr($bag)
			If $lbagptr = 0 Then ContinueLoop
			For $slot = 1 To memoryread($lbagptr + 32, "long")
				$litem = getitemptrbyslot($lbagptr, $slot)
				If NOT getcansalvage($litem) Then ContinueLoop
				out("Salvaging : " & $bag & "," & $slot)
				$lquantity = memoryread($litem + 75, "byte")
				$itemmid = memoryread($litem + 44, "long")
				$itemrarity = getrarity($litem)
				If $itemrarity = $rarity_white OR $itemrarity = $rarity_blue Then
					For $i = 1 To $lquantity
						If memoryread($lsalvagekitptr + 12, "ptr") = 0 Then
							salvagekit()
							$lsalvagekitid = findsalvagekit(1, 4)
							$lsalvagekitptr = getitemptr($lsalvagekitid)
						EndIf
						$lquantityold = $lquantity
						$loldvalue = memoryread($lsalvagekitptr + 36, "short")
						startsalvage($litem, $lsalvagekitid)
						Local $ldeadlock = TimerInit()
						Do
							Sleep(200)
						Until memoryread($lsalvagekitptr + 36, "short") <> $loldvalue OR TimerDiff($ldeadlock) > 5000
					Next
				ElseIf $itemrarity = $rarity_purple OR $itemrarity = $rarity_gold Then
					$itemtype = memoryread($litem + 32, "byte")
					If $itemtype = 0 Then
						ContinueLoop
					EndIf
					If memoryread($litem + 12, "ptr") <> 0 Then
						If memoryread($lsalvagekitptr + 12, "ptr") = 0 Then
							salvagekit()
							$lsalvagekitid = findsalvagekit(1, 4)
							$lsalvagekitptr = getitemptr($lsalvagekitid)
						EndIf
						$loldvalue = memoryread($lsalvagekitptr + 36, "short")
						startsalvage($litem, $lsalvagekitid)
						Sleep(500 + getping())
						salvagematerials()
						Local $ldeadlock = TimerInit()
						Do
							Sleep(200)
						Until memoryread($lsalvagekitptr + 36, "short") <> $loldvalue OR TimerDiff($ldeadlock) > 5000
					EndIf
				EndIf
			Next
		Next
		salvagekit()
	EndFunc

	Func getcansalvage($aitemptr)
		If memoryread($aitemptr + 24, "ptr") <> 0 Then Return False
		Local $litemtype = memoryread($aitemptr + 32, "byte")
		If $litemtype <> 5 Then Return False
		Local $lmodelid = memoryread($aitemptr + 44, "long")
		Switch $lmodelid
			Case $modeid_breambellong, $modeid_breambelrecurve, $modeid_breambelshort, $modeid_breambelflat, $modeid_breambelhorn
				Return True
		EndSwitch
		Return False
	EndFunc

	Func _sell()
		Local $lbag, $litem, $lmod
		out("Selling")
		For $j = 1 To 4
			$lbag = getbagptr($j)
			For $i = 1 To memoryread($lbag + 32, "long")
				$litem = getitemptrbyslot($lbag, $i)
				If $litem == 0 Then ContinueLoop
				If memoryread($litem + 24, "ptr") <> 0 Then ContinueLoop
				If memoryread($litem + 36, "short") <= 0 Then ContinueLoop
				If memoryread($litem + 76, "byte") <> 0 Then ContinueLoop
				Switch getrarity($litem)
					Case 2621
					Case 2623, 2624, 2626
						If NOT getisided($litem) Then ContinueLoop
					Case Else
						ContinueLoop
				EndSwitch
				Switch memoryread($litem + 32, "byte")
					Case 5
						Local $lmodelid = memoryread($litem + 44, "long")
						If $lmodelid = $modeid_breambelrecurve OR $lmodelid = $modeid_breambellong OR $lmodelid = $modeid_breambelshort OR $lmodelid = $modeid_breambelflat OR $lmodelid = $modeid_breambelhorn Then ContinueLoop
					Case 24
						Local $lmod = getdualmodshield($litem)
						If $lmod <> False Then
							Local $lmodelid = memoryread($litem + 44, "long")
							Local $larr[] = [$lmodelid, getitemreq($litem), $lmod]
							sendsafepacket(prepare("drop", $larr))
						EndIf
						If getrarity($litem) = $rarity_gold AND memoryread($litem + 20, "long") = 5 Then ContinueLoop
					Case 10
						Switch memoryread($litem + 34, "short")
							Case 10, 12
								ContinueLoop
							Case Else
						EndSwitch
					Case 18
						ContinueLoop
					Case 11
						If memoryread($litem + 44, "long") = 934 Then ContinueLoop
					Case 29
						ContinueLoop
					Case 30
						ContinueLoop
					Case Else
				EndSwitch
				sellitem($litem)
				Sleep(getping() + 500)
			Next
		Next
	EndFunc

	Func _store()
		Local $lbag, $litem, $lslot, $litemtype
		For $j = 1 To 4
			out("Storing bag " & $j)
			$lbag = getbagptr($j)
			If ischestfull() Then Return
			For $i = 1 To memoryread($lbag + 32, "long")
				$litem = getitemptrbyslot($lbag, $i)
				If $litem = 0 Then ContinueLoop
				$litemtype = memoryread($litem + 32, "byte")
				Switch $litemtype
					Case 11, 30
						If memoryread($litem + 75, "byte") <> 250 Then ContinueLoop
					Case 24
					Case Else
						ContinueLoop
				EndSwitch
				$lslot = openstorageslot()
				If IsArray($lslot) Then
					moveitem($litem, $lslot[0], $lslot[1])
					Sleep(getping() + Random(500, 750, 1))
				EndIf
			Next
		Next
	EndFunc

	Func idkit()
		If findidkit(1, 4) = 0 Then
			out("ID kit")
			If getgoldcharacter() < 100 Then
				out("Golds")
				withdrawgold(100)
				rndsleep(1000)
			EndIf
			buyitem(5, 1, 100)
			rndsleep(1000)
		EndIf
	EndFunc

	Func salvagekit()
		If findsalvagekit(1, 4) = 0 Then
			out("Salvage kit")
			If getgoldcharacter() < 100 Then
				out("Golds")
				withdrawgold(100)
				rndsleep(1000)
			EndIf
			buyitem(2, 1, 100)
			rndsleep(1000)
		EndIf
	EndFunc

	Func ischestfull()
		If countslotschest() = 0 Then
			out("Chest Full")
			Return True
		EndIf
		Return False
	EndFunc

#EndRegion
#Region Travel

	Func _travelgh()
		Local $larray_gh[16] = [4, 5, 6, 52, 176, 177, 178, 179, 275, 276, 359, 360, 529, 530, 537, 538]
		Local $lmapid = getmapid()
		If _arraysearch($larray_gh, $lmapid) <> -1 Then Return
		travelgh()
	EndFunc

	Func resigntooutpost($aisdead)
		out("Resigning")
		resign()
		Do
			Sleep(100)
		Until getisdead($myptr)
		If $aisdead Then
			rndsleep(4000)
		Else
			rndsleep(1500)
		EndIf
		returntooutpost()
		waitmaploading($mapid_anjeka)
	EndFunc

#EndRegion
#Region GUI Functions

	Func out($astring)
		Local $lstringlen = StringLen($astring)
		Local $leditlen = _guictrledit_gettextlen($lbllog)
		Local $timestamp = "[" & @HOUR & ":" & @MIN & ":" & @SEC & "] "
		If $lstringlen + $leditlen > 30000 Then
			GUICtrlSetData($lbllog, StringRight(_guictrledit_gettext($lbllog), 30000 - $lstringlen - 1000))
		EndIf
		_guictrledit_appendtext($lbllog, @CRLF & $timestamp & $astring)
		_guictrledit_scroll($lbllog, 1)
	EndFunc

	Func getchecked($guictrl)
		Return (GUICtrlRead($guictrl) == $gui_checked)
	EndFunc

#EndRegion GUI Functions

Func getdualmodshield($aitem)
	Local $lhp, $lhpench, $lhpstan
	Local $lredench, $lredstance, $lredhexed, $lreddam
	Local $larmorvs, $larmort
	$lhp = getmodbyidentifier($aitem, "4823")[1]
	$lhpench = getmodbyidentifier($aitem, "6823")[1]
	$lredench = getmodbyidentifier($aitem, "8820")[0]
	$lreddam = getmodbyidentifier($aitem, "7820")[1]
	$larmorvs = getmodbyidentifier($aitem, "4821")[0]
	$larmort = getmodbyidentifier($aitem, "4821")[1]
	If $larmort = 8 AND $larmorvs = 10 Then
		If $lhp = 30 Then
			Return "+10 Demons/+30"
		EndIf
		If $lhpench = 45 Then
			Return "+10 Demons/+45^e"
		EndIf
		If $lredench = 2 Then
			Return "+10 Demons/-2^e"
		EndIf
	EndIf
	If $lhp = 30 Then
		If $lreddam = 20 Then
			Return "+30/-5"
		EndIf
	EndIf
	Return False
EndFunc
